---
original: f7766f0bd9bb14f76479c01e77388fd1a8823cb17c2919a317d51038a9e1be69
---

---
eip: 4895
title: ベーコンチェーンからのプッシュ型ウィズドロー
description: 新しい "システムレベル" の操作タイプを介して、ベーコンチェーンからEVMへのバリデーターウィズドローをサポートする。
author: Alex Stokes (@ralexstokes), Danny Ryan (@djrtwo)
discussions-to: https://ethereum-magicians.org/t/eip-4895-beacon-chain-withdrawals-as-system-level-operations/8568
status: Final
type: Standards Track
category: Core
created: 2022-03-10
---

## 概要

ベーコンチェーンからEVMへのバリデーターウィズドローをサポートするシステムレベルの "操作" を導入する。

これらの操作は、指定された受取人への無条件の残高増加を生み出す。

## 動機

このEIPは、ベーコンチェーンで行われたバリデーターウィズドローがEVMに入る方法を提供します。
アーキテクチャは "プッシュ" ベースであり、"プル" ベースではありません。つまり、ウィズドローはコンセンサスレイヤーから取り出されるとすぐに実行レイヤーで処理される必要があります。

ウィズドローは、実行ペイロードの新しいタイプのオブジェクト "操作" として表され、ウィズドロー機能をユーザーレベルのトランザクションから分離します。
この方法は、新しいトランザクションタイプを導入する以前のアプローチよりも複雑ですが、この "システムレベル" の操作を通常のトランザクションから明確に分離することができます。
この分離により、システムレベルの懸念とユーザーデータを混在させることによって生じる相互作用効果を減らすことで、テストが簡素化され (したがって、セキュリティが向上します)。

さらに、このアプローチは "プル" ベースの代替案よりもコアプロトコルの観点では複雑ですが、プロトコル自体に重要な機能をより密接に統合することができます。

## 仕様

| 定数                          | 値                                            | 単位
|---                            |---                                             |---
| `FORK_TIMESTAMP`              | 1681338455                                     |

実行タイムスタンプ `FORK_TIMESTAMP` 以降、実行クライアントは以下の拡張を行う必要があります:

### システムレベルの操作: ウィズドロー

コンセンサスレイヤーで検証されたウィズドローを記述する新しいペイロードレベルのオブジェクト `withdrawal` を定義する。
`Withdrawal` はユーザーレベルのトランザクションと構文的に似ていますが、ユーザーレベルのトランザクションとは別のドメインに存在します。

`Withdrawal` は、コンセンサスレイヤーからの重要な情報を提供します:

1. 0から始まり、1ずつ増加する一意の `index` (64ビット整数値) 
2. ウィズドローが対応するコンセンサスレイヤーのバリデーターの `validator_index` (64ビット整数値)
3. ウィズドローされたETHを受け取る `address` (20バイト値)
4. Gwei (1e9 wei) 単位の非ゼロの `amount` (64ビット整数値)

*注意*: 各ウィズドローの `index` は、すべてのウィズドローの連続した番号付けです。

`Withdrawal` オブジェクトは、スキーマ `[index, validator_index, address, amount]` に従ってRLPリストとしてシリアル化されます。

### 実行ペイロードの新しいフィールド: ウィズドロー

実行ペイロードに新しい `withdrawals` フィールドが追加され、これは `Withdrawal` データのRLPリストです。

例:

```python
withdrawal_0 = [index_0, validator_index_0, address_0, amount_0]
withdrawal_1 = [index_1, validator_index_1, address_1, amount_1]
withdrawals = [withdrawal_0, withdrawal_1]
```

この新しいフィールドは、既存のフィールドの後にエンコードされ、実行ペイロードのボディの一部と見なされます。

```python
execution_payload_rlp = RLP([header, transactions, [], withdrawals])

execution_payload_body_rlp = RLP([transactions, [], withdrawals])
```

注意: この構造の空のリストは、[EIP-3675](./eip-3675.md) により `ommers` 値が固定定数に設定されているためです。

### 実行ペイロードヘッダーの新しいフィールド: ウィズドロー root

実行ペイロードヘッダーに新しいフィールドが追加され、`withdrawals` をコミットします。

このコミットメントは、既存の実行ペイロードヘッダーのトランザクションルートと同様の方法で構築されます。つまり、`withdrawals` リストの各ウィズドローをインデックスをキーとするMerkle-Patriciaトライに挿入します。

```python
def compute_trie_root_from_indexed_data(data):
    trie = Trie.from([(i, obj) for i, obj in enumerate(data)])
    return trie.root

execution_payload_header.withdrawals_root = compute_trie_root_from_indexed_data(execution_payload.withdrawals)
```

実行ペイロードヘッダーに、与えられた実行ペイロードのウィズドローリストをコミットするトライのルート32バイトが含まれるようになります。

例:

```python
execution_payload_header_rlp = RLP([
  parent_hash,
  0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347, # ommers hash
  coinbase,
  state_root,
  txs_root,
  receipts_root,
  logs_bloom,
  0, # difficulty
  number,
  gas_limit,
  gas_used,
  timestamp,
  extradata,
  prev_randao,
  0x0000000000000000, # nonce
  base_fee_per_gas,
  withdrawals_root,
])
```

注意: このサンプルのフィールド名と定数値は[EIP-3675](./eip-3675.md)と[EIP-4399](./eip-4399.md)を反映しています。詳細はそれらのEIPを参照してください。

### 実行ペイロードの有効性

実行ペイロードが適切にフォーマットされていることを前提として、実行クライアントには追加のペイロード検証があり、`withdrawals_root` がペイロードのリストから期待される値と一致することを確認する必要があります。

```python
assert execution_payload_header.withdrawals_root == compute_trie_root_from_indexed_data(execution_payload.withdrawals)
```

### 状態遷移

実行ペイロードの `withdrawals` は、ユーザーレベルのトランザクションが適用された **後** に処理されます。

`execution_payload.withdrawals` のリストの各 `withdrawal` について、指定された `address` の残高を `amount` だけ増加させます。

`amount` はGwei単位で指定されているため、状態の残高を扱う際にはweiに変換する必要があることに注意してください。

この残高変更は無条件であり、**失敗してはいけません**。

この操作にはガスコストはありません。

## 根拠

### なぜ新しいトランザクションタイプではないのか?

このEIPは、"ウィズドロー操作" という新しいタイプのオブジェクトを提案しています。これは、既存の他のEVMトランザクションとは異なる特別な意味を持っているためです。

操作はエンドユーザーではなくシステム全体によって開始されます。

新しいタイプのオブジェクトを導入することで、ウィズドローのテストとセキュリティレビューを簡素化するために、一般的なEVM実行からこの種の処理を隔離することができます。

### なぜウィズドロータイプにガスコストがないのか?

実行レイヤーに到達できるウィズドローの最大数は制限されており (コンセンサスレイヤーによって強制される)、この制限は実行レイヤーの運用コストが全体的なペイロード実行の文脈で無視できるように設定されています。

この制限は、計算コスト (状態の数百件の更新のみ) とストレージ/ネットワークコスト (現在のパラメータ設定では追加のオーバーヘッドが現在の平均ペイロードサイズの約1%) の両方に適用されます。

### なぜ残高更新のみなのか? 一般的なEVM実行はないのか?

より一般的な処理を導入すると、失敗のリスクが高まり、ベーコンチェーンでの会計処理が複雑になります。

このEIPは、最小限のコスト (複雑さ) で大部分の利点を提供する、ウィズドローへのルートを提案しています。

## 下位互換性

問題はありません。

## セキュリティ上の考慮事項

ウィズドローのトランザクションのコンセンサスレイヤーでの検証は、適切な量のETHが実行レイヤーに返金されることを保証するために非常に重要です。
このコンセンサスレイヤーから実行レイヤーへのETH転送は、EVMでは現在の類似例がなく、非常に高いセキュリティレビューを受ける必要があります。

## 著作権

著作権およびそれに関連する権利は[CC0](../LICENSE.md)で放棄されています。