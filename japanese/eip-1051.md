---
original: ab3c197ec044cb80ac5b2c86afd458e29fc9ae41af9a746392b9ac9131368e8b
---

---
eip: 1051
title: EVMの算術オーバーフロー検査
author: Nick Johnson <arachnid@notdot.net>
discussions-to: https://ethereum-magicians.org/t/eip-arithmetic-overflow-detection-for-the-evm/261
status: 停滞
type: Standards Track
category: Core
created: 2018-05-02
---

## 概要
このEIPはEVM算術演算のオーバーフロー検査と、オーバーフローフラグをチェックおよびクリアする2つの新しいオペコードを追加します。

## 動機
多くのコントラクトの正常な動作は、算術演算のオーバーフローを検出し防ぐことに依存しています。EVMは2^256の整数を扱いますが、組み込みのオーバーフロー検出や防止機能はありません。そのため、各算術演算の後にオーバーフローを手動でチェックする必要があります。

効率的で安全なコントラクトを実現するため、オーバーフローを効率的に検出できるオペコードを提案します。これにより、各演算の後ではなく定期的にチェックできるようになります。

## 仕様

EVMの状態に2つの新しいフラグが追加されます: オーバーフロー(`ovf`)と符号付きオーバーフロー(`sovf`)です。

`ovf`フラグは以下の場合に設定されます:

 - `ADD`(`0x01`)オペコードで、両方の入力を符号なし整数として扱った場合に、理想的な出力が2^256 - 1を超えるとき。
 - `SUB`(`0x03`)オペコードで、両方の入力を符号なし整数として扱った場合に、理想的な出力がマイナスになるとき。
 - `MUL`(`0x02`)オペコードで、両方の入力を符号なし整数として扱った場合に、理想的な出力が2^256 - 1を超えるとき。

`sovf`フラグは`ovf`フラグが設定されたときに設定され、さらに以下の場合にも設定されます:

 - `ADD`オペコードで、両方の入力の最上位ビットが同じ場合に出力の最上位ビットが異なるとき(例: `(+a) + (+b) = (-c)` または `(-a) + (-b) = (+c)`)。
 - `SUB`オペコードで、結果の最上位ビットが減算対象(第2引数)と同じ場合(例: `(+a) - (-b) = (-c)` または `(-a) - (+b) = (+c)`)。
 - `MUL`オペコードで、両方の入力が正の場合に出力がマイナスになるとき。
 - `MUL`オペコードで、両方の入力がマイナスの場合に出力がマイナスになるとき。
 - `MUL`オペコードで、一方の入力がマイナス、もう一方が正の場合に出力が正になるとき。

新しいオペコード`OFV`(番号`0x0c`)が追加されます。このオペコードはスタックから引数を取りません。実行すると、`ovf`フラグが設定されていれば`1`を、そうでなければ`0`をプッシュします。その後、`ovf`フラグをfalseにします。

新しいオペコード`SOVF`(番号`0x0d`)が追加されます。このオペコードはスタックから引数を取りません。実行すると、`sovf`フラグが設定されていれば`1`を、そうでなければ`0`をプッシュします。その後、`sovf`フラグをfalseにします。

## 根拠
オーバーフロー保護を実装するには、既存のコントラクトの動作を維持する必要があるため、算術演算自体への多くの変更は避けられます。オーバーフローが発生した場合にスローまたはリバートするオペコードを提供するのも1つの選択肢ですが、これではオーバーフローの処理方法が制限されてしまいます。

代わりに、実際のCPUで一般的に実装されている「キャリー」と「オーバーフロー」フラグの機能を複製します。

符号付きと符号なしのオーバーフローフラグを別々に設けるのは、符号付きオーバーフローが符号なしオーバーフローにはならない場合があるためです。

## 下位互換性
このEIPには下位互換性の問題はありません。

## テストケース
TBD

## 実装
TBD

## 著作権
著作権およびその関連権利は[CC0](../LICENSE.md)で放棄されています。