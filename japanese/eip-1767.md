---
original: c0d984cc244deead94f0cfe5164e5d672d16677210877bdfea6624729d765528
---

---
eip: 1767
title: Ethereum ノードデータへのGraphQLインターフェース
author: Nick Johnson (@arachnid)、Raúl Kripalani (@raulk)、Kris Shinn (@kshinn)
discussions-to: https://ethereum-magicians.org/t/graphql-interface-to-ethereum-node-data/2710
status: 停滞
type: Standards Track
category: Interface
created: 2019-02-14
---

## 概要
このEIPは、Ethereumノードに保存されているデータにアクセスするためのGraphQLスキーマを指定しています。現在のJSON-RPCインターフェースの読み取り専用情報を完全に置き換えることを目的としており、使いやすさ、一貫性、効率性、および将来性の向上を図っています。

## 動機
Ethereumノードの現在のJSON-RPCインターフェースには多くの欠点があります。一部の領域では非公式かつ不完全に指定されているため、空の16進数文字列の表現("" vs "0x" vs "0x0")などの互換性の問題が生じています。また、ユーザーが要求するデータを推測する必要があるため、しばしば不要な作業が発生します。

例えば、`totalDifficulty`フィールドは一般的なEthereumノードの実装では別個に保存されていますが、多くのコールでこのフィールドは必要とされていません。しかし、`eth_getBlock`の各呼び出しでこのフィールドが取得されるため、別のディスク読み取りが必要になります。これは、RPCサーバーがこのフィールドが必要かどうかを知る方法がないためです。

同様に、go-ethereumのトランザクションレシートはブロックごとに単一のバイナリブロブとして保存されています。単一のトランザクションのレシートを取得するには、このブロブを取得して逆シリアル化し、関連するエントリを見つけて返す必要があります。これは`eth_getTransactionReceipt`APIコールによって実現されています。APIコンシューマーの一般的なタスクはブロック内のすべてのレシートを取得することですが、その結果、ノードの実装ではデータが繰り返し取得および逆シリアル化されるため、ブロック内のすべてのトランザクションレシートを取得するのに`O(n^2)`の努力が必要になるのではなく、`O(n)`で済むはずです。

これらの問題の一部は既存のJSON-RPCインターフェースへの変更で修正できますが、インターフェースがやや複雑になります。代わりに、より効率的なAPI実装を可能にし、柔軟性も高めるための標準クエリ言語であるGraphQLの採用を提案します。

## 先行事例

Nick JohnsonとEthQL(https://github.com/ConsenSys/ethql)は独立してノードデータ用のGraphQLスキーマを開発しました。当事者が共同作業に気づいた後、両者はスキーマの調整に努めました。このEIPで提案されている現在のスキーマは主にEthQLスキーマに基づいています。

## 仕様

### ノードAPI

互換性のあるノードは、HTTPを介してGraphQLエンドポイントを提供する必要があります。これはデフォルトで8547ポートで提供されるべきです。GraphQLエンドポイントのパスは'/graphql'とする必要があります。

互換性のあるノードは、ルートパス('/')でGraphiQLインタラクティブクエリエクスプローラを提供してもよいです。

### スキーマ

このサービスのGraphQLスキーマは次のように定義されます:
```
# Bytes32は32バイトのバイナリ文字列で、0x接頭辞の16進数で表されます。
scalar Bytes32
# Addressは20バイトのEthereum アドレスで、0x接頭辞の16進数で表されます。
scalar Address
# Bytesは任意長のバイナリ文字列で、0x接頭辞の16進数で表されます。
# 空のバイト文字列は'0x'で表されます。バイト文字列の16進数ニブルは偶数でなければなりません。
scalar Bytes
# BigIntは大きな整数です。入力はJSONの数値またはストリングとして受け付けられます。
# ストリングは10進数または0x接頭辞の16進数のいずれかです。出力値はすべて0x接頭辞の16進数です。
scalar BigInt
# Longは64ビットの符号なし整数です。
scalar Long

schema {
    query: Query
    mutation: Mutation
}

# Accountは特定のブロックにおけるEthereum アカウントです。
type Account {
    # Addressはこのアカウントを所有するアドレスです。
    address: Address!
    # Balanceはアカウントの残高(wei単位)です。
    balance: BigInt!
    # TransactionCountはこのアカウントから送信されたトランザクションの数、
    # または契約の場合は作成された契約の数です。これはノンスとも呼ばれます。
    transactionCount: Long!
    # Codeはこのアカウントのスマートコントラクトコード(自己破壊されていない場合)です。
    code: Bytes!
    # Storageは契約アカウントのストレージにアクセスできます。32バイトのスロット識別子でインデックス化されています。
    storage(slot: Bytes32!): Bytes32!
}

# Logは Ethereum イベントログです。
type Log {
    # Indexはブロック内のこのログのインデックスです。
    index: Int!
    # Accountはこのログを生成したアカウント - これは常に契約アカウントになります。
    account(block: Long): Account!
    # Topicsはログのインデックス付きトピックのリストです(0-4個)。
    topics: [Bytes32!]!
    # Dataはこのログの非インデックス付きデータです。
    data: Bytes!
    # Transactionはこのログエントリを生成したトランザクションです。
    transaction: Transaction!
}

# Transactionは Ethereum トランザクションです。
type Transaction {
    # Hashはこのトランザクションのハッシュです。
    hash: Bytes32!
    # Nonceはこのトランザクションが生成されたアカウントのノンスです。
    nonce: Long!
    # Indexはこのトランザクションの親ブロック内のインデックスです。まだマイニングされていない場合、これはnullになります。
    index: Int
    # Fromはこのトランザクションを送信したアカウント - これは常に外部所有アカウントになります。
    from(block: Long): Account!
    # Toはトランザクションが送信されたアカウントです。これは契約作成トランザクションの場合はnullになります。
    to(block: Long): Account
    # Valueはこのトランザクションと一緒に送信されたwei単位の値です。
    value: BigInt!
    # GasPriceはマイナーに提供されるガス単価(wei単位)です。
    gasPrice: BigInt!
    # Gasはこのトランザクションが消費できる最大ガス量です。
    gas: Long!
    # InputDataはターゲットに送信されたデータです。
    inputData: Bytes!
    # Blockはこのトランザクションがマイニングされたブロックです。まだマイニングされていない場合、これはnullになります。

    # Statusはトランザクションの返戻ステータスです。成功した場合は1、失敗した場合(リバートまたはガス切れにより)は0になります。まだマイニングされていない場合、このフィールドはnullになります。
    status: Long
    # GasUsedはこのトランザクションの処理に使用されたガス量です。
    # まだマイニングされていない場合、このフィールドはnullになります。
    gasUsed: Long
    # CumulativeGasUsedはこのトランザクションまでのブロック内の合計ガス使用量です。
    # まだマイニングされていない場合、このフィールドはnullになります。
    cumulativeGasUsed: Long
    # CreatedContractは契約作成トランザクションによって作成されたアカウントです。
    # トランザクションが契約作成トランザクションでない場合、または
    # まだマイニングされていない場合、このフィールドはnullになります。
    createdContract(block: Long): Account
    # Logsはこのトランザクションによって発行されたログエントリのリストです。
    # まだマイニングされていない場合、このフィールドはnullになります。
}

# BlockFilterCriteriaは単一のブロックに適用されるログフィルタ基準をカプセル化します。
input BlockFilterCriteria {
    # Addressesは関心のあるアドレスのリストです。このリストが空の場合、アドレスによるフィルタリングは行われません。
    addresses: [Address!]
    # Topicsリストは特定のイベントトピックに一致するものに制限します。各イベントにはトピックのリストがあります。
    # Topicsはそのリストの先頭部分に一致します。空の要素配列は任意のトピックに一致します。
    # 非空の要素は、含まれるトピックのいずれかに一致する代替案を表します。
    #
    # 例:
    #  - [] or nil          任意のトピックリストに一致
    #  - [[A]]              最初の位置でトピックAに一致
    #  - [[], [B]]          最初の位置で任意のトピック、2番目の位置でBに一致
    #  - [[A], [B]]         最初の位置でトピックA、2番目の位置でトピックBに一致
    #  - [[A, B]], [C, D]]  最初の位置で(A OR B)、2番目の位置で(C OR D)に一致
    topics: [[Bytes32!]!]
}

# Blockは Ethereum ブロックです。
type Block {
    # Numberはジェネシスブロックから始まるこのブロックの番号です。
    number: Long!
    # Hashはこのブロックのブロックハッシュです。
    hash: Bytes32!
    # Parentはこのブロックの親ブロックです。
    parent: Block
    # Nonceはマイナーによって決定された8バイトのシーケンスです。
    nonce: Bytes!
    # TransactionsRootはこのブロック内のトランザクショントライのルートのkeccak256ハッシュです。
    transactionsRoot: Bytes32!
    # TransactionCountはこのブロック内のトランザクション数です。
    # トランザクションが利用できない場合、このフィールドはnullになります。
    transactionCount: Int
    # StateRootはこのブロックが処理された後の状態トライのkeccak256ハッシュです。
    stateRoot: Bytes32!
    # ReceiptsRootはこのブロック内のトランザクションレシートトライのkeccak256ハッシュです。
    receiptsRoot: Bytes32!
    # Minerはこのブロックをマイニングしたアカウントです。
    miner(block: Long): Account!
    # ExtraDataはマイナーが提供した任意のデータフィールドです。
    extraData: Bytes!
    # GasLimitはこのブロック内のトランザクションで利用可能な最大ガス量です。
    gasLimit: Long!
    # GasUsedはこのブロック内のトランザクション実行に使用されたガス量です。
    gasUsed: Long!
    # Timestampはこのブロックがマイニングされた Unix タイムスタンプです。
    timestamp: BigInt!
    # LogsBloomはフィルタに一致するログエントリが含まれる可能性があるかどうかを確認するために使用できるブルームフィルタです。
    logsBloom: Bytes!
    # MixHashはPoWプロセスへの入力として使用されたハッシュです。
    mixHash: Bytes32!
    # Difficultyはこのブロックのマイニング難易度の尺度です。
    difficulty: BigInt!
    # TotalDifficultyはこのブロックまでの累積難易度の合計です。
    totalDifficulty: BigInt!
    # OmmerCountはこのブロックに関連付けられたオマー(叔父)ブロックの数です。
    # オマーが利用できない場合、このフィールドはnullになります。
    ommerCount: Int
    # Ommersはこのブロックに関連付けられたオマー(叔父)ブロックのリストです。
    # オマーが利用できない場合、このフィールドはnullになります。
    # ノードによっては、トランザクション、transactionAt、transactionCount、ommers、
    # ommerCount、ommerAtフィールドがオマーブロックで利用できない可能性があります。
    ommers: [Block]
    # OmmerAtは指定されたインデックスのオマー(叔父)を返します。
    # オマーが利用できない、またはインデックスが範囲外の場合、このフィールドはnullになります。
    ommerAt(index: Int!): Block
    # OmmerHashはこのブロックに関連付けられたすべてのオマー(叔父)のkeccak256ハッシュです。
    ommerHash: Bytes32!
    # Transactionsはこのブロックに関連付けられたトランザクションのリストです
# Transactionsはこのブロックに関連付けられたトランザクションのリストです。
    # トランザクションが利用できない場合、このフィールドはnullになります。
    transactions: [Transaction!]
    # TransactionAtは指定されたインデックスのトランザクションを返します。
    # トランザクションが利用できない、またはインデックスが範囲外の場合、
    # このフィールドはnullになります。
    transactionAt(index: Int!): Transaction
    # Logsはこのブロックからフィルタリングされたログエントリを返します。
    logs(filter: BlockFilterCriteria!): [Log!]!
    # Accountは現在のブロックの状態でEthereum アカウントを取得します。
    account(address: Address!): Account
    # Callは現在のブロックの状態でローカルコール操作を実行します。
    call(data: CallData!): CallResult
    # EstimateGasは現在のブロックの状態で成功裏に実行されるトランザクションに必要なガス量を見積もります。
    estimateGas(data: CallData!): Long!
}

# CallDataはローカルコントラクトコールに関連するデータを表します。
# すべてのフィールドはオプションです。
input CallData {
    # Fromはコールを行うアドレスです。
    from: Address
    # Toはコールが送信されるアドレスです。
    to: Address
    # Gasはコールと一緒に送信されるガス量です。
    gas: Long
    # GasPriceはガス単位当たりのオファー価格(wei単位)です。
    gasPrice: BigInt
    # Valueはコールと一緒に送信されるwei単位の値です。
    value: BigInt
    # Dataは呼び出し先に送信されるデータです。
    data: Bytes
}

# CallResultはローカルコール操作の結果です。
type CallResult {
    # Dataは呼び出されたコントラクトの返戻データです。
    data: Bytes!
    # GasUsedはリファンド後のコールで使用されたガス量です。
    gasUsed: Long!
    # Statusはコールの結果 - 成功の場合は1、失敗の場合は0です。
    status: Long!
}

# FilterCriteriaはログエントリを検索するためのログフィルタ基準をカプセル化します。
input FilterCriteria {
    # FromBlockは検索を開始するブロック(包含)です。
    # 指定されていない場合、最新のブロックがデフォルトになります。
    fromBlock: Long
    # ToBlockは検索を停止するブロック(包含)です。
    # 指定されていない場合、最新のブロックがデフォルトになります。
    toBlock: Long
    # Addressesは関心のあるアドレスのリストです。
    # このリストが空の場合、アドレスによるフィルタリングは行われません。
    addresses: [Address!]
    # Topicsリストは特定のイベントトピックに一致するものに制限します。
    # 各イベントにはトピックのリストがあります。Topicsはそのリストの先頭部分に一致します。
    # 空の要素配列は任意のトピックに一致します。非空の要素は、含まれるトピックのいずれかに一致する代替案を表します。
    #
    # 例:
    #  - [] or nil          任意のトピックリストに一致
    #  - [[A]]              最初の位置でトピックAに一致
    #  - [[], [B]]          最初の位置で任意のトピック、2番目の位置でBに一致
    #  - [[A], [B]]         最初の位置でトピックA、2番目の位置でトピックBに一致
    #  - [[A, B]], [C, D]]  最初の位置で(A OR B)、2番目の位置で(C OR D)に一致
    topics: [[Bytes32!]!]
}

# SyncStateにはクライアントの現在の同期状態が含まれています。
type SyncState{
    # StartingBlockは同期が開始されたブロック番号です。
    startingBlock: Long!
    # CurrentBlockは現在同期が到達している地点です。
    currentBlock: Long!
    # HighestBlockは最新のブロック番号です。
    highestBlock: Long!
    # PulledStatesは到達した状態エントリの数、または
    # これが不明または関係ない場合はnullです。
    pulledStates: Long
    # KnownStatesはノードが現在知っている状態の数、または
    # これが不明または関係ない場合はnullです。
    knownStates: Long
}

# Pendingは現在のペンディング状態を表します。
type Pending {
  # TransactionCountはペンディング状態のトランザクション数です。
  transactionCount: Int!
  # Transactionsは現在のペンディング状態のトランザクションのリストです。
  transactions: [Transaction!]
  # Accountはペンディング状態のEthereum アカウントを取得します。
  account(address: Address!): Account
  # Callはペンディング状態でローカルコール操作を実行します。
  call(data: CallData!): CallResult
  # EstimateGasはペンディング状態で成功裏に実行されるトランザクションに必要なガス量を見積もります。
  estimateGas(data: CallData!): Long!  
}

type Query {
    # Blockは番号またはハッシュでEthereum ブロックを取得します。
    # どちらも指定されていない場合、最新のブロックが返されます。
    block(number: Long, hash: Bytes32): Block
    # Blocksは2つの番号の間のすべてのブロックを返します(包含)。
    # toが指定されていない場合、最新のブロックがデフォルトになります。
    blocks(from: Long!, to: Long): [Block!]!
    # Pendingは現在のペンディング状態を返します。
    pending: Pending!
    # Transactionはハッシュで指定されたトランザクションを返します。
    transaction(hash: Bytes32!): Transaction
    # Logsは指定されたフィルタに一致するログエントリを返します。
    logs(filter: FilterCriteria!): [Log!]!
    # GasPriceはトランザクションがタイムリーにマイニングされるのを確実にするのに十分なガス価格の推定値を返します。
    gasPrice: BigInt!
    # ProtocolVersionは現在のワイヤープロトコルバージョン番号を返します。
    protocolVersion: Int!
    # Syncingは現在の同期状態に関する情報を返します。
    syncing: SyncState
}

type Mutation {
    # SendRawTransactionはRLP エンコードされたトランザクションをネットワークに送信します。
    sendRawTransaction(data: Bytes!): Bytes32!
}