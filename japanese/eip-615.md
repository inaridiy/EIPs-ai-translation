---
original: cd00a6703f6c2b387e380a4409ae9f2a5ad67b96af0a403f054e3cd5ab6668ab
---

---
eip: 615
title: EVM用のサブルーチンとスタティックジャンプ
status: 停滞
type: Standards Track
category: Core
author: Greg Colvin <greg@colvin.org>、Brooklyn Zelenka (@expede)、Paweł Bylica (@chfast)、Christian Reitwiessner (@chriseth)
discussions-to: https://ethereum-magicians.org/t/eip-615-subroutines-and-static-jumps-for-the-evm-last-call/3472
created: 2016-12-10
---

## 簡単な要約

21世紀において、数十億ETHが流通するブロックチェーンでは、正式な仕様と検証が損失を防ぐための重要なツールです。しかし、EVMの設計ではこれが不必要に困難になっています。さらに、EVMの設計により、機械コードへのほぼ線形時間のコンパイルが困難になっています。我々は、EVMのセキュリティ保証を強化し、パフォーマンスの障壁を減らすための提案を前に進めることを提案します。

## 概要

現在、EVMコードは静的に分析するのが困難で、ブロックチェーンで経験した多くの高価なバグを防ぐための重要なツールを阻害しています。さらに、Ethereum仮想マシンの現在の実装 - コンパイラを含む - は、プリコンパイルの必要性を減らし、ネットワークの長期的な需要を満たすのに十分なパフォーマンスを持っていません。この提案では、動的ジャンプがこれらの問題の主な理由であると特定し、問題に取り組むためにEVM仕様の変更を提案しています。これにより、より安全で高性能なEVMに向けた取り組みが可能になります。

また、EVM契約が正しくサブルーチンを使用し、スタックの誤用を回避し、ブロックチェーンに置く前に他の安全条件を満たすことを、ほぼ線形時間で検証することを提案します。検証されたコードは、ほとんどのランタイム例外と、それらをテストする必要性を排除します。また、適切な制御フローとスタックの使用は、インタプリタ、コンパイラ、正式な分析、およびその他のツールの生活を容易にします。

## 動機

現在、EVMは動的ジャンプのみをサポートしており、ジャンプ先のアドレスはスタック上の引数になります。さらに、EVMは通常のCPUやWasmが提供するサブルーチンやスイッチなどの代替的な制御フロー機能を提供していません。したがって、動的ジャンプを避けることはできませんが、それらはコードの構造を不明確にし、制御フローと data-flow 分析を主に阻害します。これにより、最適化されたコンパイルの品質とスピードが根本的に対立することになります。さらに、多くのジャンプが潜在的にコード内のジャンプ先に飛べるため、コード内のパスの数は、ジャンプ数とジャンプ先の数の積に増加し、静的分析の時間複雑度も増加します。これらの多くのケースは展開時に決定不可能であり、静的および正式な分析をさらに阻害します。

しかし、Ethereumのセキュリティ要件を考えると、**ほぼ線形**の**`n log n`**時間複雑性が不可欠です。そうしないと、検証と最適化に対するサービス拒否攻撃ベクトルとして使用できる契約を作成または発見できます。

しかし、動的ジャンプがない場合、コードは線形時間で静的に分析できます。これにより、**線形時間の検証**が可能になります。また、`log n`時間で行うコード生成や最適化により、**`n log n`**時間のコンパイラを構成することもできます。

さらに、動的ジャンプがなく、適切なサブルーチンがあれば、EVMはより良いコード生成のターゲットになります。これには以下が含まれます:
* Solidity
* Vyper
* LLVM IR
  * フロントエンドには C、C++、Common Lisp、D、Fortran、Haskell、Java、Javascript、Kotlin、Lua、Objective-C、Pony、Pure、Python、Ruby、Rust、Scala、Scheme、Swiftなどが含まれます。

その結果、以下のすべての検証と最適化を、ほぼ線形の`(n log n)`時間複雑性で展開時に行うことができます。
* ほとんどの例外的な停止状態の不在を検証できます。
* リソースの最大使用量を時々計算できます。
* バイトコードをほぼ線形時間でマシンコードにコンパイルできます。
* コンパイルでより効果的に小さなレジスタの使用を最適化できます。
* コンパイルでより効果的にガスメーターの注入を最適化できます。

## 仕様

### 依存関係

> **[EIP-1702](./eip-1702.md). 一般化されたアカウントバージョン管理スキーム。** この提案には、既存のバイトコードと同じブロックチェーン上に新しいバイトコード(最終的にはeWasmバイトコード)を展開できるバージョン管理スキームが必要です。

### 提案

我々は、2つの既存の命令 - `JUMP`と`JUMPI` - を非推奨にし、それらの正当な使用をサポートする新しい命令を提案します。特に、SolidityやvyperのコードをEVMバイトコードにコンパイルする際に、パフォーマンスの大幅な低下や ガス代の増加がないようにする必要があります。

[eWasm](https://github.com/ewasm/design)との効率的な変換と、マシンコードへの変換が特に重要です。そのために、[Wasm](https://webassembly.github.io/spec/core/_download/WebAssembly.pdf)、[x86](https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf)、[ARM](https://static.docs.arm.com/100076/0100/arm_instruction_set_reference_guide_100076_0100_00_en.pdf)、および提案されたEVM命令の間で密接な対応関係を維持します。

| EIP-615   | Wasm          | x86  | ARM
| --------- | ------------- | ---- | ---- |
| JUMPTO    | br            | JMP  | B    |
| JUMPIF    | br_if         | JE   | BEQ  |
| JUMPV     | br_table      | JMP  | TBH  |
| JUMPSUB   | call          | CALL | BL   |
| JUMPSUBV  | call_indirect | CALL | BL   |
| RETURN    | return        | RET  | RET  |
| GETLOCAL  | local.get     | POP  | POP  |
| PUTLOCAL  | local.put     | PUSH | PUSH |
| BEGINSUB  | func          |      |      |
| BEGINDATA | tables        |      |      |

#### 前提条件

これらの形式
> *`INSTRUCTION`*
>
> *`INSTRUCTION x`*
>
> *`INSTRUCTION x, y`*

は、それぞれ引数のない、1つの、2つの引数を持つ*`INSTRUCTION`*を名前付けしています。命令はバイトコード内で1バイトのオペコードとして表されます。引数はオペコードの直後にインラインの即値データバイトとして配置され、固定長、MSBファースト、2の補数、2バイトの正の整数として解釈されます。(負の値は拡張用に予約されています。)

#### ブランチとサブルーチン

`JUMP`と`JUMPI`の2つの最も重要な用途は、スタティックジャンプとリターンジャンプです。条件付きおよび無条件のスタティックジャンプは、制御フローの主要部分です。リターンジャンプは、スタックにプッシュされたリターンアドレスへの動的ジャンプとして実装されます。スタティックジャンプと動的リターンジャンプの組み合わせで、Solidityはサブルーチンを実装できます。問題は、静的分析ではリターンジャンプの行き先を1つしか特定できないため、すべての可能性を分析しなければならない(重い分析)ということです。

スタティックジャンプは以下のように提供されます:
> `JUMPTO jump_target`
>
> `JUMPIF jump_target`
>
> これらは、スタック上のアドレスではなく、即値の`jump_target`にジャンプする`JUMP`と`JUMPI`と同じです。

サブルーチンをサポートするために、`BEGINSUB`、`JUMPSUB`、および`RETURNSUB`が提供されます。簡単な説明は以下の通りで、完全な意味論は以下に示します。

> `BEGINSUB n_args, n_results`
>
> サブルーチンの**単一**エントリーポイントを示します。`n_args`個のアイテムがサブルーチン入口で、`n_results`個のアイテムがサブルーチン終了時にスタックに置かれます。サブルーチンは、次の`BEGINSUB`命令(または以下の`BEGINDATA`)または、バイトコードの終わりまでに終了します。

> `JUMPSUB jump_target`
>
> 即値のサブルーチンアドレスにジャンプします。

> `RETURNSUB`
>
> 現在のサブルーチンから、そのサブルーチンに入った`JUMPSUB`の直後の命令に戻ります。

#### スイッチ、コールバック、仮想関数

動的ジャンプは、`O(1)`の間接参照にも使用されます。ジャンプ先のアドレスがスタックにプッシュされ、ジャンプされます。そのため、制約された間接参照のために2つのさらの命令を提案します。これらは、インラインに格納された`JUMPDEST`または`BEGINSUB`オフセットのベクトルを使用してサポートされます。これにより、すべての可能な宛先の中から選択できます。指数関数的な爆発の危険性は回避されます。これは、最悪の場合の悪用を保存するのに必要な容量と同じ容量でジャンプベクトルを保存できるためです。

`JUMPDEST`への動的ジャンプは、密なスイッチ文に役立つ`O(1)`ジャンプテーブルを実装するのに使用されます。Wasmと多くのCPUは同様の命令を提供しています。

> `JUMPV n, jump_targets`
>
> スタック上のゼロベースのインデックスを介して、`n`個の`JUMPDEST`オフセットのベクトルにジャンプします。ベクトルは、`BEGINDATA`バイトコードの後のオフセット`jump_targets`にMSBファースト、2の補数、2バイトの正の整数として格納されます。インデックスが`n - 1`以上の場合は、最後の(デフォルトの)オフセットが使用されます。

`BEGINSUB`への動的ジャンプは、ほとんどのCPUで最大2つのポインタ間接参照で実装できる`O(1)`の仮想関数とコールバックを実装するのに使用されます。Wasmは同様の命令を提供しています。

> `JUMPSUBV n, jump_targets`
>
> スタック上のゼロベースのインデックスを介して、`n`個の`BEGINSUB`オフセットのベクトルにジャンプします。ベクトルは、`DATA`バイトコードの後のオフセット`jump_targets`にMSBファースト、2の補数、2バイトの正の整数として格納されます。インデックスが`n - 1`以上の場合は、最後の(デフォルトの)オフセットが使用されます。

#### 変数アクセス

これらの操作は、サブルーチン内の固定スタックオフセットでのパラメータとローカル変数へのアクセスを提供します。そうしないと、16個の変数しか直接アドレス指定できません。

> `PUTLOCAL n`
>
> スタックからローカル変数`n`にポップします。

> `GETLOCAL n`
>
> ローカル変数`n`をスタックにプッシュします。

ローカル変数`n`は、フレームポインタ`FP`の下の`n`番目のスタックアイテムです。

#### データ

バイトコードに到達不能なデータを配置し、検証されずにスキップされるようにする必要があります。間接ジャンプベクトルは有効なコードではありません。初期化コードは、有効なコードではない可能性のあるデータからランタイムコードを作成する必要があります。到達不能なデータは、プログラムの他の目的に役立つ可能性があります。

> `BEGINDATA`
>
> バイトコードの残りの部分がデータであり、到達可能なコードではないことを示します。

#### 構
続きです。

#### 構造

有効なEIP-615 EVMバイトコードは、有効なヘッダーで始まります。これは、'\0evm'というマジックナンバーに続いて、セマンティックバージョン番号'\1\5\0'です。(Wasmのヘッダーは'\0asm\1'です)。

ヘッダーの後に、_main_ルーチンの`BEGINSUB`オペコードが続きます。引数は取らず、値も返しません。他のサブルーチンは_main_ルーチンの後に続き、オプションの`BEGINDATA`オペコードがデータセクションの開始を示す場合があります。

### 意味論

サブルーチンへのジャンプとリターンは、以下の要素に基づいて説明されます。
* EVMデータスタック(Yellow Paperで定義されている)、通常「スタック」と呼ばれます。
* `JUMPSUB`と`JUMPSUBV`のオフセットのリターンスタック。
* フレームスタックのフレームポインタ。

機械状態を説明するために、以下の規約を採用します:
* プログラムカウンタ`PC`は(通常どおり)現在実行中の命令のバイトオフセットです。
* スタックポインタ`SP`は[Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf)の機械状態のサブステート`s`に対応します。
  * `SP[0]`は新しいアイテムをプッシュできる場所です。
  * `SP[1]`はスタックからポップできる最初のアイテムです。
  * スタックは下位アドレスに向かって成長します。
* フレームポインタ`FP`は、現在実行中のサブルーチンに入るときに`SP + n_args`に設定されます。
  * フレームポインタとカレントスタックポインタの間のスタックアイテムは、_フレーム_と呼ばれます。
  * フレームの現在のサイズ、`FP - SP`は、_フレームサイズ_です。

> **注意**: フレームポインタを引数を含むように定義するのは非常に一般的ではありませんが、スタックセマンティクスにより適しており、提案の残りの部分を簡素化します。

フレームポインタとリターンスタックは、サブルーチンメカニズムに内部的であり、プログラムから直接アクセスできません。これは、プログラムが無効になる可能性のある方法で自身の状態を変更するのを防ぐために必要です。

EVMバイトコードの実行は、引数なしの_main_ルーチンから始まり、`SP`と`FP`は0に設定され、リターンスタックに1つの値 - `code_size - 1` - があります。(この位置の0の仮想バイトを実行すると、EVMが停止します。したがって、`JUMPSUB`または`JUMBSUBV`のない`RETURNSUB`を実行する(つまり、_main_ルーチンで) - `STOP`を実行します。)

サブルーチンの実行は、`JUMPSUB`または`JUMPSUBV`で始まり、

* `PC`をリターンスタックにプッシュし、
* `FP`をフレームスタックにプッシュし
  * 現在のサブルーチンの実行を一時停止し、
* `FP`を`SP + n_args`に設定し、
* `PC`を指定された`BEGINSUB`アドレスに設定し
  * 新しいサブルーチンの実行を開始します。

ネストされたサブルーチンの実行中および後に、サブルーチンの実行は一時停止および再開され、`RETURNSUB`に遭遇すると終了します。これにより、

* `FP`を仮想フレームスタックの先頭に設定し、スタックをポップし、
* `SP`を`FP + n_results`に設定し、
* `PC`をリターンスタックの先頭に設定し、スタックをポップし、
* `PC`を次の命令に進めます

これにより、囲むサブルーチンまたは_main_ルーチンの実行が再開されます。`STOP`または`RETURN`もサブルーチンの実行を終了します。

例えば、このスタックから始まり、
```
_________________
      | locals      20 <- FP
frame |             21
______|___________  22
                       <- SP
```
2つの引数をプッシュし、`BEGINSUB 2, 3`のある`JUMPSUB`でブランチした後、
```
PUSH 10
PUSH 11
JUMPSUB beginsub
```
3つのローカル変数を初期化すると、
```
PUSH 99
PUSH 98
PUSH 97
```
スタックは次のようになります
```
                    20
                    21
__________________  22
      | arguments   10 <- FP
frame |___________  11
      | locals      99
      |             98
______|___________  97
                       <- SP
```
いくらかの計算の後、スタックは次のようになる可能性があります
```
                    20
                    21
__________________  22
      | returns     44 <- FP
      |             43
frame |___________  42
      | locals      13
______|___________  14
                       <- SP
```
そして`RETURNSUB`の後は次のようになります
```
_________________
      | locals      20 <- FP
      |             21
frame |___________  22
      | returns     44
      |             43
______|___________  42
                       <- SP
```

### 有効性

プログラムの実行が例外的な停止状態に至らないことを考慮したいと思いますが、線形時間で検証する必要があります。したがって、私たちの検証はコードのデータと計算を考慮せず、制御フローとスタックの使用のみを考慮します。これは、到達不可能なパスでも無効なコードパスを持つプログラムを拒否することを意味します。ほとんどの条件は検証でき、実行時にチェックする必要はありません。例外は十分なガスと十分なスタックです。そのため、静的分析では、よく理解されているクラスのコードに属する偽陰性が生じる可能性があります。これらのケースを除いて、多くのクラスを検証時間と線形複雑性で検証できます。

_実行_は[Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf)で定義されているように、EVM状態の連続的な変化です。有効なコードの条件は状態変化によって保持されます。実行時に、命令の実行が条件に違反する場合、実行は例外的な停止状態になります。Yellow Paperでは5つのそのような状態が定義されています。
>**1**  ガス不足

>**2**  1024を超えるスタックアイテム

>**3**  スタックアイテムが不足

>**4**  無効なジャンプ先

>**5**  無効な命令

我々は、提案する新しい命令を処理するために、Yellow Paperの条件を拡張および拡張することを提案します。

リターンスタックを処理するために、スタックサイズの条件を次のように拡張します:
>**2a**  データスタックのサイズが1024を超えない。

>**2b**  リターンスタックのサイズが1024を超えない。

データスタックの詳細な説明に基づいて、条件3 - スタックアンダーフロー - を次のように再定義します:
>**3**  `SP`は`FP`以下でなければならない

`DUP`、`SWAP`、`PUTLOCAL`、`GETLOCAL`などの各種命令は、スタックからアイテムを取り出してそれを戻すように定義されているため、これにより、フレームポインタ以下のデータにアクセスできなくなります。

新しいジャンプ命令とサブルーチンの境界を処理するために、ジャンプとジャンプ先の条件を次のように拡張します。
>**4a**  `JUMPTO`、`JUMPIF`、および`JUMPV`は`JUMPDEST`命令のみをアドレス指定する。

>**4b**  `JUMPSUB`および`JUMPSUBV`は`BEGINSUB`命令のみをアドレス指定する。

>**4c**  `JUMP`命令は、それが発生するサブルーチュン外のアドレスをアドレス指定しない。

サブルーチンによるスタックの一貫した使用を確保するための2つの新しい実行条件があります:
>**6**  `JUMPSUB`および`JUMPSUBV`の場合、フレームサイズは、ジャンプ先の`BEGINSUB`(複数可)の`n_args`以上でなければならない。

>**7**  `RETURNSUB`の場合、フレームサイズは、囲むBEGINSUBの`n_results`と等しくなければならない。

最後に、スタックの病理的な使用を防ぐための1つの条件があります:
>**8**  コード内のすべての命令について、フレームサイズは一定でなければならない。

実際には、条件1と2 - 十分なガスと十分なスタック - をランタイムでテストする必要があります。ガスの量がわからず、再帰の深さもわからず、非再帰プログラムでさえもスタック深さの分析は複雑です。

残りのすべての条件は静的に検証します。

#### コストとコード

すべての命令は、わずかな定数の`O(1)`で、それぞれわずかな機械命令しか必要としません。一方、`JUMP`または`JUMPI`は通常、ジャンプの前に`O(log n)`のバイナリ検索を行います。`JUMPI`のコストが_high_で、`JUMP`のコストが_mid_であるのに対し、`JUMPV`と`JUMPSUBV`のコストは_mid_、`JUMPSUB`と`JUMPIF`のコストは_low_、`JUMPTO`とその他のコストは_verylow_であると提案します。測定が示すでしょう。

以下のオペコードを提案します:
```
0xb0 JUMPTO
0xb1 JUMPIF
0xb2 JUMPV
0xb3 JUMPSUB
0xb4 JUMPSUBV
0xb5 BEGINSUB
0xb6 BEGINDATA
0xb7 RETURNSUB
0xb8 PUTLOCAL
0xb9 GETLOCAL
```

## 下位互換性

これらの変更は、適切な間隔で段階的に実装する必要があります:
>**1.**  この EIP が受け入れられた場合、無効なコードは非推奨になります。ツールは無効なコードの生成を停止し、ユーザーはそれを書かず、クライアントはそれのロードについて警告する必要があります。

>**2.**  後のハードフォークでは、クライアントがブロックチェーンに有効なコードのみを配置することを要求します。ただし、フォーク後も古いEVMコードを無期限にサポートする必要があります。古いコントラクトは引き続き実行され、新しいコントラクトを作成します。

必要に応じて、段階2を無期限に延期することで、非推奨期間を延長できます。つまり、段階2を遅らせるか取り消すことです。

いずれにしろ、[EIP-1702](./eip-1702.md)のようなバージョン管理スキームが必要になり、現在のコードとEIP-615コードを同じブロックチェーン上で共存させることができます。

## 根拠

この設計は、既存のEVMセマンティクス、eWasm互換性の要件、およびEthereumの環境のセキュリティ要求によって非常に制約されていました。また、著者の以前のJavaおよびSchemeインタプリタの実装の経験にも影響されています。そのため、代替設計の余地はほとんどありませんでした。

上述のように、アプローチは単に問題のある動的ジャンプを非推奨にし、それらがサポートしていた機能を提供するために必要なオペコードを尋ねるというものでした。これらには、eWasmが提供するものも含まれ、それ自体は典型的なハードウェアをモデルにしていました。唯一の真の革新は、それらを上書きする可能性を排除するために、フレームポインタとリターンポインタを独自のスタックに移すことでした。(ただし、Forthもリターンスタックを使用しています。)これにより、引数をローカル変数として扱うことができ、複数の値の返却が容易になりました。

## 実装

この提案の実装は難しくありません。最小限では、インタプリタに新しいオペコードを単に拡張し、それ以外は変更せずに実行できます。新しいオペコードには、フレームポインタとリターンオフセットのスタックと、上述の少数のプッシュ、ポップ、および代入のみが必要です。主な努力はバリデータで、ほとんどの言語では上記の擬似コードからほぼそのまま書き写せます。

軽く テストされた C++ のリファレンス実装は、[Greg Colvin の Aleth フォーク](https://github.com/gcolvin/aleth/tree/master/libaleth-interpreter)にあります。このバ
続きです。

ージョンには、新しいインタプリタコードが約110行、よくコメントされた178行のバリデータが必要でした。

## 付録A
### 検証

検証には2つのタスクがあります:
* ジャンプ先が正しく、命令が有効であることを確認する。
* サブルーチンが制御フローとスタック使用の条件を満たすことを確認する。

これらの2つの検証関数を擬似Cで概説します。プレゼンテーションを簡単にするために、プリミティブの5つのみを扱い(`JUMPV`と`JUMPSUBV`はベクトルをループするだけで複雑さが増す)、命令引数を抽出するヘルパー関数、スタックポインタとプログラムカウンタを管理するものを想定し、一部の最適化は省略しています。

#### ジャンプの検証

ジャンプ先が有効なアドレスであることを検証するには、バイトコードを2回連続してスキャンする必要があります。1回目はジャンプ先とサブルーチンエントリポイントのセットを構築し、2回目はジャンプ先がそれらのセットに含まれることを確認します。
```
    bytecode[code_size]   // contains EVM bytecode to validate
    is_sub[code_size]     // is there a BEGINSUB at PC?
    is_dest[code_size]    // is there a JUMPDEST at PC?
    sub_for_pc[code_size] // which BEGINSUB is PC in?

    bool validate_jumps(PC)
    {
        current_sub = PC

        // build sets of BEGINSUBs and JUMPDESTs
        for (PC = 0; instruction = bytecode[PC]; PC = advance_pc(PC))
        {
            if instruction is invalid
                return false
            if instruction is BEGINDATA
                break;
            if instruction is BEGINSUB
                is_sub[PC] = true
                current_sub = PC
                sub_for_pc[PC] = current_sub
            if instruction is JUMPDEST
                is_dest[PC] = true
            sub_for_pc[PC] = current_sub
        }

        // check that targets are in subroutine
        for (PC = 0; instruction = bytecode[PC]; PC = advance_pc(PC))
        {
            if instruction is BEGINDATA
                break;
            if instruction is BEGINSUB
                current_sub = PC
            if instruction is JUMPSUB
                if is_sub[jump_target(PC)] is false
                    return false
            if instruction is JUMPTO or JUMPIF
                if is_dest[jump_target(PC)] is false
                    return false
            if sub_for_pc[PC] is not current_sub
                return false
       }
       return true
    }
```
このようなコードは、EVMによってすでに実行されており、動的ジャンプの場合、毎回コントラクトを実行するときにジャンプ先セットを構築し、ジャンプの前にジャンプ先セットを検索しています。

#### サブルーチンの検証

この関数は、検証対象のEVMコード内のサブルーチンの記号的な実行と見なすことができます。ここでは、命令がステートに及ぼす影響のみが計算されます。したがって、この関数の構造は、EVMインタプリタとよく似ています。この関数は、頂点をインストラクション、順次および分岐接続を辺とする有向グラフを横断するアサイクリックな traversal とも見なすことができ、途中で条件をチェックします。この traversal はrecursionで実現され、以前に訪問したvertexに到達したときにリターンすることでサイクルが破られます。この traversalの時間複雑度は`O(|E|+|V|)`です。つまり、グラフの辺の数と頂点の数の和です。

基本的なアプローチは、EVMコードの最初の命令から各`BEGINDATA`オフセットまで`validate_subroutine(i, 0, 0)`を呼び出すことです。`validate_subroutine()`は命令を順次トラバースし、`JUMP`および`JUMPI`命令に遭遇したときにrecurseします。以前に訪問した宛先に到達すると戻り、サイクルが破られます。サブルーチンが有効な場合はtrueを、そうでない場合はfalseを返します。

```
    bytecode[code_size]     // contains EVM bytecode to validate
    frame_size[code_size ]  // is filled with -1

    // we validate each subroutine individually, as if at top level
    // * PC is the offset in the code to start validating at
    // * return_pc is the top PC on return stack that RETURNSUB returns to
    // * at top level FP = SP = 0 is both the frame size and the stack size
    // * as items are pushed SP get more negative, so the stack size is -SP
    validate_subroutine(PC, return_pc, SP)
    {
        // traverse code sequentially, recurse for jumps
        while true
        {
            instruction = bytecode[PC]

            // if frame size set we have been here before
            if frame_size[PC] >= 0
            {
                // check for constant frame size
                if instruction is JUMPDEST
                    if -SP != frame_size[PC]
                        return false

                // return to break cycle
                return true
            }
            frame_size[PC] = -SP

            // effect of instruction on stack
            n_removed = removed_items(instructions)
            n_added = added_items(instruction)

            // check for stack underflow
            if -SP < n_removed
                return false

            // net effect of removing and adding stack items
            SP += n_removed
            SP -= n_added

            // check for stack overflow
            if -SP > 1024
                return false

            if instruction is STOP, RETURN, or SUICIDE
                return true

            // violates single entry
            if instruction is BEGINSUB
                 return false

            // return to top or from recursion to JUMPSUB
            if instruction is RETURNSUB
                return true;;

            if instruction is JUMPSUB
            {
                // check for enough arguments
                sub_pc = jump_target(PC)
                if -SP < n_args(sub_pc)
                    return false
                return true
            }

            // reset PC to destination of jump
            if instruction is JUMPTO
            {
                PC = jump_target(PC)
                continue
            }

            // recurse to jump to code to validate
            if instruction is JUMPIF
            {
                if not validate_subroutine(jump_target(PC), return_pc, SP)
                    return false
            }

            // advance PC according to instruction
            PC = advance_pc(PC)
        }

        // check for right number of results
        if (-SP != n_results(return_pc)
            return false
        return true
    }
```
## 付録B
### EVM分析

研究者、著者、教師、監査人、分析ツールなど、EVMコードの正確性とセキュリティに焦点を当てた大規模で成長し続けるエコシステムがあります。ここでは、その一部を紹介します。

#### いくつかのツール

* [Contract Library](https://contract-library.com/)
* [EthereumJ](https://github.com/ethereum/ethereumj)
* [Exthereum](https://github.com/exthereum/blockchain)
* [Harmony](https://github.com/ether-camp/ethereum-harmony)
* [JEB](https://www.pnfsoftware.com/blog/ethereum-smart-contract-decompiler/)
* [Mythril](https://github.com/ConsenSys/mythril)
* [Securify](https://github.com/eth-sri/securify)
* [Skale](https://www.skalelabs.com/)
* [Status](https://status.im/)

#### いくつかの論文

* [A Formal Verification Tool for Ethereum VM Bytecode](https://www.google.com/url?q=http://fsl.cs.illinois.edu/FSL/papers/2018/park-zhang-saxena-daian-rosu-2018-fse/park-zhang-saxena-daian-rosu-2018-fse-public.pdf)
* [A Lem formalization of EVM and some Isabelle/HOL proofs](https://github.com/pirapira/eth-isabelle)
* [A survey of attacks on Ethereum smart contracts](https://eprint.iacr.org/2016/1007.pdf)
* [Defining the Ethereum Virtual Machine for Interactive Theorem Provers](https://www.google.com/url?q=http://fc17.ifca.ai/wtsc/Defining%2520the%2520Ethereum%2520Virtual%2520Machine%2520for%2520Interactive%2520Theorem%2520Provers.pdf)
* [Ethereum 2.0 Specifications](https://github.com/ethereum/eth2.0-specs)
* [Formal Verification of Smart Contracts](https://www.cs.umd.edu/~aseem/solidetherplas.pdf)
* [JelloPaper: Human Readable Semantics of EVM in K](https://jellopaper.org/)
* [KEVM: A Complete Semantics of the Ethereum Virtual Machine.](https://www.ideals.illinois.edu/items/102260)
* [Making Smart Contracts Smarter](https://eprint.iacr.org/2016/633.pdf)
* [Securify: Practical Security Analysis of Smart Contracts](https://arxiv.org/pdf/1806.01143.pdf)
* [The Thunder Protocol](https://docs.thundercore.com/thunder-whitepaper.pdf)
* [Towards Verifying Ethereum Smart Contract Bytecode in Isabelle/HOL](https://trustworthy.systems/publications/full_text/Amani_BBS_18.pdf)
*[A Lem formalization of EVM 1.5](https://github.com/seed/eth-isabelle/tree/evm15)

## 著作権

著作権およびその関連権利は[CC0](../LICENSE.md)で放棄されています。