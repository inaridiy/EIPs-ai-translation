---
original: 71cd294c49f7b390d23144bd712ee22d60ff65b870c4ed9b0af57de7163d4cc7
---

---
eip: 3534
title: 制限付きチェーンコンテキストタイプのトランザクション
author: Isaac Ardis (@whilei)
discussions-to: https://ethereum-magicians.org/t/eip-3534-restricted-chain-context-transaction-type/6112
status: 停滞
type: Standards Track
category: Core
created: 2021-04-20
requires: 2718, 2930
---

## 簡単な要約

祖先ブロックハッシュ、ブロック作成者、および/またはブロックタイムスタンプに制約を持つ新しいトランザクションタイプを定義します。

## 概要

EIP-2718 トランザクションタイプの新しい形式 `0x4 || rlp([chainId, chainContext, nonce, gasPrice, gasLimit, to, value, data, access_list, yParity, senderR, senderS])` を導入します。

提案された `chainContext` 要素は、トランザクションの有効性を参照された値に一致するチェーンセグメントに制限します。 4つのコンテキストがこのタイプのサブクラスとして定義されています:

- `segmentId`
- `eligibleMinerList`
- `ineligibleMinerList`
- `expiry`

これらのコンテキストは任意の組み合わせで使用できます。注釈付きのコンテキスト値の組み合わせは、注釈の複合整数プレフィックスによって参照されます。

## 動機

トランザクションが適格なチェーンコンテキストに関する制約を表現できるプロトコルベースのメカニズムを確立する。
一般的に、これらの制約により、消費者(トランザクター)はブロックチェーンデータとその出所に関する要件を表現する機能を得ることができます。

- トランザクションの適用を、現在利用可能で、ある主観的な見方の下で推論されるチェーンコンテキストに制限する。
    - トランザクションがチェーンの現在の見方に依存することを記述する方法を導入します。
- トランザクションの適用を、前のブロック(およびそのトランザクション)に続くチェーンコンテキストに制限する。
    - トランザクションが「マクロ」(ブロック)レベルで祖先依存関係を記述する方法を導入します。
    間接的に、これにより、依存するトランザクションが別のブロックにある限り、別のトランザクションに依存することができます。
- トランザクションの適用を、優先/嫌われるマイナーアドレスを受益または_受益しない_ブロックに制限する。
    - マイナーがトランザクション消費者の取引を競争する機会/市場を導入します。現状では、消費者の視点から見ると、現在のマイナー-トランザクション処理サービスはほぼ完全に均一です。
- トランザクションの適用時間を制限する。
    - トランザクション/消費者がトランザクションプールから無効/排除されるための別の方法(現状)を導入します。

## 仕様

### パラメーター

- `FORK_BLOCK_NUMBER` `TBD`
- `TRANSACTION_TYPE_NUMBER` `0x4`。 EIP-2718を参照してください。

`FORK_BLOCK_NUMBER`以降、EIP-2718トランザクションの新しいタイプが `TRANSACTION_TYPE_NUMBER` で導入されます。

このトランザクションのEIP-2718 `TransactionPayload` は `rlp([chainId, chainContext, nonce, gasPrice, gasLimit, to, value, data, access_list, yParity, senderR, senderS])` です。

このトランザクションのEIP-2718 `ReceiptPayload` は `rlp([status, cumulativeGasUsed, logsBloom, logs])` です。

### 定義

- `chainContext`。 トランザクションは、注釈のすべてを満たすブロックチェーンデータにのみ有効です。
- `ANNOTATION_COMPOSITE_PREFIX`。 `chainContext` のサブクラス注釈を表す `1` と `0xff` の間の正の整数(つまり、_どの_チェーンコンテキストサブクラスに提供された値を適用する必要があるか)。この値は、サブクラスの `ANNOTATION_PREFIX` の合計である必要があります。
- サブクラスの `ANNOTATION_PREFIX` は、8進数から派生した正の整数 `2^0,2^1,2^2,2^3,2^4,2^5,2^6,2^7` に制限されています。

`chainContext` の値は、`ANNOTATION_COMPOSITE_PREFIX || [{サブクラス値}...]` の形式である必要があります。ここで
- `...` は「左側のものの0個以上」を意味し、
- `||` はバイト/バイト配列の連結演算子を表します。

`chainContext` の値は `ANNOTATION_COMPOSITE_PREFIX || rlp[{サブクラス値}...]` としてエンコードする必要があります。

### 検証

以下に定義されるサブクラスの値は、特定のチェーンコンテキストに対するトランザクションの有効性の制約として機能します。
制約を満たさないチェーンコンテキストを持つトランザクションは無効として拒否されるべきです。
無効なトランザクションを含むブロックは、_現状_に従って無効として拒否されるべきです。

### サブクラスの組み合わせ

複数のサブクラスを参照する `chainContext` の値は、以下の順序でそれらの値を提供する必要があります:

1. `ANCESTOR_ID`
2. `ELIGIBLE_MINER_LIST`
3. `INELIGIBLE_MINER_LIST`
4. `EXPIRY`

上記のように、`ANNOTATION_COMPOSITE_PREFIX` は指定されたサブクラスの `ANNOTATION_PREFIX` の合計である必要があります。

### サブクラス

- 利用可能なコンテキストサブクラスの各々を表すために `ANNOTATION_PREFIX` 値が使用されます。

#### `ancestorId`

- `ANNOTATION_PREFIX` `1`.
- `ANCESTOR_ID` `bytes`. 4~12バイトの長さの byte 配列。

`ANCESTOR_ID` は、ブロック番号とその最初の4バイトのハッシュを連結することで、特定のブロックを参照します。
ブロック番号は big endian でエンコードされ、先頭の0は削除されます。
ジェネシスブロックを参照する場合は、ブロック番号の値を省略できます。

`ANCESTOR_ID` の値はハッシュ化と送信のためにRLPエンコードされる必要があります。

#### `eligibleMinerList`

- `ANNOTATION_PREFIX` `2`.
- `ELIGIBLE_MINER_LIST` `[address...]`. アドレスのリスト。
- `MAX_ELEMENTS` `3`. 提供できる最大アドレス数。

`ELIGIBLE_MINER_LIST` の値は、一意の有効なアドレスの配列です。
この値を使用するトランザクションを含むブロックは、このセットに含まれるブロック受益者を持っている必要があります。

`ELIGIBLE_MINER_LIST` の値は `[{20 bytes}+]` 型である必要があります。ここで `+` は「左側のものの1個以上」を意味します。
一意でない値は許可されません。

`ELIGIBLE_MINER_LIST` の値はハッシュ化と送信のためにRLPエンコードされる必要があります。

`ELIGIBLE_MINER_LIST` の値は `INELIGIBLE_MINER_LIST` の値と隣接して提供することはできません。

#### `ineligibleMinerList`

- `ANNOTATION_PREFIX` `4`.
- `INELIGIBLE_MINER_LIST` `[address...]`. アドレスのリスト。
- `MAX_ELEMENTS` `3`. 提供できる最大アドレス数。

`INELIGIBLE_MINER_LIST` の値は、一意の有効なアドレスの配列です。
この値を使用するトランザクションを含むブロックは、このセットに含まれるブロック受益者を持っていてはいけません。

`INELIGIBLE_MINER_LIST` の値は `[{20 bytes}+]` 型である必要があります。ここで `+` は「左側のものの1個以上」を意味します。
一意でない値は許可されません。

`INELIGIBLE_MINER_LIST` の値はハッシュ化と送信のためにRLPエンコードされる必要があります。

`INELIGIBLE_MINER_LIST` の値は `ELIGIBLE_MINER_LIST` の値と隣接して提供することはできません。

#### `expiry`

- `ANNOTATION_PREFIX` `8`.
- `EXPIRY` `integer`. 正の符号なし整数。

`EXPIRY` の値は、このトランザクションを含むブロックの有効な最大 `timestamp` に等しい値です。

`EXPIRY` の値はハッシュ化と送信のためにRLPエンコードされた整数である必要があります。

## 根拠

### サブクラス

サブクラスは概念的に独立性の高いレベルで定義されており、このEIPから独立して変更および/または拡張できます。
その仕様定義では、任意の相互(`AND`)組み合わせが可能です。

この設計は、具体的な一連の詳細を提案しつつ、後の拡張や変更のための十分な柔軟性を備えることを目的としています。

#### `ANNOTATION_PREFIX`

`ANNOTATION_PREFIX` 値の8進数派生値の使用、つまり `1, 2, 4, 8, 16, 32, 64, 128` は、Unixスタイルのファイル権限などの限られたセットからの組み合わせを一意かつ簡潔に表現する従来のパターンに従っています。
このEIPでは4つのコンテキストサブクラスを定義していますが、これは将来の成長のための十分な余地があるように見えます。
この制限に達するか超えた場合、それを行うには事実上ハードフォークが必要です(トランザクション検証スキームに対するコンセンサスプロトコルの変更によって)。したがって、必要に応じてこのスキームを改訂するのは付随的で些細なことになるはずです。

#### `ancestorId`

番号とハッシュによって以前のカノニカルブロックを参照することで、トランザクションの有効性を制限します。
トランザクションは、注釈付きのブロックを祖先として持つブロックに含まれる場合にのみ有効です。

実際には、「指定された許容可能なチェーンセグメント」は `0..ancestorId` までのブロックセグメントと理解できます。

##### `chainId`への冗長性

このパターンは、[EIP-155](./eip-155)の `chainId` 仕様の相関物と理解できます。
EIP155は、EIP-155トランザクションの適用をアノテートされたチェーンIDを持つチェーンに制限します。
`ancestorId` はさらに、1つのチェーンの1つのセグメント("セグメント")にトランザクションの適用を制限します。

この制約階層から、`ancestorId` の実装が `chainId` を概念的に冗長にする可能性があることがわかります。

##### では、なぜ `chainId` を維持するのか?

`chainId` は以下の理由から不変の状態に維持されます:

- このEIPで提案されているトランザクションタイプの使用はオプションであり、これは `chainId` がプロトコルインフラストラクチャとツーリングのために引き続き必要であることを意味しています。
- `ancestorId` がこのEIPで提案されるトランザクションタイプに含まれるのはオプションです。値が RCC トランザクションによって埋められない場合、`chainId` の需要は残ります。
- `chainId` の値は必ずしも `ancestorId` に冗長ではありません。たとえば、ブロック `1_919_999` への `ancestorId` 参照は、Ethereum とEthereum Classicの間で曖昧になる可能性があります。
- `ancestorId` の使用時に `chainId` の省略を指定することができます。これにより、`chainId` が通常必要とする数バイトを削除するためのインフラストラクチャの複雑さが追加されますが、この取引は行う価値がないと考えられます。
    - `chainId` は取引署名スキームの `v` 値(of `v,r,s`)として使用されています。これを削除または変更すると、エンコードされたトランザクションフィールドよりも下位のレベルでの複雑性が発生し、実装のための追加のインフラストラクチャの複雑さが必要になります。
- 提案された `ancestorId` の設計は完全な精度を提供しません(バイトサイズの節約の利点)。
  まれに値が曖昧になる場合、`chainId` はトランザクションのチェーン固有性の確実な保証を維持します。

#### `eligibleMinerList`

トランザクションは、注釈付きのアドレスリストに含まれる `etherbase` を持つブロックに含まれる場合にのみ有効です。
「ホワイトリスト」(`eligibleMinerList`)と「ブラックリスト」(`ineligibleMinerList`)を組み合わせて使用するのは論理的に矛盾しています
。それらの共存は許可されません。

`MAX_ELEMENTS` の制限を `3` に設定したのは、トランザクションのサイズを制限する利益と、ユーザーに十分な表現レベルを提供する利益のバランスを取るためです。執筆時点では、ブロック数で測定した上位3人のイーサリアムマイナー(公開アドレスによる)が全ブロックの52%を占めています。

#### `ineligibleMinerList`

トランザクションは、注釈付きのアドレスリストに含まれない `etherbase` を持つブロックに含まれる場合にのみ有効です。
「ブラックリスト」(`ineligibleMinerList`)と「ホワイトリスト」(`eligibleMinerList`)を組み合わせて使用するのは論理的に矛盾しています。それらの共存は許可されません。

`MAX_ELEMENTS` の制限を `3` に設定したのは、トランザクションのサイズを制限する利益と、ユーザーに十分な表現レベルを提供する利益のバランスを取るためです。執筆時点では、ブロック数で測定した上位3人のイーサリアムマイナー(公開アドレスによる)が全ブロックの52%を占めています。

#### `expiry`

トランザクションは、注釈された値よりも小さい `timestamp` を持つブロックに含まれる場合にのみ有効です。
正の整数が使用されるのは、それがブロック `timestamp` ヘッダー値の指定されたタイプに対応しているためです。

### サブクラスの組み合わせ

サブクラスは8進数ベースの値を `ANNOTATION_PREFIX` に使用するため、注釈の順序を前提として、和として区別可能に組み合わせることができます。
例えば:

- `ANNOTATION_PREFIX` `1` は `ancestorId` を排他的に示します。
- `ANNOTATION_PREFIX` `2` は `eligibleMinerList` を排他的に示します。
- `ANNOTATION_PREFIX` `4` は `ineligibleMinerList` を排他的に示します。
- `ANNOTATION_PREFIX` `8` は `expiry` を排他的に示します。
- `ANNOTATION_PREFIX` `1+2=3` は `ancestorId` と `eligibleMinerList` を組み合わせます。
- `ANNOTATION_PREFIX` `1+4=5` は `ancestorId` と `ineligibleMinerList` を組み合わせます。
- `ANNOTATION_PREFIX` `1+8=9` は `ancestorId` と `expiry` を組み合わせます。
- `ANNOTATION_PREFIX` `1+2+8=11` は `ancestorId` と `eligibleMinerList` と `expiry` を組み合わせます。
- `ANNOTATION_PREFIX` `1+4+8=13` は `ancestorId` と `ineligibleMinerList` と `expiry` を組み合わせます。
- `ANNOTATION_PREFIX` `2+4=6` は許可されません。 `eligibleMinerList` と `ineligibleMinerList` を組み合わせるためです。
- `ANNOTATION_PREFIX` `1+2+4+8=15` は許可されません。 `eligibleMinerList` と `ineligibleMinerList`(および `ancestorId` と `expiry`)を組み合わせるためです。

順序が定義され要求されているため、注釈付きの参照は区別可能なままです。例えば:

- `chainContext` `3[e4e1c0e78b1ec3,[Df7D7e053933b5cC24372f878c90E62dADAD5d42]]` - トランザクションは、番号が `15_000_000` で、ハッシュが `e78b1ec3` で始まるカノニカルな祖先ブロックを持つブロックに含まれる場合にのみ含まれることができ、そのブロックの受益者は `Df7D7e053933b5cC24372f878c90E62dADAD5d42` です。
- `chainContext` `10[[Df7D7e053933b5cC24372f878c90E62dADAD5d42],1619008030]` - トランザクションは、`Df7D7e053933b5cC24372f878c90E62dADAD5d42` を `etherbase` 受益者として指定し、`1619008030` (2021年4月21日07:27:10 CDT)よりも大きいタイムスタンプを持つブロックに含まれる場合にのみ有効です。

### EIP-2930の継承
[EIP-2930 Optional Access List Type Transaction](https://eips.ethereum.org/EIPS/eip-2930)は、この提案の想定される「ベース」トランザクションタイプとして使用されます。
ただし、これは概念的な依存関係ではありません。この提案に含まれる `accessList` 部分(post-EIP-155レガシートランザクションフィールドとの唯一の差分)は容易に削除できます。
EIP-2930の上に立つのは、次世代トランザクションの採用をさらに支援することを意図しているだけです。

### 署名ターゲット

署名は、トランザクションタイプとトランザクションデータの両方を対象としています。
これは、トランザクションが別のタイプのトランザクションとして「再解釈」されることを防ぐためです。

## 下位互換性

既知の下位互換性の問題はありません。

## テストケース

| セグメントID | ブロック番号 | カノニカルブロックハッシュ |
| --- | --- | --- |
| `e78b1ec3` | `0` | `0xe78b1ec31bcb535548ce4b6ef384deccad1e7dc599817b65ab5124eeaaee3e58` |
| `01e78b1ec3` | `1` | `0xe78b1ec31bcb535548ce4b6ef384deccad1e7dc599817b65ab5124eeaaee3e58` |
| `e4e1c0e78b1ec3` | `15_000_000` | `0xe78b1ec31bcb535548ce4b6ef384deccad1e7dc599817b65ab5124eeaaee3e58` |
| `e8d4a50fffe78b1ec3` | `999_999_999_999` | `0xe78b1ec31bcb535548ce4b6ef384deccad1e7dc599817b65ab5124eeaaee3e58` |
| `7fffffffffffffffe78b1ec3` | `9223372036854775807` | `0xe78b1ec31bcb535548ce4b6ef384deccad1e7dc599817b65ab5124eeaaee3e58` |

その他のテストケース、TODO。

## セキュリティ上の考慮事項

### `ancestorId`に4バイトのブロックハッシュが「十分に安全」な理由

__TL;DR__: `ancestorId`が無効になる可能性は約40億分の1から40億分の1の間です。意図的な重複シナリオ(悪意のある再編成など)の方が可能性が高くなります。

__衝突が_発生した場合__、それはトランザクションが両方のセグメントで有効になることを意味します(現状の場合と同様)。

32バイトの全ハッシュではなく4バイトを選択したのは、この値を伝送するために必要な情報量を減らすためだけです。
全ハッシュを使用すれば「完全に安全」な実装になり、追加のバイトごとに衝突の可能性が指数関数的に減少します。

`ancestorId`の目的は、1つのチェーンセグメントを別のものから明確に区別し、それによってトランザクションが必要とするチェーンを十分な精度で定義できるようにすることです。
トランザクションの `ancestorId` がブロックを参照する場合、その参照が、トランザクションの作成者が念頭に置いていたブロック以外のものと混同されないことを確認したいと思います。

ブロックハッシュ値のすべての可能なサブセットに対して衝突耐性の特性が一様に適用されると仮定しているため、_最初の_4バイトを使用するという選好は任意であり、同じ長さの他のサブセットと機能的に等価です。

可読性と利用しやすさのために、以下の議論では4バイトの16進表現、つまり8文字の長さ(例: `e78b1ec3`)を参照します。

`ancestorId` の衝突する可能性は `1/(16^8=4_294_967_296)` 倍、同等の番号のブロックが(別のチェーンで)存在する可能性と見なされます。10%(`1/10`)の寛大な概算確率を仮定すると、これは `(1/(16^8=4_294_967_296) * 1/10` になります。ただし、この概算は「通常」のチェーンとネットワークの動作を前提としています。競合するチェーンセグメントが持続する場合、この値は100%(`1`)に上がります。

### `eligibleMinerList`

注釈付きの `eligibleMinerList` にリストされていないマイナーは、直ちにトランザクションをトランザクションプールから削除することが期待されます。

悲観的な見方では、これらの適格外のノードがこれらのトランザクションの再ブロードキャストを提供しないことも予想されるため、意図したマイナーへのトランザクションの配布(および可用性)に影響を与える可能性があります。一方で、マイナーはこのようなトランザクションの受信に自分を利用可能にする動機付けがあり、オンネットワークおよびオフネットワークの両方で多くの方法がこれを可能にします。

`eligibleMinerList` を使用するトランザクションの作成者は、このようなトランザクションの「一般的な可用性」が制限のないトランザクションよりも低くなると想定する必要があります(適格なマイナーのみがトランザクションを処理できるため)。

最後の考慮事項は、ホワイトリストされたマイナーのトランザクション処理順序の経済性です。
ホワイトリストのないトランザクションは最初は競争力があるように見え、優先的に処理されるべきです。
ただし、このような戦略に従うマイナーは評判が低下し、最悪の場合、トランザクション作成者の積極的な好みが競合他社に移行し、自分の手の届かないところに行ってしまう可能性があります。

### `ineligibleMinerList`

`eligibleMinerList` に示された懸念と議論に加えて、`ineligibleMinerList` には一意の懸念があります。ブラックリストによる不適格性を回避するためには、ブロック受益者として別のアドホックアドレスを使用するだけでよいためです。
原則的にこれは避けられません。

ただし、「回避」するマイナーにはいくつかの関連コストを考慮する必要があります。

- アカウントの作成には時間とエネルギーが必要です。ただし、この作業は常に便利な時間と状況で行うことができます。おそらく限界的ですが、ゼロではありません。
- 複数のアカウントからの資金移動には、同数のトランザクションが必要です。ブロック報酬はトランザクション処理後に適用されるため、同じブロックでアドホックアカウントから目標アカウントに資金を同時に移動することはできません(これがなければ「無料」のトランザクションになります)。
- アドホックアドレスを使ってブラックリストを回避する際、マイナーは同時に現代のホワイトリストトランザクションからも除外される可能性があります。

### 検証コスト

マイナーリストと有効期限は、容易にキャッシュでき、コンテキストで利用可能な条件(つまり、含まれるブロックヘッダー)に依存します。これらの検証を実施するためのインフラストラクチャのオーバーヘッドコストは名目的なものと予想されます。

`ancestorId` の検証は、ブロック番号によるポジティブなデータベースヒットの主張(それによってストアされたブロックのハッシュを相互参照)を要求します。
この必要な検索は(おそらくすでに)キャッシュされていますが、検索値が任意であるため、100%のヒット率を期待することはできません。
それでも、深い `ancestorId` を使用するトランザクションに提供される価値は徐々に限界的になるため、ほとんどのトランザクションがこのフィールドを使用するのは比較的浅い、キャッシュフレンドリーな値のセットになると予想されます。

### トランザクションサイズの増加

提案された追加フィールドにより、トランザクションサイズが増加する可能性があります。
提案されたフィールドには任意のガスコストは関連付けられていないため、潜在的なスパムに対するプロトコル定義の経済的緩和策はありません。
ただし、マイナーが望ましくないと見なすトランザクションは単にトランザクションプールから削除され、無視されることがあります。

## 著作権

著作権およびそれに関連する権利は[CC0](../LICENSE.md)によって放棄されています。