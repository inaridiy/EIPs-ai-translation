---
original: 7f38172445a27c0f77d820d00be954f54ac76710ba522adfdfb8982cfb233418
---

---
eip: 198
title: 大整数の剰余指数演算
author: Vitalik Buterin (@vbuterin)
status: 最終版
type: 標準トラック
category: コア
created: 2017-01-30
---

# パラメータ

* `GQUADDIVISOR: 20`

# 仕様

アドレス 0x00......05 に、以下の形式の入力を期待する前処理を追加します:

    <BASE の長さ> <EXPONENT の長さ> <MODULUS の長さ> <BASE> <EXPONENT> <MODULUS>
    
ここで、各長さは BASE、EXPONENT、MODULUS の長さをバイト数で表した32バイトの左詰めの整数です。呼び出しデータは無限に右詰めのゼロバイトで埋められ、余分なデータは無視されます。 `floor(mult_complexity(max(MODULUS の長さ, BASE の長さ)) * max(ADJUSTED_EXPONENT_LENGTH, 1) / GQUADDIVISOR)` ガスを消費し、ガスが十分であれば、MODULUS と同じ長さのバイト配列で `(BASE**EXPONENT) % MODULUS` の出力を返します。

`ADJUSTED_EXPONENT_LENGTH` は以下のように定義されます。

* `EXPONENT の長さ <= 32` で、EXPONENT のビットがすべて 0 の場合は 0 を返す
* `EXPONENT の長さ <= 32` の場合は、EXPONENT の最上位ビットのインデックスを返す (例: 1 -> 0, 2 -> 1, 3 -> 1, 255 -> 7, 256 -> 8)
* `EXPONENT の長さ > 32` の場合は、EXPONENT の最初の32バイトの最上位ビットのインデックスに、(EXPONENT の長さ - 32) * 8 を加えた値を返す (例: EXPONENT が100バイトで先頭32バイトがすべて 0 の場合、結果は 8 * (100 - 32) + 253 = 797)。EXPONENT の最初の32バイトがすべて 0 の場合は、ちょうど (EXPONENT の長さ - 32) * 8 を返す

`mult_complexity` は Karatsuba 乗算 (主要な大整数ライブラリで使用されている) の難易度を近似するための関数で、以下のように定義されています。

```
def mult_complexity(x):
    if x <= 64: return x ** 2
    elif x <= 1024: return x ** 2 // 4 + 96 * x - 3072
    else: return x ** 2 // 16 + 480 * x - 199680
```

例えば、以下の入力データ:

    0000000000000000000000000000000000000000000000000000000000000001
    0000000000000000000000000000000000000000000000000000000000000020
    0000000000000000000000000000000000000000000000000000000000000020
    03
    fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2e
    fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f
    
は、指数 `3**(2**256 - 2**32 - 978) % (2**256 - 2**32 - 977)` を表しています。フェルマーの小定理より、これは 1 に等しいので、結果は:

    0000000000000000000000000000000000000000000000000000000000000001
    
32バイトで返されます。`ADJUSTED_EXPONENT_LENGTH` は 255 となり、ガスコストは `mult_complexity(32) * 255 / 20 = 13056` ガスになります (これは 32 バイトの指数を EXP オペコードで計算するコストの約 8 倍です)。4096ビットの RSA 指数演算の最悪ケースのガスコストは `mult_complexity(512) * 4095 / 100 = 22853376` ガスですが、RSA 検証では通常指数 3 や 65537 が使用されるため、ガスコストはそれぞれ 5580 や 89292 に減少します。

この入力データ:

    0000000000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000020
    0000000000000000000000000000000000000000000000000000000000000020
    fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2e
    fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f
    
は、BASE が 0、EXPONENT が `2**256 - 2**32 - 978`、MODULUS が `2**256 - 2**32 - 977` として解析され、0 を返します。BASE の長さが 0 の場合、BASE のデータは解釈されず、次の 32 バイトが直接 EXPONENT として解釈されることに注意してください。

この入力データ:

    0000000000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000020
    ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
    fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe
    fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd
    
は、BASE 長 0、EXPONENT 長 32、MODULUS 長 `2**256 - 1` として解析され、BASE が空、EXPONENT が `2**256 - 2`、MODULUS が `(2**256 - 3) * 256**(2**256 - 33)` (非常に大きな数) となります。これは計算に必要なガスを提供できないため、直ちに失敗します。

この入力データ:

    0000000000000000000000000000000000000000000000000000000000000001
    0000000000000000000000000000000000000000000000000000000000000002
    0000000000000000000000000000000000000000000000000000000000000020
    03
    ffff
    8000000000000000000000000000000000000000000000000000000000000000
    07

は、BASE が 3、EXPONENT が 65535、MODULUS が `2**255` として解析され、残りの 0x07 バイトは無視されます。

この入力データ:

    0000000000000000000000000000000000000000000000000000000000000001
    0000000000000000000000000000000000000000000000000000000000000002
    0000000000000000000000000000000000000000000000000000000000000020
    03
    ffff
    80
    
も同様に、BASE が 3、EXPONENT が 65535、MODULUS が `2**255` として解析されます。MODULUS の 32 バイトを 0x80 から取ろうとしますが、それ以上のデータがないため、31 個のゼロバイトで右詰めされます。

# 根拠

これにより、EVM 内での効率的な RSA 検証や、その他の数論に基づく暗号化が可能になります。加算と減算のための前処理を追加する必要はありません。EVM 内のアルゴリズムが十分に効率的であり、乗算は `a * b = ((a + b)**2 - (a - b)**2) / 4` を使って、この前処理で行うことができます。

ビットベースの指数計算は、2 (乗算用)、3、65537 (RSA 検証用) などの一般的に使用される指数に対して適切にガスを請求するために行われています。

# 著作権

著作権およびそれに関連する権利は [CC0](../LICENSE.md) により放棄されています。