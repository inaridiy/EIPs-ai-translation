---
original: 0a9e934c3589c2ad3a20221ce39ec2a46135170e68148267804c6477c2296b25
---

---
eip: 5283
title: 再入力保護のためのセマフォ
description: コールスタックを使用した並列化可能な再入力保護のためのプリコンパイルベース
author: Sergio D. Lerner (@SergioDemianLerner)
discussions-to: https://ethereum-magicians.org/t/eip-5283-a-semaphore-for-parallelizable-reentrancy-protection/10236
status: 停滞
type: Standards Track
category: Core
created: 2022-07-17
requires: 20, 1283, 1352
---

## 概要

このEIPは、再入力保護ガード(RPG)の新しいタイプを作成するためのセマフォ関数を提供するプリコンパイルドコントラクトを追加することを提案しています。この関数は、コントラクトストレージセルを変更するという典型的なRPGを置き換えることを目的としています。プリコンパイルベースのRPGはストレージに書き込まないため、EVM トランザクションの並列実行のための細かい(つまり、セルレベルの)並列化を提供するすべての設計と互換性があります。

## 動機

典型的なスマートコントラクトのRPGは、コントラクトストレージセルを使用します。アルゴリズムは単純です。コードはストレージセルが0(または事前に定義された定数)であることを確認し、そうでない場合はアボートします。その後、必要なコードを実行し、終了前にセルを再び0に設定します。これは、OpenZeppelinのReentrancyGuardで実装されているアルゴリズムです。このアルゴリズムは、RPGのストレージセルに対する読み書きパターンをもたらします。このパターンは、細かい並列化(ストレージセルレベルの競合検出)を提供するすべての既知の設計におけるスマートコントラクトの実行の並列化を妨げます。

いくつかのEVMベースのブロックチェーンは、EVMの並列化のための設計をテストしてきました。最良の結果は、個々のストレージセルの使用を追跡することで競合を検出する細かい並列化で得られています。アカウントやコントラクトの使用を追跡するデザインは、ほとんどのトランザクションが同じ[EIP-20](./eip-20.md)コントラクトを使用するため、わずかな利点しか提供しません。

要約すると、現在利用可能なRPGの構築は、コントラクトストレージセルを使用するものです。この構築は簡潔ですが、トランザクション実行の並列化と互換性がありません。

## 仕様

アクティベーションブロック(TBD)から、新しいプリコンパイルドコントラクト `Semaphore` が `0x0A` のアドレスに作成されます。`Semaphore` が呼び出されると、呼び出し元のアドレスがコールスタックに複数回存在する場合、最初の命令が `REVERT` であったかのように動作し、CALL は 0 を返します。それ以外の場合は、コードを実行せず 1 を返します。コントラクトの実行のガスコストは 100 に設定され、呼び出し結果に関係なく消費されます。

## 根拠

アドレス `0x0A` は、[EIP-1352](./eip-1352)で定義された範囲内で次に利用可能なものです。

### サンプル使用例

```solidity
pragma solidity ^0.8.0;

abstract contract ReentrancyGuard2 {

    uint8 constant SemaphoreAddress = 0x0A;
    /**
     * @dev 自身を直接的または間接的に呼び出すことを防ぎます。
     * `nonReentrant` 関数から別の `nonReentrant` 関数を呼び出すことはサポートされています。      
     */
    modifier nonReentrant() {
        _nonReentrantBefore();
        _;
    }

    function _nonReentrantBefore() private {
    	assembly {
            if iszero(staticcall(1000,SemaphoreAddress,  0, 0, 0, 0)) {
                revert(0, 0)
            }
        }
    }
}
```

### 並列化可能なストレージベースのRPG

既存のコントラクトでストレージベースのRPG構築を並列化する唯一の方法は、VMが RPGに使用されるストレージ変数を自動的に検出し、それが必要に応じて機能することを証明することです。これには静的コード解析が必要です。コンセンサスでこれを実装するのは2つの理由で難しいです。1つ目は、検出や証明のCPUコストが高い可能性があることです。2つ目は、一部の契約関数がRPGによって保護されていない可能性があり、一部の実行パスがRPGを変更しないことが証明を複雑にする可能性があることです。したがって、このプロポーザルは、すでに展開されているものではなく、将来のコントラクトを保護し、並列化可能にすることを目的としています。

### 代替案

EVMでRPGを実装するための代替設計があります:

1. 一時的なストレージオペコード(`TLOAD`/`TSTORE`)は、同じトランザクション内の呼び出し間で保持されるが、その後ワールドステートにコミットされないコントラクトステートを提供します。これらのオペコードは細かい並列化も可能にします。
2. `SSTORE_COUNT` オペコードは、実行された `SSTORE` 命令の数を取得します。これにより、細かい実行並列化も可能ですが、`SSTORE_COUNT` を正しく使用するのは複雑で、実行された `SSTORE` 命令の数ではなく、再入力呼び出しの数を推測する必要があります。
3. `LOCKCALL` オペコードは、`STATICALL` と似ていますが、呼び出し元のコントラクトでのストレージ書き込みのみをブロックします。これにより、RPGのコストが安くなりますが、一部の契約関数がRPGから自由にならないという欠点があります。

これらの代替案はすべて、同じガスコストで同じ機能をプリコンパイルを使用して実装できる場合、新しいオペコードを作成することが望ましくないという欠点があります。新しいオペコードを追加すると、コンパイラ、デバッガ、静的解析ツールを変更する必要があります。

### ガスコスト

100 ガスのコストは、スタックがほぼ満杯(約 400 アドレス)で完全にスキャンされる最悪のリソース消費を表します。スタックは常にRAMに存在するため、スキャンは高速です。

注: gethでコードが実装されると、ベンチマークを取り、コストを再評価できます。実際には、それよりも低くなる可能性があります。プリコール呼び出しの現在のコストが 700 ガスであるため、スタックスキャンのコストがプリコール呼び出し全体のコスト(合計 800 ガス)に与える影響は低いです。

現在のストレージベースのRPGのコストは [EIP-1283](./eip-1283.md) で導入された節約のおかげで 200 ガスです。`Semaphore` プリコンパイルをリエントラントチェックとして使用すると、現在 800 ガス(関数修飾子からの単一の呼び出し)かかります。このコストは従来のRPGコストよりも高いため、その使用を控えさせますが、EIP-1283 以前のコストよりはるかに低くなっています。プリコール呼び出しのコスト削減が実装された場合、`Semaphore` プリコンパイルの使用コストは約 140 ガスまで下がり、現在の 200 ガスを消費するストレージベースのRPGよりも低くなります。プリコンパイルベースのRPGの使用を奨励するために、このEIPはプリコール呼び出しコストの削減と一緒に実装することが提案されています。

## 下位互換性

この変更にはハードフォークが必要であり、したがってすべてのフルノードを更新する必要があります。

## テストケース

```solidity
contract Test is ReentrancyGuard2 {
    function second() external nonReentrant {
    }
    function first() external nonReentrant {
        this.second();
    }
}
```

トランザクションから直接 `second()` を呼び出すと、リバートしませんが、`first()` を呼び出すとリバートします。

## セキュリティ上の考慮事項

議論が必要です。

## 著作権

著作権およびその関連権利は [CC0](../LICENSE.md) で放棄されています。