---
original: cfff36d2470dab957393e12ca6d89372379f2d1395baf5db8b8d953a0873c0ea
---

---
eip: 7251
title: MAX_EFFECTIVE_BALANCEの増加
description: バリデーターが32 ETHの下限を維持しつつ、より大きな有効残高を持てるようにする。
author: mike (@michaelneuder)、Francesco (@fradamt)、dapplion (@dapplion)、Mikhail (@mkalinin)、Aditya (@adiasg)、Justin (@justindrake)、lightclient (@lightclient)
discussions-to: https://ethereum-magicians.org/t/eip-7251-increase-the-max-effective-balance/15982
status: レビュー
type: Standards Track
category: Core
created: 2023-06-28
requires: 7002, 7685
---
## 概要

`MAX_EFFECTIVE_BALANCE`定数を増加させますが、最小ステーキング残高は32 ETHのままとします。これにより、大規模なノード運営者がより少数のバリデーターに集約できるようになり、個人ステーカーも複利報酬を得られ、より柔軟な増額単位でステーキングできるようになります。

## 動機

2023年10月3日時点で、コンセンサスレイヤーには83万人以上のバリデーターが参加しています。このセットのサイズは、部分的に`MAX_EFFECTIVE_BALANCE`に起因して継続的に増加しています。これは単一のバリデーターの持分を32 ETHに制限しているためです。これにより、単一のエンティティが管理する「冗長なバリデーター」が大量に存在することになります。これらは同じビーコンノードで稼働しているものの、個別のBLS署名鍵を持っています。`MAX_EFFECTIVE_BALANCE`の制限は、元のシャーディングデザインからの技術的負債です。当時は、サブコミッティー(アテステーション委員会ではなく、`is_aggregator`で計算される委員会)の過半数が正直である必要がありました。その結果、サブコミッティーメンバーの重みを概ね等しくすることで、単一の大規模バリデーターが過度の影響力を持つリスクを低減していました。現在のデザインでは、これらのサブコミッティーはアテステーション集約にのみ使用されており、`1/N`の正直性仮定しか必要ありません。

プロトコルのセキュリティモデルが`MAX_EFFECTIVE_BALANCE`の低い値に依存しなくなったため、最小バリデーター閾値の32 ETHを維持しつつ、この値を引き上げることを提案します。この増加により、バリデーターセットのサイズを削減し、ネットワーク上のP2Pメッセージ数、エポックごとに集約する必要があるBLS署名の数、およびBeaconStateのメモリフットプリントを削減することができます。この変更は、小規模および大規模なバリデーターの両方に価値をもたらします。大規模なバリデーターは、より少数のバリデーターおよびビーコンノードを運用できるようになります。小規模なバリデーターは、複利報酬の恩恵を受けられるようになり、より柔軟な増額単位(例えば、現在の64 ETHを2つのバリデーターとして運用する代わりに40 ETHを1つのバリデーターとして運用できるようになる)でステーキングできるようになります。

## 仕様

### 定数

#### 実行レイヤー

| 名称 | 値 | コメント |
| - | - | - |
| `CONSOLIDATION_REQUEST_TYPE` | `0x02` | [EIP-7685](./eip-7685.md)におけるコンソリデーション要求のタイププレフィックス |
| `CONSOLIDATION_REQUEST_PREDEPLOY_ADDRESS` | `0x` | コンソリデーション要求メカニズムを呼び出して関連する詳細を保存する場所 |
| `SYSTEM_ADDRESS` | `0xfffffffffffffffffffffffffffffffffffffffe` | システム操作をコントラクトに呼び出すために使用されるアドレス |
| `EXCESS_CONSOLIDATION_REQUESTS_STORAGE_SLOT` | `0` | |
| `CONSOLIDATION_REQUEST_COUNT_STORAGE_SLOT` | `1` | |
| `CONSOLIDATION_REQUEST_QUEUE_HEAD_STORAGE_SLOT` | `2` | コンソリデーション要求メッセージキューの先頭を指すポインター |
| `CONSOLIDATION_REQUEST_QUEUE_TAIL_STORAGE_SLOT` | `3` | コンソリデーション要求メッセージキューの末尾を指すポインター |
| `CONSOLIDATION_REQUEST_QUEUE_STORAGE_OFFSET` | `4` | 状態内のコンソリデーション要求メッセージキューの開始メモリスロット |
| `MAX_CONSOLIDATION_REQUESTS_PER_BLOCK` | `1` | ブロックあたりにデキューできるコンソリデーション要求の最大数 |
| `TARGET_CONSOLIDATION_REQUESTS_PER_BLOCK` | `1` | |
| `MIN_CONSOLIDATION_REQUEST_FEE` | `1` | |
| `CONSOLIDATION_REQUEST_FEE_UPDATE_FRACTION` | `17` | |
| `EXCESS_INHIBITOR` | `1181` | 最初のシステムコール前に手数料を計算するために使用される過剰値 |
| `FORK_TIMESTAMP` | *TBD* | メインネット |

#### コンセンサスレイヤー

| 名称 | 値 |
| - | - |
| `COMPOUNDING_WITHDRAWAL_PREFIX` | `Bytes1('0x02')` |
| `MIN_ACTIVATION_BALANCE` | `Gwei(2**5 * 10**9)`  (32 ETH) |
| `MAX_EFFECTIVE_BALANCE` | `Gwei(2**11 * 10**9)` (2048 ETH) |

### 実行レイヤー

#### コンソリデーション要求

新しいコンソリデーション要求は、以下のフィールドで構成される[EIP-7685](./eip-7685.md)要求(タイプ`0x02`)です:

1. `source_address`: `Bytes20`
2. `source_pubkey`: `Bytes48`
3. `target_pubkey`: `Bytes48`

[EIP-7685](./eip-7685.md)の引き出し要求の**エンコーディング**は以下のように計算されます:

```python
encoded = CONSOLIDATION_REQUEST_TYPE ++ rlp([source_address, source_pubkey, target_pubkey])
```

#### コンソリデーション要求コントラクト

このコントラクトには3つの異なるコードパスがあり、高レベルでは以下のように要約できます:

1. コンソリデーション要求の追加 - 96バイトの入力が必要で、ソースバリデーターとターゲットバリデーターの公開鍵を連結したものです。
2. 過剰なコンソリデーション要求の取得 - 入力長がゼロの場合、現在の過剰なコンソリデーション要求数を返します。
3. システムプロセス - システムアドレスから呼び出された場合、現在のブロックからコンソリデーション要求をキューから取り除きます。

##### コンソリデーション要求の追加

コントラクトへの呼び出しデータ入力が正確に96バイトの場合、以下を実行します:

1. 現在のコンソリデーション要求手数料をカバーするのに十分なETHが送信されたことを確認する(`check_fee()`)
2. 現在のブロックのコンソリデーション要求数を1増やす(`increment_count()`)
3. ソースアドレスおよびソースとターゲットの公開鍵のコンソリデーション要求をキューに挿入する(`insert_withdrawal_request_into_queue()`)

具体的には、この機能は擬似コードの関数`add_consolidation_request()`として定義されています:

```python
def add_consolidation_request(Bytes48: source_pubkey, Bytes48: target_pubkey):
    """
    add_consolidation_requestは、十分な手数料が提供されている限り、新しい要求をコンソリデーション要求キューに追加します。
    """

    # 十分な手数料が提供されたことを確認する。
    fee = get_fee()
    require(msg.value >= fee, '手数料が不足しています')

    # コンソリデーション要求数を増やす。
    count = sload(CONSOLIDATION_REQUEST_PREDEPLOY_ADDRESS, CONSOLIDATION_REQUEST_COUNT_STORAGE_SLOT)
    sstore(CONSOLIDATION_REQUEST_PREDEPLOY_ADDRESS, CONSOLIDATION_REQUEST_COUNT_STORAGE_SLOT, count + 1)

    # キューに挿入する。
    queue_tail_index = sload(CONSOLIDATION_REQUEST_PREDEPLOY_ADDRESS, CONSOLIDATION_REQUEST_QUEUE_TAIL_STORAGE_SLOT)
    queue_storage_slot = CONSOLIDATION_REQUEST_QUEUE_STORAGE_OFFSET + queue_tail_index * 4
    sstore(CONSOLIDATION_REQUEST_PREDEPLOY_ADDRESS, queue_storage_slot, msg.sender)
    sstore(CONSOLIDATION_REQUEST_PREDEPLOY_ADDRESS, queue_storage_slot + 1, source_pubkey[0:32])
    sstore(CONSOLIDATION_REQUEST_PREDEPLOY_ADDRESS, queue_storage_slot + 2, source_pubkey[32:48] ++ target_pubkey[0:16])
    sstore(CONSOLIDATION_REQUEST_PREDEPLOY_ADDRESS, queue_storage_slot + 3, target_pubkey[16:48])
    sstore(CONSOLIDATION_REQUEST_PREDEPLOY_ADDRESS, CONSOLIDATION_REQUEST_QUEUE_TAIL_STORAGE_SLOT, queue_tail_index + 1)
```

###### 手数料計算

以下の擬似コードは、過剰なコンソリデーション要求の数に応じて、個々のコンソリデーション要求のコストを計算できます。

```python
def get_fee() -> int:
    excess = sload(CONSOLIDATION_REQUEST_PREDEPLOY_ADDRESS, EXCESS_CONSOLIDATION_REQUESTS_STORAGE_SLOT)
    return fake_exponential(
        MIN_CONSOLIDATION_REQUEST_FEE,
        excess,
        CONSOLIDATION_REQUEST_FEE_UPDATE_FRACTION
    )

def fake_exponential(factor: int, numerator: int, denominator: int) -> int:
    i = 1
    output = 0
    numerator_accum = factor * denominator
    while numerator_accum > 0:
        output += numerator_accum
        numerator_accum = (numerator_accum * numerator) // (denominator * i)
        i += 1
    return output // denominator
```

##### 過剰なコンソリデーション要求の取得

```python
def get_excess_consolidation_requests():
    count = sload(CONSOLIDATION_REQUEST_PREDEPLOY_ADDRESS, EXCESS_CONSOLIDATION_REQUESTS_STORAGE_SLOT)
    return count
```

##### システムコール

コントラクトが空の入力データで`SYSTEM_ADDRESS`として呼び出された場合、以下を実行します:

* キューからコンソリデーション要求がデキューされ、キューが空になった場合はキューの先頭/末尾ポインターがリセットされます(`dequeue_consolidation_requests()`)
* 現在のブロックでの使用に基づいて、コントラクトの過剰なコンソリデーション要求が更新されます(`update_excess_consolidation_requests()`)
* コントラクトのコンソリデーション要求数がゼロにリセットされます(`reset_consolidation_requests_count()`)

具体的には、この機能は擬似コードの関数`process_consolidation_requests()`として定義されています:

```python
###################
# Public function #
###################

def process_consolidation_requests():
    reqs = dequeue_consolidation_requests()
    update_excess_consolidation_requests()
    reset_consolidation_requests_count()
    return reqs

###########
# Helpers #
###########

class ConsolidationRequest(object):
    source_address: Bytes20
    source_pubkey: Bytes48
    target_pubkey: Bytes48

def dequeue_consolidation_requests():
    queue_head_index = sload(CONSOLIDATION_REQUEST_PREDEPLOY_ADDRESS, CONSOLIDATION_REQUEST_QUEUE_HEAD_STORAGE_SLOT)
    queue_tail_index = sload(CONSOLIDATION_REQUEST_PREDEPLOY_ADDRESS, CONSOLIDATION_REQUEST_QUEUE_TAIL_STORAGE_SLOT)
    num_in_queue = queue_tail_index - queue_head_index
    num_dequeued = min(num_in_queue, MAX_CONSOLIDATION_REQUESTS_PER_BLOCK)

    reqs = []
    for i in range(num_dequeue):
        queue_storage_slot = CONSOLIDATION_REQUEST_QUEUE_STORAGE_OFFSET + (queue_head_index + i) * 4
        source_address = address(sload(CONSOLIDATION_REQUEST_PREDEPLOY_ADDRESS, queue_storage_slot)[0:20])
        source_pubkey = (
            sload(CONSOLIDATION_REQUEST_PREDEPLOY_ADDRESS, queue_storage_slot + 1)[0:32] + sload(CONSOLIDATION_REQUEST_PREDEPLOY_ADDRESS, queue_storage_slot + 2)[0:16]
        )
        target_pubkey = (
            sload(CONSOLIDATION_REQUEST_PREDEPLOY_ADDRESS, queue_storage_slot + 2)[16:32] + sload(CONSOLIDATION_REQUEST_PREDEPLOY_ADDRESS, queue_storage_slot + 3)[0:32]
        )
        req = ConsolidationRequest(
            source_address=Bytes20(source_address),
            source_pubkey=Bytes48(source_pubkey),
            target_pubkey=Bytes48(target_pubkey)
        )
        reqs.append(req)

    new_queue_head_index = queue_head_index + num_dequeued
    if new_queue_head_index == queue_tail_index:
        # キューが空になったので、キューのポインターをリセットする
        sstore(CONSOLIDATION_REQUEST_PREDEPLOY_ADDRESS, CONSOLIDATION_REQUEST_
QUEUE_HEAD_STORAGE_SLOT, 0)
        sstore(CONSOLIDATION_REQUEST_PREDEPLOY_ADDRESS, CONSOLIDATION_REQUEST_QUEUE_TAIL_STORAGE_SLOT, 0)
    else:
        sstore(CONSOLIDATION_REQUEST_PREDEPLOY_ADDRESS, CONSOLIDATION_REQUEST_QUEUE_HEAD_STORAGE_SLOT, new_queue_head_index)

    return reqs

def update_excess_consolidation_requests():
    previous_excess = sload(CONSOLIDATION_REQUEST_PREDEPLOY_ADDRESS, EXCESS_CONSOLIDATION_REQUESTS_STORAGE_SLOT)
    # 最初の反復後にゼロにリセットする必要があるかどうかを確認する
    if previous_excess == EXCESS_INHIBITOR:
        previous_excess = 0

    count = sload(CONSOLIDATION_REQUEST_PREDEPLOY_ADDRESS, CONSOLIDATION_REQUEST_COUNT_STORAGE_SLOT)

    new_excess = 0
    if previous_excess + count > TARGET_CONSOLIDATION_REQUESTS_PER_BLOCK:
        new_excess = previous_excess + count - TARGET_CONSOLIDATION_REQUESTS_PER_BLOCK

    sstore(CONSOLIDATION_REQUEST_PREDEPLOY_ADDRESS, EXCESS_CONSOLIDATION_REQUESTS_STORAGE_SLOT, new_excess)

def reset_consolidation_requests_count():
    sstore(CONSOLIDATION_REQUEST_PREDEPLOY_ADDRESS, CONSOLIDATION_REQUEST_COUNT_STORAGE_SLOT, 0)
```

##### バイトコード

```asm
caller
push20 0xfffffffffffffffffffffffffffffffffffffffe
eq
push1 0x98
jumpi

calldatasize
iszero
iszero
push1 0x28
jumpi

push0
sload
push0
mstore
push1 0x20
push0
return

jumpdest
calldatasize
push1 0x60
eq
iszero
push2 0x0144
jumpi

push1 0x11
push0
sload
push1 0x01
dup3
mul
push1 0x01
swap1
push0

jumpdest
push0
dup3
gt
iszero
push1 0x59
jumpi

dup2
add
swap1
dup4
mul
dup5
dup4
mul
swap1
div
swap2
push1 0x01
add
swap2
swap1
push1 0x3e
jump

jumpdest
swap1
swap4
swap1
div
callvalue
lt
push2 0x0144
jumpi

push1 0x01
sload
push1 0x01
add
push1 0x01
sstore
push1 0x03
sload
dup1
push1 0x04
mul
push1 0x04
add
caller
dup2
sstore
push1 0x01
add
push0
calldataload
dup2
sstore
push1 0x01
add
push1 0x20
calldataload
dup2
sstore
push1 0x01
add
push1 0x40
calldataload
swap1
sstore
push1 0x01
add
push1 0x03
sstore
stop

jumpdest
push1 0x03
sload
push1 0x02
sload
dup1
dup3
sub
dup1
push1 0x01
gt
push1 0xac
jumpi

pop
push1 0x01

jumpdest
push0

jumpdest
dup2
dup2
eq
push1 0xf1
jumpi

dup1
push1 0x74
mul
dup4
dup3
add
push1 0x04
mul
push1 0x04
add
dup1
sload
swap1
push1 0x01
add
dup1
sload
swap1
push1 0x01
add
dup1
sload
swap1
push1 0x01
add
sload
swap3
push1 0x60
shl
dup5
mstore
swap1
dup4
push1 0x14
add
mstore
dup3
push1 0x34
add
mstore
swap1
push1 0x54
add
mstore
push1 0x01
add
push1 0xae
jump

jumpdest
swap2
add
dup1
swap3
eq
push2 0x0103
jumpi

swap1
push1 0x02
sstore
push2 0x010e
jump

jumpdest
swap1
pop
push0
push1 0x02
sstore
push0
push1 0x03
sstore

jumpdest
push0
sload
dup1
push2 0x049d
eq
iszero
push2 0x011d
jumpi

pop
push0

jumpdest
push1 0x01
sload
push1 0x01
dup3
dup3
add
gt
push2 0x0132
jumpi

pop
pop
push0
push2 0x0138
jump

jumpdest
add
push1 0x01
swap1
sub

jumpdest
push0
sstore
push0
push1 0x01
sstore
push1 0x74
mul
push0
return

jumpdest
push0
push0
revert
```

##### デプロイメント

コンソリデーション要求コントラクトは、他のスマートコントラクトと同様にデプロイされます。目的のデプロイトランザクションから逆算して、特殊な合成アドレスが生成されます:

```json
{
  "type": "0x0",
  "nonce": "0x0",
  "to": null,
  "gas": "0x3d090",
  "gasPrice": "0xe8d4a51000",
  "maxPriorityFeePerGas": null,
  "maxFeePerGas": null,
  "value": "0x0",
  "input": "0x61049d5f5561014880600f5f395ff33373fffffffffffffffffffffffffffffffffffffffe146098573615156028575f545f5260205ff35b36606014156101445760115f54600182026001905f5b5f82111560595781019083028483029004916001019190603e565b90939004341061014457600154600101600155600354806004026004013381556001015f35815560010160203581556001016040359055600101600355005b6003546002548082038060011160ac575060015b5f5b81811460f15780607402838201600402600401805490600101805490600101805490600101549260601b84529083601401528260340152906054015260010160ae565b9101809214610103579060025561010e565b90505f6002555f6003555b5f548061049d141561011d57505f5b6001546001828201116101325750505f610138565b01600190035b5f555f6001556074025ff35b5f5ffd",
  "v": "0x1b",
  "r": "0x539",
  "s": "0x13370066aa8fbe21ca1511",
  "hash": "0x6de32a89ba4c0592fd2453f8838d6bb69d93a102723de5f4b0f046ddcf8b8fa9"
}
```

```
Sender: 0xd6e25886D7B986C394156C31a48e84Ee0BA71f72
Address: 0x00b42dbF2194e931E80326D950320f7d9Dbeac02
```

#### ブロック処理

`block.timestamp >= FORK_TIMESTAMP`(つまり、すべてのトランザクションの処理と、ブロック本文要求の検証が完了した後)の任意の実行ブロックの最後に、クライアントソフトウェアは以下の手順を**必ず**実行しなければなりません:

1. 空の入力データでSYSTEM_ADDRESSとしてコントラクトを呼び出し、システムサブルーチンを実行する。
2. [EIP-7685](./eip-7685.md)要求リストのコンソリデーション要求が、スマートコントラクトの`dequeue_consolidation_requests()`関数から返されたリストと順序を守って一致することを確認する。この条件が満たされない場合、ブロックは**無効**とみなされなければならない。

### コンセンサスレイヤー

このEIPの定義的な特徴は以下の通りです:

1. ***`MAX_EFFECTIVE_BALANCE`の増加と`MIN_ACTIVATION_BALANCE`の作成***。可変サイズのバリデーターを可能にする中核的な機能。
2. ***プロトコルを通じて複数のバリデーターインデックスを組み合わせることの許可***。大規模なノード運営者がバリデーターを統合できるメカニズム(退出および活性化キューを循環させることなく)。
3. ***バリデーターが自分のバリデーターの上限を設定できるようにする***。部分的な引き出しのスイープがアクティブになる「上限」を柔軟に定義できるようになる。
4. ***実行レイヤーの部分的な引き出し(EIP-7002の一部)の追加***。実行レイヤーのメッセージが、完全な退出に加えて部分的な引き出しをトリガーできるようになる(例えば、100 ETHのバリデーターは68 ETHまで引き出せるようになる)。
5. ***初期のスラッシング罰則の削除(議論中)***。これにより、大規模なバリデーターの統合リスクが低減される。

[根拠](#根拠)セクションには、これらの提案された中核的な機能の説明が含まれています。コンセンサスレイヤーへの変更の概要は以下の通りです。

1. `COMPOUNDING_WITHDRAWAL_PREFIX`と`MIN_ACTIVATION_BALANCE`定数を追加し、`MAX_EFFECTIVE_BALANCE`の値を更新する。
2. 重み付きレート制限メカニズムで入金を追跡するために使用される`PendingDeposit`コンテナを作成する。
3. 入金および退出キューの重み付きレート制限に必要なフィールドで`BeaconState`を更新する。
4. `is_eligible_for_activation_queue`を更新して`MIN_ACTIVATION_BALANCE`ではなく`MAX_EFFECTIVE_BALANCE`をチェックするようにする。
5. `get_validator_churn_limit`をバリデーター数ではなくバリデーターの重みに依存するように変更する。
6. 現在の保留中の引き出しに基づいて退出エポックを計算する`compute_exit_epoch_and_update_churn`ヘルパーを作成する。
6. `initiate_validator_exit`を更新して、バリデーター数ではなくバランスでキューを制限する。
7. `initialize_beacon_state_from_eth1`を更新して`MIN_ACTIVATION_BALANCE`を使用する。
9. `process_registry_updates`を更新して、適格なすべてのバリデーターをアクティブ化する。
10. 一時的な入金を消費する`process_pending_balance_deposits`という1エポックあたりのヘルパーを追加する。
10. `get_validator_from_deposit`を更新して、有効残高を0で初期化する(保留中の入金フローで更新される)。
11. `apply_deposit`を更新して、入金を`state.pending_balance_deposits`に格納する。
12. `is_aggregator`を重み付きに変更する。
13. `compute_weak_subjectivity_period`を新しいチャーン制限関数を使用するように変更する。
14. `0x02`資格情報を持つかどうかを確認する`has_compounding_withdrawal_credential`を追加する。
15. `is_fully_withdrawable_validator`を更新して、複利の資格情報をチェックする。
16. バリデーターの超過残高を計算する`get_validator_excess_balance`を追加する。
17. `is_partially_withdrawable_validator`を更新して超過残高をチェックする。
18. `get_expected_withdrawals`を超過残高を使用するように変更する。

## 根拠

このEIPは、プロトコルの経済的セキュリティを変更することなく、バリデーターの総数を削減することを目的としています。大規模なノード運営者が管理する多額の持分を、より少数のバリデーターに集約できるメカニズムを提供します。各中核的な機能の理由を分析します。

1. ***`MAX_EFFECTIVE_BALANCE`の増加と`MIN_ACTIVATION_BALANCE`の作成***
    * *`MAX_EFFECTIVE_BALANCE`を増加させて大規模なステーカーを許可しつつ、`32 ETH`の下限(新しい定数`MIN_ACTIVATION_BALANCE`を導入)を維持することで、個人ステーキングを奨励する。*
2. ***プロトコルを通じて複数のバリデーターインデックスを組み合わせることの許可***
    * *すでに数千のバリデーターを管理している大規模なステーキングプールにとって、退出および再入力は非常に遅く、コストがかかります。プロトコル内の統合を許可することで、EIPの採用が大幅に高まります。*
3. ***バリデーターが自分のバリデーターの上限を設定できるようにする***
    * *報酬にアクセスするために、バリデーターは自分の有効残高の上限を柔軟に設定したい可能性があります。これにより、オプション性が高まり、部分的な引き出しのスイープ(ガスレスで報酬を引き出す方法)を継続してサポートする方法が明確になります。*
4. ***実行レイヤーの部分的な引き出し(EIP-7002の一部)の追加***
    * *有効残高の上限を引き上げるバリデーターにとって、実行レイヤーからトリガーされる部分的な引き出しを許可することで、ステーキング設定の柔軟性が高まります。バリデーターは、いつ、どのくらい引き出すかを選択できますが、ELトランザクションのガス代を支払う必要があります。*
5. ***初期のスラッシング罰則の削除(議論中)***
    * *統合を奨励するために、
スラッシング罰則を変更することができます。最大のダメージは、バリデーターの有効残高の1/32の初期罰則です。これは有効残高に比例して拡大するため、大規模なバリデーターは直接的にリスクが高くなります。スケーリングプロパティを変更することで、統合をより魅力的にすることができます。*

## 下位互換性

このEIPは、コンセンサスレイヤーのブロック検証ルールセットに下位互換性のない変更を導入し、ハードフォークを伴う必要があります。これらの変更は、現在のユーザーアクティビティや体験に関連するものではありません。

## セキュリティの考慮事項

この変更はコミッティーとチャーンを変更しますが、セキュリティプロパティに大きな影響を与えるものではありません。

### アテステーションコミッティーのセキュリティ

完全な統合が最悪のシナリオとして考えられますが、敵対的なコミッティーの乗っ取りの確率は低いままです。高い統合シナリオでも、最終確定に必要な2/3超過多数の正直なバリデーターの割合は依然として低くなっています。

### アグリゲーター選択

元のシャーディングロードマップでは、サブコミッティーは非常に高い確率で安全である必要がありました。現在では、アテステーション集約のみの責任を負っているため、各コミッティーに少なくとも1人の正直なアグリゲーターがいれば十分です。現在、アグリゲーターは VRFロトリーで選択されており、非統合の攻撃者によって偏らせることができます。この提案では、VRFロトリーを重みを考慮するように変更するため、少なくとも1人の正直なアグリゲーターを持つ確率は悪化しません。

### プロポーザー選択確率

プロポーザー選択は既に有効残高の比率に基づいて重み付けされています。確率が低くなるため、次のプロポーザーインデックスを計算するのにわずかに時間がかかるようになります。

### シンクコミッティー選択確率

シンクコミッティー選択も有効残高に基づいて重み付けされているため、この提案ではシンクプロトコルに変更は必要ありません。ライトクライアントは、重みに関係なく、スーパーマジョリティのパーティシパントが署名した更新を確認できます。

### チャーンの不変条件

この提案は、アクティブな重みを制限するための活性化および退出のチャーン不変条件を維持します。トップアップは明示的に処理され、完全な入金と同じ活性化キューの対象となります。

## 著作権

著作権およびその関連権利は[CC0](../LICENSE.md)で放棄されています。