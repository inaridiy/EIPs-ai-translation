---
original: 6725520ff327f1eb636cdc099030639fe0aaf4e6748d33335e3dec4c78f9b1bf
---

---
eip: 2936
title: SELFDESTRUCTed契約のEXTCLEAR Opcode
author: William Morriss (@wjmelements)
discussions-to: https://ethereum-magicians.org/t/eip-2936-extclear-for-selfdestruct/4569
status: 停滞
type: Standards Track
category: Core
created: 2020-09-03
---

## 簡単な要約
`SELFDESTRUCT`された契約のストレージをクリアする新しいオペコードを有効にする。

## 概要
`SELFDESTRUCT` (`0xff`) を変更して、ストレージをクリアしないようにし、以前に自己破壊された契約の特定のストレージスロットをクリアする新しい `EXTCLEAR` (`0x5c`) オペコードを追加する。

## 動機
`SELFDESTRUCT` (`0xFF`) は、無制限の量の契約ストレージをクリアするため、不必要に複雑です。
すべての契約のストレージを追跡する必要があるため、ノードにとって計算コストがかかります。
さらに、`CREATE2` (`0xF5`) を使用して契約を再初期化し、事前のストレージを `SLOAD` (`0x54`) することができます。
したがって、いくつかのイーサリアムクライアントはストレージをまったくクリアせず、`SSTORE` (`0x55`) 中に契約が開始されたかどうかのみをチェックします。
`CREATE2` は `SLOAD` を複雑化することを意図していませんでした。この変更により、その複雑さが解消されます。
さらに、この実装のバグにより、ネットワークが分割される可能性があります。

代わりに、ストレージのクリーンアップの時期を遅らせ、ストレージをそのままの状態に残すことで、`SLOAD` と `SELFDESTRUCT` の複雑さを軽減します。

これにより、アップグレード時にストレージをリセットする必要がなくなるため、`CREATE2` 再生プロキシパターンが強化されます。
アトミックな再生アップグレードでは、契約が破壊される間にストレージの一部をクリアし、その後再度インストールできます。

## 仕様

`FORK_BLOCK_NUM` 以降、新しいオペコード `EXTCLEAR` が `0x5C` で有効になり、`SELFDESTRUCT`された契約のストレージをクリアできるようになります。
`EXTCLEAR`:
* スタックにワードをプッシュしない
* スタックから2つのワード(破壊された契約アドレスとストレージアドレス)をポップする
* 契約が存在する場合、`EXTCODEHASH` (`0x3F`) と同じガスコストを請求する
* それ以外の場合、ストレージがゼロの場合は `EXTCODEHASH` に加えて `SLOAD` と同じガスコストを請求する
* それ以外の場合、破壊された契約のスロットがリセットされ、`EXTCODEHASH` と `SSTORE` (ストレージリセット時)と同じガスコストが請求され、`SSTORE` で指定された量が払い戻される。

`SELFDESTRUCT` は、契約ストレージをクリアしないように変更されます。
この変更は遡及的にも機能します。以前に破壊された契約をすべてクリーンアップできます。

## 根拠
`0x5C` は `SSTORE` と `SLOAD` と同じ範囲にあります。

## 下位互換性
内部ストレージがすべてクリアされることを期待するリバイバルアップグレードメカニズムが破損する可能性がありますが、そのようなアップグレードメカニズムでは、この新しい動作に適応できるはずです。

## テストケース
TODO

## 実装
主要なクライアントすべてでオペコードを追加する実装が必要です。

## セキュリティ上の考慮事項
状態がマリシャスな `EXTCLEAR` によってクリアされることを期待していない再生契約は、敵対的な動作を避けるために自身を再初期化する必要があります。

## 著作権
[CC0](../LICENSE.md)によりすべての著作権およびそれに関連する権利が放棄されています。