---
original: 3d5b5c014f1ba8fa0240d53f66b9defc03b350961d615a6c5f1b6259d79567bf
---

---
eip: 6913
title: SETCODE命令
description: コードを場所を変えずに置き換える新しい命令
author: William Morriss (@wjmelements)
discussions-to: https://ethereum-magicians.org/t/eip-6913-setcode-instruction/13898
status: Draft
type: Standards Track
category: Core
created: 2023-04-20
---

## 概要

`SETCODE` (`0xfc`) 命令を導入し、実行中のアカウントのコードをメモリから置き換えることができるようにする。

## 動機

多くのコントラクトは、改善や決定の延期を容易にするために、アドレスを移行せずにアップグレード可能になっている。
コントラクトは現在、次のようないくつかの方法でこれを行っている:

最も古い方法は `CALL` を使うものである。
この方法の限界は、内部状態がすべての将来の実装によって変更可能でなければならないことである。

2つ目は、`DELEGATECALL` でプロキシ実装を行うものである。
一部のプロキシは最小限のものであり、他のものは多数の別々の実装アカウントにブランチする。
この方法では、アカウントコードサイズ制限を回避することもできる。

3つ目の方法は、`SELFDESTRUCT` と `CREATE2` を使ってコードを場所を変えずに置き換えるものである。
この方法は、外部コントラクトに呼び出す必要がないことで、前の方法を改善している。
この方法の1つの限界は、`SELFDESTRUCT` によって内部状態がすべて削除されてしまうことである。
もう1つの限界は、`SELFDESTRUCT` がトランザクションの最後まで、コードを削除しないため、`CREATE2` によるアップグレードが完了するまでアベイラビリティが犠牲になることである。

`SELFDESTRUCT` の今後の非推奨化を考えると、`SETCODE` は場所を変えずにコードを置き換える better な方法を導入する。

## 仕様

`STATICCALL` によって作成されるような読み取り専用の実行スコープ内では、`SETCODE` は例外的な中断を引き起こす。

現在実行中のコードが実行中アカウントのコードと等しくない場合、たとえば `DELEGATECALL` や `CREATE` の内部で発生する場合、`SETCODE` は例外的な中断を引き起こす。

それ以外の場合、`SETCODE` はスタックから2つの単語、オフセットと長さを消費する。
これらは、新しいコードを含むメモリの範囲を指定する。
`CREATE` や `CREATE2` の結果に対して行われるすべての検証は即座に行われ、例外的な中断を引き起こす可能性がある。
`EXTCODESIZE` と `EXTCODECOPY` は、更新されたコードを照会するようになり、`DELEGATECALL`、`CALLCODE`、`CALL`、`STATICCALL` などのメッセージ呼び出しは、更新されたコードを実行するようになる。
置き換えられたコードを既に実行しているすべての実行スコープ、`SETCODE` を含む、は引き続き前のコードを実行する。
そのようなスコープ内では、`CODESIZE` と `CODECOPY` は引き続き実行中のコードを照会する。

`SSTORE` と同様に、このアカウント変更は、現在のスコープまたは任意の親スコープが巻き戻されるか中断された場合に巻き戻される。

`SELFDESTRUCT` とは異なり、`SETCODE` はアカウントの残高、ノンス、ストレージをクリアしない。

### ガス

この操作のガス代は、`Gselfdestruct` と、新しいコードのバイト数に `Gcodedeposit` を乗じた値の合計である。

## 根拠

`CODECOPY`、`CODESIZE`、`EXTCODESIZE`、`EXTCODECOPY` の動作は、実行中のコードが実行中アカウントのコードと異なる可能性がある `DELEGATECALL` や `CREATE` の動作と一致する。

`SETCODE` のガス代は `CREATE` と同程度だが、新しい実行コンテキストや新しいアカウントが作成されないため、`Gcreate` は除外されている。
その他のアカウント変更コストは、実行ガス以外で考慮される。

`SELFDESTRUCT` とは異なり、`SETCODE` の後の実行は通常通り進行し、検証と返却データを可能にする。
アップデート後の検証は `REVERT` または再帰的な `SETCODE` で `SETCODE` 操作を元に戻すことができるが、`REVERT` はガスが少なくて済む。

ほとんどの `DELEGATECALL` 内での `SETCODE` を禁止することで、変更可能なコードを簡単に識別するための静的分析が可能になる。
`SETCODE` 操作を含まないアカウントコードは、不変であると安全に見なすことができる。
巻き戻されないコンテキストで観察された不変のコードは不変のままであり、不変性のオンチェーン静的分析を可能にする。

## 下位互換性

コードを変更する唯一の従来の操作は `SELFDESTRUCT` である。
`SELFDESTRUCT` によるコード変更はトランザクションの最後まで遅延されるため、`SETCODE` との相互作用は明確に定義されている。

## テストケース

| CodeStart            | CallData         | CodeResult           | Gas  |
|----------------------|------------------|----------------------|------|
| 365f5f37365ffc00     | 365f5f37365ffc00 | 365f5f37365ffc00     | 6613 |
| 365f5f37365ffc00     | 00               | 00                   | 5213 |
| 365f5f37365ffc00     |                  |                      | 5013 |
| 365f5f37365ffc595ffd | 365f5f37365ffc00 | 365f5f37365ffc595ffd | 6617 |
| 365f5f37365ffcfe     | 365f5f37365ffc00 | 365f5f37365ffcfe     |  all |

## セキュリティ上の考慮事項

`SETCODE` に関連するリスクは、他のアップグレードパターンにも同様に適用される。

ほとんどのコントラクトは置き換えられるべきではなく、アップグレード可能であるべきではない。
アップグレード機構には永久的な障害のリスクがある。
アップグレードの可能性はそのようなリスクを永続化する。

アップグレード操作へのアクセスは制限されるべきである。
アップグレードは決して急いで行われるべきではなく、疲れた状態で行われるべきではない。
アップグレードは可能な限り本番環境に近い条件でテストされるべきである。差異は予期せぬ結果の源となる。
可能な場合は、複数のエンジニアがペンディングのアップグレード手順をプレビューし、独立して検証するべきである。

ブロックエクスプローラ、ウォレット、その他のインターフェイスは、アップグレード可能なコードにフラグを立てるべきである。
クライアントソフトウェアは、アップグレード可能なアカウントの [ERC-20](./eip-20.md) や [ERC-721](./eip-721.md) トークンの承認に警告を表示するべきである。

## 著作権

著作権およびそれに関連する権利は [CC0](../LICENSE.md) によって放棄されています。