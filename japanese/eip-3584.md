---
original: f2e34b752b13150132197757bbfe35f3d04b958772ec5a36eb9dac9cbc6c3cf2
---

---
eip: 3584
title: ブロックアクセスリスト
author: Gajinder Singh (@g11in), Piper Merriam (@pipermerriam)
discussions-to: https://ethresear.ch/t/block-access-list-v0-1/9505
status: 停滞
type: Standards Track
category: Core
created: 2021-05-22
requires: 2929, 2930
---

## 簡単な要約
ブロックの `access_list` を構築し、その指紋 `AccessListRoot` をブロックヘッダーに含めることを提案します。

## 概要
[EIP-2929](./eip-2929.md)/[EIP-2930](./eip-2930.md)は、トランザクションによるデータ/ストレージアクセスの (低い) ガスコストの正規化と、新しいトランザクションタイプフォーマットの提供と奨励に焦点を当てています:
```
0x01 || rlp([chainId, nonce, gasPrice, gasLimit, to, value, data, access_list, yParity, senderR, senderS])
```
ここで `access_list` は `[[{20 bytes}, [{32 bytes}...]]...]` の `AccessedAddress=> AccessedStorageKeys` マップです。

これらの事前宣言された *アクセス* の最初のアクセスは割引価格 (約 `10%`) で課金され、このリスト外の最初のアクセスは高価格で課金されます。 この事前アクセス宣言により、トランザクションの実行時にこれらの場所を *プリロード/最適化/バッチ* 読み込むことができるためです。
これにより、トランザクションの `access_list` には (宣言されたか否かにかかわらず) そのトランザクションによるすべての (最初の) アクセスが生成されます。
この提案は、ブロック内のすべてのトランザクションの *トランザクション* `access_list` を集約し、その *指紋* をブロックヘッダーに含めることです。

## 動機
ブロックの *トランザクション* `access_list` を集約する動機は、ブロックのアクセスインデックスを持つことで以下のような利点があるためです:
1. アクセスの *部分順序* を構築することで、ブロックの実行/検証の最適化、並列化、キャッシュウォームアップが可能になります (ヒント: この *ポセット* の *チェーン* は並列化できます)。
2. *ライトシンク* や *ファーストシンク* プロトコルが関心を持つアドレスのサブセットのデータ/状態の部分的な検査、フェッチ、提供が可能になります。
3. *ステートレス* プロトコルのためのウィットネスデータのバンドリング、提供、フェッチのインデックスとして、この一覧をさらに拡張することが可能です。

## 仕様
ブロックの `access_list` は以下のように表されます:
```
Set [ 
    AccessedAddress, 
    List [AccessedStorageKeys] , 
    Set  [ AccessedInBlockTransactionNumber, List [ AccessedStorageKeys ]]  
]
```
このような `access_list` の *正準* な構築は以下のように指定されています。

### 正準ブロックアクセスリスト
`access_list` は多数の `access_list_entry` 要素で構成されます:
```
access_list   :=  [access_list_entry, ...]
```

`access_list_entry` は 3 つのタプルで構成されます:
* アドレス
* そのアドレスがブロック全体でアクセスしたストレージキーのソート済みリスト
* 以下の 2 つのタプルのソート済みリスト:
    * そのアドレスまたはそのストレージキーのいずれかがアクセスされたトランザクションのインデックス
    * アクセスされたストレージキーのソート済みリスト

```
access_list                 := [access_list_entry, ...]
access_list_entry           := [address, storage_keys, accesses_by_txn_index]
address                     := bytes20
accesses_by_txn_index       := [txn_index_and_keys, ...]
txn_index_and_keys          := [txn_index, storage_keys]
txn_index                   := uint64  # or uint256 or whatever
storage_keys                := [storage_key, ...]
storage_key                 := bytes32
```

上記のための追加のソート規則は以下の通りです:
* `access_list` は `address` でソートされます
* `storage_keys` はソートされます
* `accesses_by_txn_index` は `txn_index` でソートされます

上記の追加の検証規則は以下の通りです:
* `access_list` 内の各一意の `address` は最大 1 回しか出現しません
* `storage_keys` 内の各 `storage_key` は最大 1 回しか出現しません
* `txn_index_and_keys` 内の各 `txn_index` は最大 1 回しか出現しません

すべてのソートは昇順です。

### AccessListRoot
`AccessListRoot` は、正準の `access_list` およびその構築タイプ (`sha256`) とシリアル化タイプ (`json`) の URN *のような* エンコーディング `Hash/Commitment` です。つまり、
```
AccessListRoot := "urn:sha256:json:0x${ SHA256( access_list.toJSONString('utf8') ).toHexString() }"
```
ここで `0x${ SHA256 (...)...}` は、先頭の `0x` で示される `32` バイトの `SHA256` ハッシュ化された16進文字列です。

### 追加のブロック検証
新しいブロックを検証するには、ブロックの `AccessListRoot` が、ブロックの実行時に `AccessListRoot` URN によって定義された構築を使って生成されたものと一致することを確認する追加の検証チェックが必要です。

## 根拠
### 正準 `access_list` のソート
適用可能な場合は、常に辞書順または整数ソートで指定されるようにソートされます。アクセス時間に基づくソートも検討されましたが、実装の複雑さとブックキーピングを追加するコストに見合う追加の利点はないと判断されました。

### `AccessListRoot` 
`AccessListRoot` は *グリーフィング* 攻撃を防ぐために生成され、*ブロックヘッダー*に含まれ (そして検証される) 必要があります。
`AccessListRoot` は現在、正準の `access_list` の単純な `sha256` ハッシュとして指定されていますが、他の構築を検討するのが有益でしょう:
* ツリー構造 (`merkle`/`verkle`)。少し高価になりますが、`access_list` の部分的なダウンロード、検査、検証を可能にします。 
* 通常の `kate` コミットメントを生成することで、この部分的な機能を実現でき、推奨されます。部分的にアクセスリストのチャンクを検証するのが非常に簡単になります。

また、`access_list` のシリアル化は現在、通常の `JSON String` ダンプとして指定されていますが、これらのパラメーターは構築ごとに異なる可能性があります。ただし、簡単のため、常に `sha256` ハッシュを取って一貫した `32` バイトの16進文字列ルートを得ることができます。

したがって、このAccessListRootは `urn:merkle:ssz:...` や `urn:kate:...` などに進化する可能性があり、またその他のスキームに変更することもできます。そして、AccessListRootをURN *のような* 構造にする考えは、ブロック構造に影響を与えずにこれらのパスにアップグレードできるようにするためです。

### `access_list` の将来の拡張
ブロックの `access_list` にウィットネスを含めるように拡張できます:
```
access_list := Set[ 
    Address,
    List [ AddressWitnesses ],
    Set  [ AccessedStorageKey, List [ StorageKeyWitnesses] ],        
    Set  [ AccessedInBlockTransactionNumber, List [ AccessedStorageKeys ] ]
]
```
そして、正準の仕様を構築するための指紋を定義することができます。
これにより、部分的または完全なステートレス性への段階的なパスが可能になり、この `access_list` を使ってウィットネスを簡単にバンドル/リクエストできるようになります。

## 下位互換性
追加のブロック検証は、このEIPが有効になるブロック番号以降で必須となりますが、クライアントはこのアクセスリストを要求に応じて (JSON/RPCAPIを介して) 生成 (および保存) する方法を提供することができます。ただし、これはオプションであり、クライアントに依存します。

## セキュリティ上の考慮事項
この変更による既知のセキュリティ上の問題はありません。

## 著作権
著作権およびその関連権利は [CC0](../LICENSE.md) で放棄されています。