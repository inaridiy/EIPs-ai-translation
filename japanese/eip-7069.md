---
original: 0c29db7d96b529ee81864289cb2db3375e76e87cc00fdbc724ad529f1bd9d2f4
---

---
eip: 7069
title: 改訂された CALL 命令
description: 簡略化されたセマンティクスを持つ EXTCALL、EXTDELEGATECALL、EXTSTATICCALL の導入
author: Alex Beregszaszi (@axic)、Paweł Bylica (@chfast)、Danno Ferrin (@shemnon)、Andrei Maiboroda (@gumb0)、Charles Cooper (@charles-cooper)
discussions-to: https://ethereum-magicians.org/t/eip-revamped-call-instructions/14432
status: Review
type: Standards Track
category: Core
created: 2023-05-05
requires: 150, 211, 214, 2929, 3540
---

## 概要

`EXTCALL`、`EXTDELEGATECALL`、`EXTSTATICCALL` の3つの新しい呼び出し命令を導入し、セマンティクスを簡略化する。また、リターンデータからワードをスタックにロードする `RETURNDATALOAD` 命令を導入する。[EIP-3540](./eip-3540.md) で定義された EOF 形式のコード内で実行される `RETURNDATACOPY` 命令の動作を変更する。既存の `*CALL` 命令は変更されない。

新しい命令ではガス制限を指定できないが、代わりに "63/64ルール" ([EIP-150](./eip-150.md)) を使ってガスを制限する。重要な改善点は、"スティペンド" に関するルールが簡素化され、呼び出し側が値を送信するかどうかの特別な計算を行う必要がなくなることである。

さらに、出力バッファのアドレスを指定する機能は廃止され、代わりに `RETURNDATACOPY` を使用する。以前は `*CALL` で出力バッファに出力し、そこから `MLOAD` していた場合は、`RETURNDATALOAD` が提供される。

最後に、実行ステータスを表すブール値の代わりに、拡張可能なステータスコードのリストを返すようになる: 成功は `0`、リバートは `1`、失敗は `2`。

ほとんどの新しいコントラクトは簡単さと ガス節約のために新しい命令を使用すると期待されるが、ガス制限が必要な特定のコントラクト (例: [ERC-4337](./eip-4337.md)) では、古い命令を使い続けることになる。

## 動機

ガスの可観測性は長年の問題であった。ガスシステムは、Ethereum の使用方法の変化や基盤となるハードウェアの変化に適応するために (そして適応しなければならない) 柔軟であった。

残念ながら、多くの場合、呼び出し命令に悪影響を及ぼすのを避けるために、妥協点や回避策を講じる必要があった。これは主に、呼び出し命令のセマンティクスと期待が複雑であったためである。

この変更は、新しい命令からガスの可観測性を取り除き、ガス料金の変更の影響を受けない新しいクラスのコントラクトを可能にすることを目的としている。さらに、EVM オブジェクトフォーマット (EOF) が導入されると、レガシーの呼び出し命令は EOF コントラクト内で拒否されるため、ガス料金の変更の影響をほとんど受けなくなる。これらの操作はガスの可観測性を排除するために必要であり、レガシーの命令の代わりに EOF で必要とされる。

Solidity 0.4.21 以降、コンパイラはすでに残りのガスをすべて呼び出しに渡す (ただし、開発者が明示的なオーバーライド (`{gas: ...}`) を使用する場合を除く) ことに注目するのは重要である。これは、ほとんどのコントラクトがガスを制御する必要はないことを示唆している。

上記に加えて、この変更では、成功 (0)、リバート (1)、失敗 (2) の詳細なステータスコードを返す便利な機能を導入する。これにより、ブール値オプションから、将来的に拡張可能なコードに移行する。

最後に、[EIP-211](./eip-211.md) での `RETURNDATA*` 命令の導入により、呼び出しの出力パラメータが不要になった多くのケースがある。出力バッファの使用は過去に "バグ" を引き起こしていた。[ERC-20](./eip-20.md) の場合、一部の実装では何かを返し、他の実装では何も返さないなど、競合する実装が多くの問題を引き起こした。`RETURNDATA*` 命令に依存することで、これが暗黙的に明確化される。この提案では、リターンデータバッファへのアクセスを完備するために、"欠落している" `RETURNDATALOAD` 命令も追加する。

## 仕様

| 名称 | 値 | コメント |
|------|-------|---------|
| WARM_STORAGE_READ_COST | 100 | [EIP-2929](./eip-2929.md) から |
| COLD_ACCOUNT_ACCESS | 2600 | [EIP-2929](./eip-2929.md) から |
| CALL_VALUE_COST | 9000 | |
| ACCOUNT_CREATION_COST | 25000 | |
| MIN_RETAINED_GAS | 5000 | |
| MIN_CALLEE_GAS | 2300 | |

4つの新しい命令を導入する:

- `EXTCALL` (`0xf8`) の引数 `(target_address, input_offset, input_size, value)`
- `EXTDELEGATECALL` (`0xf9`) の引数 `(target_address, input_offset, input_size)`
- `EXTSTATICCALL` (`0xfb`) の引数 `(target_address, input_offset, input_size)`
- `RETURNDATALOAD` (`0xf7`) の引数 `offset`

この EIP が EOF アップグレードの一部として含まれる場合、これら4つの新しい命令はレガシーコードでは未定義であり、EOF コードでのみ利用可能となる。

`EXT*CALL` の実行セマンティクス:

1. `WARM_STORAGE_READ_COST` (100) ガスを請求する。
2. スタックから必要な引数をポップし、スタックアンダーフローが発生した場合は例外的な失敗で停止する。
    - **注意**: EOF で実装する場合、スタックアンダーフローチェックはスタック検証時に行われ、実行時のチェックは省略される。
3. `value` が0以外の場合:
    - 現在のフレームが `static-mode` にある場合は、例外的な失敗で停止する。
    - `CALL_VALUE_COST` ガスを請求する。
4. `target_address` の上位12バイトのいずれかが0以外の値を含む場合 (つまり、20バイトのアドレスではない) は、例外的な失敗で停止する。
5. `[input_offset, input_size]` を使ってメモリ拡張を行い、その分のガスを請求する。
6. `target_address` が `warm_account_list` にない場合、`COLD_ACCOUNT_ACCESS - WARM_STORAGE_READ_COST` (2500) ガスを請求する。
7. `target_address` がステートにない場合で、呼び出し設定がアカウント作成につながる場合、`ACCOUNT_CREATION_COST` (25000) ガスを請求する。
    - このEIPの場合、そのような場合は `value` が0以外の場合のみである。
8. 呼び出し側の残りガスから `max(floor(gas/64), MIN_RETAINED_GAS)` を減じた値を、被呼び出し側の利用可能ガスとする。
9. リターンデータバッファをクリアする。
10. 以下のいずれかが true の場合、ステータスコード `1` をスタックに返して失敗する (この時点までに請求されたガスのみ消費される):
    - 被呼び出し側の利用可能ガスが `MIN_CALLEE_GAS` 未満。
    - 現在のアカウントの残高が `value` 未満。
    - 現在のコールスタックの深さが `1024` に等しい。
11. 利用可能ガスと設定を使って呼び出しを実行する。
12. スタックにステータスコードを push する:
    - 呼び出しが成功した場合は `0`。
    - 呼び出しがリバートした場合は `1` (軽度の失敗シナリオでも早期に push される可能性がある)。
    - 呼び出しが失敗した場合は `2`。
13. 被呼び出し側が使用しなかったガスは呼び出し側に返される。

`RETURNDATALOAD` の実行セマンティクス:

1. `G_verylow` (3) ガスを請求する
2. スタックから1つのアイテムをポップし、これを `offset` と呼ぶ
3. スタックに1つのアイテムをプッシュする。これは、リターンデータバッファから `offset` から始まる32バイトのワードを読み取ったものである。
4. `offset + 32 > len(returndata buffer)` の場合、結果はゼロパディングされる。

この EIP が EOF アップグレードの一部として含まれる場合、[EIP-3540](./eip-3540.md) で定義された EOF 形式のコード内での `RETURNDATACOPY` の実行セマンティクスが以下のように変更される:

1. スタックから3つの引数 `destOffset`、`offset`、`size` をポップすると仮定する。
2. `offset + size > len(returndata buffer)` の場合、**例外的な失敗で停止せず**、コピーされた部分の後の `offset + size - len(returndata buffer)` バイトをゼロに設定する。
3. メモリコピーに請求されるガスは、実際にコピーされたバイト数や、ゼロに設定されたバイト数に関わらず、`3 * num_words(size)` のままとする。

EOF 形式のコード以外 (つまり、レガシーコード) での `RETURNDATACOPY` の実行は変更されない。

**TODO:** ガス控除側 (呼び出し側/被呼び出し側) と、エラーの発生源を明確にする。

**TODO:** ガス払い戻しについて言及する。

**TODO:** 非呼び出しデータ値転送を許可しない代わりに、特定の `TRANSFER`/`PAY` 関数を設けるオプションを検討する。これにより、ロジックを大幅に簡素化できる。

## 根拠

### ガス選択可能性の除去

元の `CALL` 命令シリーズからの大きな変更点の1つは、呼び出し側がコールに渡すガスの量を制御できなくなったことである。そのような機能が不可欠な場合は、おそらく直接プロトコルに統合するほうが適切である。

ガス選択可能性を除去することで、ガス料金表の将来の改訂にも役立つ重要な特性が導入される: 常に、トランザクションにより多くのガスを送ることで、Out of Gas (OOG) エラーを回避できるようになる (ブロックガス制限の範囲内)。以前、ストレージコストを引き上げた ([EIP-1884](./eip-1884.md)) 際、呼び出しに限定的なガスしか送らなかった一部のコントラクトが壊れていた。

したがって、あるコントラクトは次の呼び出しに送るガスの上限を持っており、その上限を超えてガスを使うことはできなかった。追加のガスを送っても、呼び出しがガス制限を設けるため、問題を解決できなかった。このルール集では、スティペンドの下限が保持されている。この下限は、スマートコントラクトとは独立して変更できるため、OOG 停止をトランザクションにより多くのガスを送ることで修正できるようになる。

### スティペンドと 63/64ルール

スティペンドの目的は、"コントラクトウォレット" が呼び出されたときに、ログを出力する (つまり、状態変更を伴わない操作を行う) ために十分なガスを持つことである。スティペンドは `CALL` 命令を使用し、値が0以外の場合にのみ追加される。

63/64ルールには複数の目的がある:

a. コールの深さを制限する
b. コーラーが呼び出し側から戻った後に状態変更を行うのに十分なガスを残すことを保証する

さらに、コールの深さカウンターがあり、深さが1024を超えるとコールが失敗する。

63/64ルールが導入される前は、呼び出し側で利用可能ガスをある程度正確に計算する必要があった。Solidity には複雑なルールセットがあり、呼び出し自体を実行するのにどれくらいのコストがかかるかを見積もり、合理的なガス量を設定しようとしていた。

ルールセットを変更した:

63/64ルールは依然として適用されるが
- 少なくとも `MIN_RETAINED_GAS` ガスが被呼び出し側の実行前に呼び出し側に残される
- 少なくとも `MIN_CALLEE_GAS` ガスが被呼び出し側に利用可能

`MIN_CALLEE_GAS` ルールはスティペンドの代替品であり、ガストコストの推論を簡素化し、すべての導入された `EXT*CALL` 命令に一様に適用される。
次の表は違いを示している (呼び出し側の必要ガスと呼び出し側のコスト (消費ガス) の間の不一致に注意)。

|                 | 呼び出し側の必要ガス | 呼び出し側のコスト (消費ガス) | 呼び出し側の最小残存ガス | 被呼び出し側の最小ガス |   
|-----------------|---------------------|--------------------------|-------------------------|----------------|
| CALL V=0        | 100                 | 100                      | 0                       | 0              |
| CALL V≠0        | 100+9000            | 100+6700                 | 0                       | 2300           |
| DELEGATECALL    | 100                 | 100                      | 0                       | 0              |
| STATICCALL      | 100                 | 100                      | 0                       | 0              |
| EXTCALL V=0     | 100                 | 100                      | 5000                    | 2300           |
| EXTCALL V≠0     | 100+9000            | 100+9000                 | 5000                    | 2300           |
| EXTDELEGATECALL | 100                 | 100                      | 5000                    | 2300           |
| EXTSTATICCALL   | 100                 | 100                      | 5000                    | 2300           |

- **呼び出し側の必要ガス**: 呼び出し命令を実行するために呼び出し側が必要とする最小ガス量。これ以下だと呼び出し側のOOGが発生する。
- **呼び出し側のコスト (消費ガス)**: 命令を実行するために呼び出し側から差し引かれるガス量。この量は被呼び出し側には利用できない。
- **呼び出し側の最小残存ガス**: 呼び出し後に呼び出し側が確実に持つ最小ガス量。これが保証できない場合、被呼び出し側に到達する前に呼び出しが失敗する。
- **被呼び出し側の最小ガス**: 被呼び出し側の実行に必要な最小ガス制限。

コールスタックの深さチェックを削除することを当初検討したが、これは元の `*CALL` 命令や `CREATE*` 命令とも互換性がなくなるため、採用しなかった。そのため、コールスタックの深さチェックを維持することで、レガシーコードに影響を与えない。

また、ガスルールを回避できる場合でも、コールスタックの深さが制限されることを単純な (63/64ルールに比べて複雑ではない) ハードキャップとして安心できる。最後に、1024の深さに到達するのに必要なガスは膨大ではあるが、それほど膨大ではなく、現在のガス制限に依存することを避けたい。

### 出力バッファ

出力バッファのアドレスを指定する機能は削除された。これは複雑性を追加するものの、多くの場合、実装者は代わりに `RETURNDATACOPY` を使うことを好むためである。出力バッファに依存する場合 (Vyperの場合など) でも、`RETURNDATASIZE` でサイズを確認する。Solidityの1つの例外は、期待される返り値のサイズが既知の場合 (つまり、動的でない返り値) である。この場合、Solidityは依然として出力バッファを使用する。これらのケースのために、出力バッファにコピーしてそこから `MLOAD` する代わりに、`RETURNDATALOAD` を直接使用できるようになる。

### ステータスコード

現在の呼び出し命令は、成功を示すブール値を返す: 0は失敗、1は成功を意味する。Solidityコンパイラはこの値がブール値であると想定しているため、ステータスを分岐条件として使用する (`if iszero(status) { /* failure */ }`). これにより、既存のコントラクトを壊すことなく、新しいステータスコードを導入することができない。[EIP-211](./eip-211.md) の設計時には、リバートのための特定のコードを返す案が議論されたが、上記の理由から最終的に見送られた。

ブール値から、ステータスコードに変更する。`0` は成功を示し、将来的にさらに非成功のコードを導入することが可能になる。

ステータスコード `1` は、被呼び出しフレームからのリバートと、命令の実行中に遭遇した軽度の失敗の両方に使用される。これらを組み合わせる理由は、元の CALL と同様のセマンティクスを維持することである - どちらのシナリオでも未使用のガスが保持され、呼び出し側には区別がつかない。

### パラメータの順序

パラメータの順序を変更し、`value` フィールドを最後に移動した。これにより、最後のパラメータを除いて命令のエンコーディングが同一になり、EVM とコンパイラの実装を少し簡素化できる。

### オペコードのエンコーディング

3つの新しい `EXT*CALL` オペコードを導入する代わりに、即時設定バイト (フラグ) を持つバージョンについても検討した。これには2つの主な欠点がある:

1. 一部の組み合わせのフラグが有用/無効である可能性があり、これにより、テストと実装の表面積が増加する。
2. 命令がスタックアイテムの可変数を取る (つまり、`EXTCALL` の `value`) という、他の命令にはない新しい概念が必要になる。

また、EOF 内の既存の CALL シリーズを変更する代わりに、これらを新しいオペコードとして導入することも有用である。これにより、EOF コントラクトにガスの可観測性を復元する必要がある場合の "脱出口" ができる。これは、GAS と元の CALL シリーズのオペコードを EOF のオペコードリストに追加することで実現される。

### `CALLCODE`

`CALLCODE` は非推奨となっているため、ここでは対応する命令は導入しない。

### `target_address` が20バイトのイーサリアムアドレスではない場合に停止する

既存の `CALL` シリーズの命令では、アドレスが20バイトに収まらない場合、アドレスをマスクして20バイトに収まるように扱い、上位バイトを無視していた。`EXT*CALL` 命令の場合は、アドレスが存在しないものとして扱うのではなく、停止することにした。1つ目の理由は、アドレスが存在しない場合の値の送信を特別に扱う必要がなくなることである。2つ目の理由は、`warm_access_list` が20バイトのイーサリアムアドレス以外を追跡する必要がなくなることである。

スマートコントラクト開発者は、そのようなアドレスが渡された場合に命令がリバートすることに依存してはいけない。アドレススペース拡張の適切な提案が採用されると、`EXT*CALL` シリーズの命令もそれらの変更を採用することが期待される。

### レガシーでは新しい命令が未定義 (このEIPがEOFの一部である場合のみ)

このEIPがEOFアップグレードの一部として含まれる場合の代替シナリオとして、4つの新しい命令がレガシーEVMでも**追加的に**利用可能にするというものがある。ただし、EOFが含まれるフォークおよびその後のフォークでレガシーEVMへの変更を制限することが好ましい。

### `RETURNDATALOAD` と `RETURNDATACOPY` のパディング動作

この EIP は当初、レガシーの `RETURNDATACOPY` のOOB (Out-of-Bounds) 時の停止動作を維持することを提案していた。これにより、不要な `RETURNDATA*` 命令を最適化できなくなるため、コンパイラの最適化が難しくなる。

`RETURNDATALOAD` のみにパディング動作を与えるという代替案もあったが、密接に関連する `RETURNDATACOPY` 命令との不整合が生じる。

`RETURNDATACOPY2` を導入し、パディング動作を持たせ、同時に EOF 内での `RETURNDATACOPY` の使用を禁止するという選択肢もあったが、オペコードの増加を避けるため、また、コンパイラ実装の観点から最適ではないと判断された。

## 後方互換性

既存の命令は変更されないため、後方互換性の問題は発生しないと考えられる。

## セキュリティ上の考慮事項

攻撃面が広がることはないと期待される。これらの操作はすべて、固定ガス (利用可能なすべて) と出力範囲 (ゼロ長のゼロメモリ) でモデル化できる既存の操作で表現できる。

EOF で実装される場合 (GAS オペコードと元の CALL 操作が削除される)、既存の OOG 攻撃はやや困難になるが、完全に防ぐことはできない。トランザクションは任意のガス値を渡すことができ、巧妙なコントラクト構築により、特定の呼び出しに特定のガス値が渡されるようにすることができる。EOF でも同じ表面が残ると期待されるが、攻撃の容易さは低減される。

## 著作権

著作権およびそれに関連する権利は [CC0](../LICENSE.md) で放棄されています。