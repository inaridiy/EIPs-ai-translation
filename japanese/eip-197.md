---
original: 96355ab680ea8fae76e05c69009e30bd0ec87f352bec9312515b1cbabc6fe89d
---

---
eip: 197
title: 楕円曲線alt_bn128の最適なate ペアリングチェックのための事前コンパイルされたコントラクト
author: Vitalik Buterin <vitalik@ethereum.org>, Christian Reitwiessner <chris@ethereum.org>
type: Standards Track
category: Core
status: Final
created: 2017-02-06
---

## 簡単な要約

ブロックガスリミット内でzkSNARKの検証を行うには、楕円曲線ペアリング演算のための事前コンパイルされたコントラクトが必要です。

## 概要

このEIPでは、特定のペアリング対応楕円曲線上のペアリング関数の事前コンパイルされたコントラクトを追加することを提案しています。これは、[EIP-196](./eip-196.md)と組み合わせることで、Ethereumスマートコントラクト内でzkSNARKsを検証できるようになります。EthereumにおけるzkSNARKsの一般的な利点は、ユーザーのプライバシーを向上させること(Zero-Knowledgeプロパティのため)と、スケーラビリティの解決策となること(簡潔性と効率的な検証性のため)です。

## 動機

現在のEthereumスマートコントラクトの実行は完全に透明であるため、場所、身元、過去の取引履歴などの非公開情報を含む多くのユースケースに適していません。zkSNARKsの技術がこの問題の解決策となる可能性があります。EthereumバーチャルマシンはzkSNARKsを理論的に利用できますが、現在のブロックガスリミット内では非常に高コストです。そのため、このEIPでは、zkSNARKsを効率的に実装し、ガスコストを削減できるよう、いくつかの基本的なプリミティブのパラメーターを指定することを提案しています。

これらのパラメーターを固定することで、zkSNARKsのユースケースが制限されるわけではありません。むしろ、ハードフォークを行うことなく、zkSNARKの研究の進展を取り入れることができるようになります。

ペアリング関数は、現在のzkSNARKsに必要な乗法的準同型演算の限定的な形式を実行するために使用できます。この事前コンパイルされたコントラクトは、ペアリング関数の評価ではなく、特定のチェックを指定するものです。これは、ペアリング関数の余域が非常に複雑な領域であり、エンコーディングの問題が発生する可能性があるためで、zkSNARKsでの既知の用途はこの指定されたチェックのみを必要としているためです。

## 仕様

`block.number >= BYZANTIUM_FORK_BLKNUM`のブロックについて、楕円曲線"alt_bn128"上のグループの双線形関数の事前コンパイルされたコントラクトを追加します。離散対数に基づいて事前コンパイルされたコントラクトを定義します。離散対数は計算が困難であると想定されていますが、以下で効率的に計算できるペアリング関数を使用した同等の仕様を示します。

アドレス: 0x8

素数位数 `q` の巡回群 `G` (加法的に書かれる)について、ジェネレーター `P` に関する離散対数 `log_P: G -> F_q` を、`log_P(x)` が `n * P = x` を満たす最小の非負整数 `n` として定義します。

事前コンパイルされたコントラクトは以下のように定義されます。ここで、2つのグループ `G_1` と `G_2` は、以下で定義されるジェネレーター `P_1` と `P_2` によって定義されます。両方のジェネレーターは同じ素数位数 `q` を持ちます。

```
入力: (a1, b1, a2, b2, ..., ak, bk) from (G_1 x G_2)^k
出力: 入力の長さが正しくない、または入力のいずれかが対応するグループの要素ではないか、正しくエンコードされていない場合、呼び出しは失敗します。
     そうでない場合、
     log_P1(a1) * log_P2(b1) + ... + log_P1(ak) * log_P2(bk) = 0
     (in F_q) の場合は1を、そうでない場合は0を返します。
```

`k` は入力の長さから決まります。エンコーディングについての節に従えば、`k` は入力の長さを192で割った値です。入力の長さが192の倍数でない場合、呼び出しは失敗します。空の入力は有効で、1を返します。

`G_1` の要素であることを確認するには、座標のエンコーディングを検証し、曲線方程式(または無限遠点のエンコーディング)を満たすことを確認すれば十分です。`G_2`の場合は、それに加えて、要素の位数がグループの位数 `q = 21888242871839275222246405745257275088548364400416034343698204186575808495617` と等しいことも確認する必要があります。

### グループの定義

グループ `G_1` と `G_2` は、素数位数 `q = 21888242871839275222246405745257275088548364400416034343698204186575808495617` の巡回群です。

`G_1` は、フィールド `F_p` 上の曲線 `Y^2 = X^3 + 3` 上に定義され、ジェネレーター `P1 = (1, 2)` を持ちます。ここで、`p = 21888242871839275222246405745257275088696311157297823662689037894645226208583`です。

`G_2` は、別のフィールド `F_p^2 = F_p[i] / (i^2 + 1)` (pは上記と同じ)上の曲線 `Y^2 = X^3 + 3/(i+9)` 上に定義され、ジェネレーター
```
P2 = (
  11559732032986387107991004021392285783925812861821192530917403151452391805634 * i +
  10857046999023057135944570762232829481370756359578518086990519993285655852781,
  4082367875863433681332203403145435568316851327593401208105741076214120093531 * i +
  8495653923123431417604973247489272438418190587263600148770280649306958101930
)
```
を持ちます。

`G_2` は、その楕円曲線上の位数 `q` のグループの唯一のものです。`P2`以外のジェネレーターを使用しても、同じ `G_2` が定義されます。ただし、具体的な `P2` の値は、位数 `q` のグループの存在に疑問を持つ読者に役立ちます。彼らは、`q * P2` と `P2` の具体的な値を比較することができます。

### エンコーディング

`F_p` の要素は、32バイトのビッグエンディアンの数値としてエンコードされます。`p`以上の値はinvalid です。

`F_p^2` の要素 `a * i + b` は、2つの `F_p` の要素 `(a, b)` としてエンコードされます。

楕円曲線上の点は、無限遠点を `(0, 0)` としてエンコードされる、ヤコビアン対 `(X, Y)` としてエンコードされます。

入力の長さから `k` の値が導出されることに注意してください。

返されるデータの長さは常に32バイトで、32バイトのビッグエンディアンの数値としてエンコードされます。

### ガスコスト

事前コンパイルされたコントラクトのガスコストは、`80 000 * k + 100 000`です。ここで、`k`は点の数、つまり入力の長さを192で割った値です。

## 根拠

特に `alt_bn128` 曲線を選択したのは、zkSNARKsに特に適しているためです。より具体的には、ペアリング関数のビルディングブロックに適しています。さらに、この曲線を選択することで、ZCashとの相乗効果を活用し、その一部のコンポーネントやアーティファクトを再利用できます。

入力にカーブやフィールドのパラメーターを追加する機能は検討されましたが、最終的に仕様を複雑化するため却下されました。ガスコストの決定が非常に困難になり、実際の楕円曲線や効率的なペアリング実装ではないものに対してコントラクトを呼び出すことができてしまうためです。

コンパクトではないポイントエンコーディングが選択されたのは、スマートコントラクト自体でいくつかの操作を行えるようにするため(完全なy座標の含有)、2つのエンコードされた点の等価性を比較できるようにするためです。

`F_p^2` の要素のエンコーディングは、要素自体のビッグエンディアンエンコーディングに合わせて、この順序で選択されました。

## 下位互換性

事前コンパイルされたコントラクトの導入と同様に、既に指定のアドレスを使用しているコントラクトのセマンティクスが変更されます。そのため、"予約範囲"の256未満のアドレスが使用されています。

## テストケース

後で記述します。

## 実装

事前コンパイルされたコントラクトは、楕円曲線ペアリング関数、具体的には alt_bn128 曲線上の最適なateペアリングを使用して実装できます。これを理解するために、まず、ペアリング関数 `e: G_1 x G_2 -> G_T` が以下のプロパティを満たすことに注目してください(`G_1` と `G_2` は加法的に書かれ、`G_T` は乗法的に書かれます)。

(1) `e(m * P1, n * P2) = e(P1, P2)^(m * n)`
(2) `e` は非退化的

次に、以下が同値であることに注目してください:
```
log_P1(a1) * log_P2(b1) + ... + log_P1(ak) * log_P2(bk) = 0 (in F_q)
```
と
```
e(P1, P2)^(log_P1(a1) * log_P2(b1) + ... + log_P1(ak) * log_P2(bk)) = 1 (in G_T)
```

さらに、この式の左辺は以下と等しくなります:
```
e(log_P1(a1) * P1, log_P2(b1) * P2) * ... * e(log_P1(ak) * P1, log_P2(bk) * P2)
= e(a1, b1) * ... * e(ak, bk)
```

したがって、事前コンパイルされたコントラクトは、`e(a1, b1) * ... * e(ak, bk) = 1`を検証することで実装できます。

以下に実装例があります:

 - [libff](https://github.com/scipr-lab/libff/blob/master/libff/algebra/curves/alt_bn128/alt_bn128_g1.hpp) (C++)
 - [bn](https://github.com/zcash/bn/blob/master/src/groups/mod.rs) (Rust)
 - [Python](https://github.com/ethereum/py_pairing/blob/master/py_ecc/bn128/bn128_pairing.py)

## 著作権

著作権およびそれに関連する権利は[CC0](../LICENSE.md)によって放棄されています。