---
original: a71b1d97df49622c0583afcbc769af77ad4f56147d9fb2301400c8d0b84ec2ac
---

---
eip: 2539
title: BLS12-377曲線演算
description: BLS12-377曲線演算のプリコンパイル
author: Alex Vlasov (@shamatar), hujw77 (@hujw77)
discussions-to: https://ethereum-magicians.org/t/eip-2539-bls12-377-precompile-discussion-thread/4659
status: Draft
type: Standards Track
category: Core
created: 2020-02-26
requires: 1109, 2046
---

## 概要

このプリコンパイルは、(Zexe論文から)BLS12-377曲線上の演算を追加します。これにより、BLS署名検証や SNARKs 検証などの操作を効率的に実行できるようになります。BLS12-377の固有の特性により、BLS12-377ペアリングを効率的に検証するSNARKsを持つことができ、定数サイズのBLS署名集約などが可能になります。

`block.number >= X`の場合、以下の9つのプリコンパイルを導入します:

- BLS12_377_G1ADD - 素数体上の曲線上の点加算を実行する
- BLS12_377_G1MUL - 素数体上の曲線上の点乗算を実行する
- BLS12_377_G1MULTIEXP - 素数体上の曲線上の多重指数計算を実行する
- BLS12_377_G2ADD - 基底体の2次拡大体上の曲線のねじれ上の点加算を実行する
- BLS12_377_G2MUL - 基底体の2次拡大体上の曲線のねじれ上の点乗算を実行する
- BLS12_377_G2MULTIEXP - 基底体の2次拡大体上の曲線のねじれ上の多重指数計算を実行する
- BLS12_377_PAIRING - (G1, G2)点の組のペアリング演算を実行する
- BLS12_377_MAP_FP_TO_G1 - 基底体の元をG1点にマッピングする
- BLS12_377_MAP_FP2_TO_G2 - 拡大体の元をG2点にマッピングする

多重指数計算は、BLS署名検証時の公開鍵や個々の署名者の署名の集約を効率的に行うために含まれています。

### 提案されるアドレステーブル

| プリコンパイル           | アドレス |
| ----------------------- | ------- |
| BLS12_377_G1ADD         | 0x15    |
| BLS12_377_G1MUL         | 0x16    |
| BLS12_377_G1MULTIEXP    | 0x17    |
| BLS12_377_G2ADD         | 0x18    |
| BLS12_377_G2MUL         | 0x19    |
| BLS12_377_G2MULTIEXP    | 0x1a    |
| BLS12_377_PAIRING       | 0x1b    |
| BLS12_377_MAP_FP_TO_G1  | 0x1c    |
| BLS12_377_MAP_FP2_TO_G2 | 0x1d    |

## 動機

このプリコンパイルを追加する動機は、ペアリング友和曲線上の操作に対して80ビットのセキュリティしか提供しないBN254プリコンパイルに比べて、120ビット以上のセキュリティを提供できるようにすることです。さらに、BLS12-377ベースの署名の存在に関するプルーフの1回限りの再帰的な集約を可能にします。

## 仕様

曲線パラメータ:

BLS12-377曲線は、以下のパラメータセットによって完全に定義されます(BLS12曲線のすべてについて係数`A=0`):

```
基底体のモジュラス = 0x01ae3a4617c510eac63b05c06ca1493b1a22d9f300f5138f1ef3622fba094800170b5d44300000008508c00000000001
B係数 = 0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
主部分群の位数 = 0x12ab655e9a2ca55660b44d1e5c37b00159aa76fed00000010a11800000000001
拡張タワー:
Fp2の構築:
Fp2の2次非剰余元 = 0x01ae3a4617c510eac63b05c06ca1493b1a22d9f300f5138f1ef3622fba094800170b5d44300000008508bffffffffffc
Fp6/Fp12の構築:
Fp2の3次非剰余元 c0 = 0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
Fp2の3次非剰余元 c1 = 0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
ねじれパラメータ:
ねじれの種類: D
ねじれ c0 の B係数 = 0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
ねじれ c1 の B係数 = 0x010222f6db0fd6f343bd03737460c589dc7b4f91cd5fd889129207b63c6bf8000dd39e5c1ccccccd1c9ed9999999999a
ジェネレータ:
G1:
X = 0x008848defe740a67c8fc6225bf87ff5485951e2caa9d41bb188282c8bd37cb5cd5481512ffcd394eeab9b16eb21be9ef
Y = 0x01914a69c5102eff1f674f5d30afeec4bd7fb348ca3e52d96d182ad44fb82305c2fe3d3634a9591afd82de55559c8ea6
G2:
X c0 = 0x018480be71c785fec89630a2a3841d01c565f071203e50317ea501f557db6b9b71889f52bb53540274e3e48f7c005196
X c1 = 0x00ea6040e700403170dc5a51b1b140d5532777ee6651cecbe7223ece0799c9de5cf89984bff76fe6b26bfefa6ea16afe
Y c0 = 0x00690d665d446f7bd960736bcbb2efb4de03ed7274b49a58e458c282f832d204f2cf88886d8c7c2ef094094409fd4ddf
Y c1 = 0x00f8169fd28355189e549da3151a70aa61ef11ac3d591bf12463b01acee304c24279b83f5e52270bd9a1cdd185eb8f93
ペアリングパラメータ:
|x| (ミラーループスカラー) = 0x8508c00000000001
xは負ではない
```

### 基本要素のエンコーディングと詳細

#### 体要素のエンコーディング:

操作に関与する点をエンコードするには、基底体と拡大体の要素をエンコードする必要があります。

基底体要素(Fp)は、対応する(符号なし)整数のビッグエンディアン符号化を行うことで64バイトとしてエンコードされます(上位16バイトは常にゼロ)。64バイトを選択したのは、32バイトアラインのABI(例えば`bytes32[2]`や`uint256[2]`で表現可能)を持つためです。対応する整数は**必ず**フィールドのモジュラスより小さくなければなりません。

2次拡大体(Fp2)の要素のエンコーディングは、係数の個別のエンコーディングを連結したものになります。合計で128バイトになります。Fp2要素が`el = c0 + c1 * v`の形式で表されるとき、ここで`v`は2次非剰余元、`c0`と`c1`はFp要素です。対応するバイトエンコーディングは`encode(c0) || encode(c1)`となり、`||`はバイト連結を意味します(Solidityの型では`bytes32[4]`や`uint256[4]`を使うこともできます)。

仕様に従わないエンコーディングがプリコンパイルの解析時に発見された場合、プリコンパイルは必ずエラーを返さなければなりません。

#### G1/G2点のエンコーディング:

G1(基底体上)またはG2(拡大体上)の点は、アファイン座標`x`と`y`のエンコーディングを連結したものとしてエンコードされます。G1点の総エンコーディング長は128バイト、G2点は256バイトです。

#### 無限遠点のエンコーディング:

"ゼロ点"とも呼ばれます。BLS12曲線では、座標が`(0, 0)`(Fpまたはfp2の形式上のゼロ)の点は曲線上にはないため、そのような点`(0, 0)`のエンコーディングを無限遠点を表すための規約として使用します。

#### 乗算操作のスカラーのエンコーディング:

乗算操作のスカラーは、対応する(符号なし)整数のビッグエンディアン符号化を行うことで32バイトとしてエンコードされます。対応する整数は**必ずしも**主部分群の位数以下である必要はありません。

### 操作のABI

#### G1加算のABI

G1加算呼び出しでは、2つのG1点(`128バイトずつ`)のバイト連結である256バイトを入力として受け取ります。出力は加算操作の結果 - 単一のG1点(`128バイト`)のエンコーディングです。

エラーケース:
	- 点のいずれかが曲線上にない場合はエラーとなる
	- フィールド要素のエンコーディングルールが適用される(当然のこと)
	- 入力長が無効

#### G1乗算のABI

G1乗算呼び出しでは、G1点のエンコーディング(`128バイト`)とスカラー値のエンコーディング(`32バイト`)のバイト連結である160バイトを入力として受け取ります。出力は乗算操作の結果 - 単一のG1点(`128バイト`)のエンコーディングです。

エラーケース:
	- 点が曲線上にない場合はエラーとなる
	- フィールド要素のエンコーディングルールが適用される(当然のこと)
	- 入力長が無効

#### G1多重指数計算のABI

G1多重指数計算呼び出しでは、`k`個のスライスのバイト連結である`160*k`バイトを入力として受け取ります。各スライスは、G1点のエンコーディング(`128バイト`)とスカラー値のエンコーディング(`32バイト`)のバイト連結です。出力は多重指数計算操作の結果 - 単一のG1点(`128バイト`)のエンコーディングです。

エラーケース:
	- G1点のいずれかが曲線上にない場合はエラーとなる
	- フィールド要素のエンコーディングルールが適用される(当然のこと)
	- 入力長が無効

#### G2加算のABI

G2加算呼び出しでは、2つのG2点(`256バイトずつ`)のバイト連結である512バイトを入力として受け取ります。出力は加算操作の結果 - 単一のG2点(`256バイト`)のエンコーディングです。

エラーケース:
	- 点のいずれかが曲線上にない場合はエラーとなる
	- フィールド要素のエンコーディングルールが適用される(当然のこと)
	- 入力長が無効

#### G2乗算のABI

G2乗算呼び出しでは、G2点のエンコーディング(`256バイト`)とスカラー値のエンコーディング(`32バイト`)のバイト連結である288バイトを入力として受け取ります。出力は乗算操作の結果 - 単一のG2点(`256バイト`)のエンコーディングです。

エラーケース:
	- 点が曲線上にない場合はエラーとなる
	- フィールド要素のエンコーディングルールが適用される(当然のこと)
	- 入力長が無効

#### G2多重指数計算のABI

G2多重指数計算呼び出しでは、`k`個のスライスのバイト連結である`288*k`バイトを入力として受け取ります。各スライスは、G2点のエンコーディング(`256バイト`)とスカラー値のエンコーディング(`32バイト`)のバイト連結です。出力は多重指数計算操作の結果 - 単一のG2点(`256バイト`)のエンコーディングです。

エラーケース:
	- G2点のいずれかが曲線上にない場合はエラーとなる
	- フィールド要素のエンコーディングルールが適用される(当然のこと)
	- 入力長が無効

#### ペアリングのABI

ペアリング呼び出しでは、`k`個のスライスのバイト連結である`384*k`バイトを入力として受け取ります。各スライスは以下の構造になっています:
	- G1点のエンコーディ
ング(`128バイト`)
	- G2点のエンコーディング(`256バイト`)

出力は32バイトで、最初の31バイトは`0x00`、最後の1バイトは、ペアリング結果がペアリング対象体の乗法単位元と等しい場合は`0x01`、そうでない場合は`0x00`となります。

エラーケース:
	- 任意のブール変数のエンコーディングが無効な場合はエラーとなる
	- G1または G2 点のいずれかが曲線上にない場合はエラーとなる
	- G1または G2 点が正しい部分群にない
	- フィールド要素のエンコーディングルールが適用される(当然のこと)
	- 入力長が無効

#### Fp要素をG1点にマッピングするABI

フィールド・トゥ・カーブ呼び出しでは、基底体の要素を表す64バイトを入力として受け取ります。この呼び出しの出力は128バイトで、それぞれのエンコーディングルールに従ったG1点です。

エラーケース:
	- 入力長が無効
	- 入力が有効なフィールド要素ではない

#### Fp2要素をG2点にマッピングするABI

フィールド・トゥ・カーブ呼び出しでは、2次拡大体の要素を表す128バイトを入力として受け取ります。この呼び出しの出力は256バイトで、それぞれのエンコーディングルールに従ったG2点です。

エラーケース:
	- 入力長が無効
	- 入力が有効なフィールド要素ではない

### エラー処理によるDDoS攻撃の防止

このプリコンパイルは大規模な計算を行うため、エラー発生時にはガス代を全額消費しなければなりません。

### ガススケジュール

`30 MGas/second`を前提として、以下の価格を提案します。

#### G1加算

`600` gas

#### G1乗算

`12000` gas

#### G2加算

`4500` gas

#### G2乗算

`55000` gas

#### G1/G2多重指数計算

多重指数計算はPeppinger アルゴリズムを使って実行されることが期待されます(高速化のために、Peppinger アルゴリズムを使用しなければならないと言えます)。この場合、`k <= 128`の点の多重指数計算に対するディスカウントテーブルが用意されており、`k > 128`の場合の最大ディスカウント`max_discount`が定義されています。

非整数演算を避けるため、呼び出しコストは`k * 乗算コスト * ディスカウント / 乗数`として計算されます。ここで、`乗数 = 1000`、`k`は(スカラー、点)ペアの数、`乗算コスト`は対応するG1/G2の単一乗算呼び出しのコストです。

ディスカウントテーブル(ペアの vector `[k, ディスカウント]`):

```
[[1, 1200], [2, 888], [3, 764], [4, 641], [5, 594], [6, 547], [7, 500], [8, 453], [9, 438], [10, 423], [11, 408], [12, 394], [13, 379], [14, 364], [15, 349], [16, 334], [17, 330], [18, 326], [19, 322], [20, 318], [21, 314], [22, 310], [23, 306], [24, 302], [25, 298], [26, 294], [27, 289], [28, 285], [29, 281], [30, 277], [31, 273], [32, 269], [33, 268], [34, 266], [35, 265], [36, 263], [37, 262], [38, 260], [39, 259], [40, 257], [41, 256], [42, 254], [43, 253], [44, 251], [45, 250], [46, 248], [47, 247], [48, 245], [49, 244], [50, 242], [51, 241], [52, 239], [53, 238], [54, 236], [55, 235], [56, 233], [57, 232], [58, 231], [59, 229], [60, 228], [61, 226], [62, 225], [63, 223], [64, 222], [65, 221], [66, 220], [67, 219], [68, 219], [69, 218], [70, 217], [71, 216], [72, 216], [73, 215], [74, 214], [75, 213], [76, 213], [77, 212], [78, 211], [79, 211], [80, 210], [81, 209], [82, 208], [83, 208], [84, 207], [85, 206], [86, 205], [87, 205], [88, 204], [89, 203], [90, 202], [91, 202], [92, 201], [93, 200], [94, 199], [95, 199], [96, 198], [97, 197], [98, 196], [99, 196], [100, 195], [101, 194], [102, 193], [103, 193], [104, 192], [105, 191], [106, 191], [107, 190], [108, 189], [109, 188], [110, 188], [111, 187], [112, 186], [113, 185], [114, 185], [115, 184], [116, 183], [117, 182], [118, 182], [119, 181], [120, 180], [121, 179], [122, 179], [123, 178], [124, 177], [125, 176], [126, 176], [127, 175], [128, 174]]
```

`max_discount = 174`

#### ペアリング操作

ペアリング操作のコストは`55000*k + 65000`で、`k`はペアの数です。

#### Fp-to-G1マッピング操作

Fp -> G1マッピングは`5500` gasです。

#### Fp2-to-G2マッピング操作

Fp2 -> G2マッピングは`75000` gasです。

## 根拠

動機の節で、BLS12-377曲線上の演算を利用可能にする全体的な動機が説明されています。また、より具体的な詳細についての根拠も述べられています。

### 多重指数計算を別の呼び出しとして

明示的な多重指数計算の個別の呼び出しを設けることで、使用するアルゴリズム(具体的にはPeppingerアルゴリズム)と、Ethereumの`CALL`操作が高コストであるという事実(現時点で)によって、実行時間(ガス代)を節約できます。例えば100点の多重指数計算を行う場合、乗算プリコンパイルを100回、加算を99回呼び出す必要があるのに対し、この方式では約13.8600ガスを節約できます。

## 下位互換性

下位互換性の問題はありません。

### 重要な注意事項

#### 部分群チェック

ペアリング呼び出し時の部分群チェックは**必須**です。実装では高速な部分群チェックを使用すべきです: 現時点では乗算のガスコストは`double-and-add`乗算法に基づいていますが、これは最悪ケース(すべてのビットが1)が明確です。ペアリング操作では、ウィンドウサイズ4のwNAF乗算法など、より高速な部分群チェックを使用することが期待されます(約40%の節約になります。経験的に検証済み。部分群位数のハミング重みが低いことと、wNAFのハミング重みがさらに低いことによる節約。具体的には、ペアの両方のG1とG2点の部分群チェックが合計で約35000ガスになります)。

## テストケース

膨大なテストパラメータ空間のため、まず各操作が満たすべき性質を示します。点演算には加法記法を使い、点には大文字(`P`, `Q`)、スカラーには小文字(`a`, `b`)を使います。G1のジェネレータは`G`、G2のジェネレータは`H`、それ以外は曲線上のランダムな点とします。`0`はスカラーゼロまたは無限遠点、`1`はスカラー1または乗法単位元を意味します。`group_order`は主部分群の位数です。`e(P, Q)`はPがG1、QがG2の点のペアリング演算を表します。

基本演算(加算/乗算)に対する必須の性質:
	- 可換性: `P + Q = Q + P`
	- 加法逆元: `P + (-P) = 0`
	- 倍点: `P + P = 2*P` 
	- 部分群チェック: `group_order * P = 0`
	- 単位元乗算: `1 * P = P`
	- ゼロ乗算: `0 * P = 0`
	- 正規化されていないスカラーによる乗算: `(scalar + group_order) * P = scalar * P`

ペアリング演算に対する必須の性質:
	- 縮退性: `e(P, 0*Q) = e(0*P, Q) = 1`
	- 双線形性: `e(a*P, b*Q) = e(a*b*P, Q) = e(P, a*b*Q)`(内部テスト、ABIからは見えない)

すべての操作のテストベクトルは、matter-labsの提案1962で拡張されたCSVファイルに記載されています。

## 参考実装

ABI対応のために追加作業が必要かもしれませんが、以下の既存の曲線演算実装が利用可能です:
	- 固定パラメータのコードベース
	  - Rust: matter-labs
	  - C++: matter-labs
	- Zexe論文のオリジナル実装(Rust): github.com/scipr-lab/zexe
	- Go単体実装: github.com/kilic/bls12-377

## セキュリティ上の考慮事項

仕様を厳密に従えば、前のBN254プリコンパイルとは対照的に、セキュリティ上の影響や合意上の影響はありません。

重要なトピックは、実行された操作の"一定時間"特性です。このプリコンパイルは、すべての操作を一定時間アルゴリズムで実行する必要**はありません**。

## 著作権

著作権およびそれに関連する権利は[CC0](../LICENSE.md)で放棄されています。