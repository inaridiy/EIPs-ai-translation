---
original: 36a5f5d36fd745056e4df5014bfb286014570fe0202b7a21a5583445a3270808
---

---
eip: 4881
title: デポジットコントラクトスナップショットインターフェース
description: デポジットMerkleツリーのスナップショットを送信するためのフォーマットとエンドポイントを確立する
author: Mark Mackey (@ethDreamer)
discussions-to: https://ethereum-magicians.org/t/eip-4881-deposit-contract-snapshot-interface/8554
status: Final
type: Standards Track
category: Interface
created: 2021-01-29
---

## 概要

このEIPは、弱いサブジェクティビティ同期中にデポジットコントラクトのMerkleツリーを圧縮された形式で送信するための標準フォーマットを定義しています。これにより、新しく同期するコンセンサスクライアントは、すべての過去のデポジットをダウンロードするよりも迅速にデポジットツリーを再構築できます。提案されたフォーマットは、コンセンサスに完全に参加するために必要以上のデポジットを保持する必要がなくなるため、クライアントがデポジットをプルーニングできるようにもします(「デポジットの確定フロー」を参照)。

## 動機

ほとんどのクライアント実装では、デポジットMerkleツリーを再構築するためにベーコンノードがデポジットコントラクトの起動以来のすべてのデポジットログをダウンロードして保存する必要があります。しかし、このアプローチでは、コンセンサスに参加するために必要以上のデポジットをベーコンノードが保持する必要があります。さらに、これにより新しいノードの同期時間が長くなり、特に弱いサブジェクティビティ同期時に顕著になります。この単純なアプローチでは、完全ノードからの履歴コントラクトログのプルーニングを妨げるという問題もあり、これは状態の成長を制限する文脈でしばしば議論されています。

## 仕様

コンセンサスクライアントは、デポジットMerkleツリーをこれまでどおり実装し続けてもかまいません。ただし、新しく同期するノードにツリーを送信する際は、以下のフォーマットを使用しなければなりません:

```python
class DepositTreeSnapshot:
    finalized: List[Hash32, DEPOSIT_CONTRACT_DEPTH]
    deposit_root: Hash32
    deposit_count: uint64
    execution_block_hash: Hash32
    execution_block_height: uint64
```

ここで、`finalized`は「デポジットの確定フロー」セクションで定義されているハッシュの可変長リスト(最大サイズ`DEPOSIT_CONTRACT_DEPTH`)です。`deposit_root`、`deposit_count`、`execution_block_hash`フィールドは、スナップショットに対応する`Eth1Data`オブジェクトと同じ情報を保持し、`execution_block_height`はハッシュ`execution_block_hash`の実行ブロックの高さです。コンセンサスクライアントは、以下のBeaconノードAPIエンドポイントからこの構造体を利用可能にしなければなりません:

```
/eth/v1/beacon/deposit_snapshot
```

### デポジットの確定フロー

デポジット処理中、ベーコンチェーンはデポジットルートへのMerkleパスとともにデポジットを送信することを要求します。これは各デポジットについて1回だけ必要です。デポジットがベーコンチェーンによって処理され、[デポジットの確定条件](#デポジットの確定条件)が満たされると、ルートへのパスに沿った多くのハッシュがもはや必要なくなります。これらの不要なハッシュはスペースを節約するためにプルーニングできます。以下の図は、新しいデポジットが追加され、古いデポジットが確定されるにつれて、デポジットMerkleツリーとそれに対応する`DepositTreeSnapshot`がどのように変化するかを示しています:

![デポジットツリーの変遷](../assets/eip-4881/deposit_tree_evolution.svg)

## 根拠

この仕様のフォーマットは、以下の目的を同時に達成するために選択されました:

1. 完全ノードがすべての履歴コントラクトログを保存する必要なく、デポジットコントラクトのMerkleツリーを再構築できるようにする
2. コンセンサスノードがコンセンサスに完全に参加するために必要以上のデポジットを保持する必要がなくなるようにする
3. 実装の簡単さ(「リファレンス実装」セクションを参照)
4. 弱いサブジェクティビティ同期の高速化
5. 既存の実装との互換性(議論を参照)

提案された`DepositTreeSnapshot`構造体には、コンセンサスノードの実装者の利便性のために`execution_block_hash`と`execution_block_height`の両方が含まれています。これらのフィールドのどちらか一方だけが厳密に必要ですが、クライアントによってはブロックキャッシュのロジックをどちらかに基づいて設計している可能性があります。一方のフィールドだけを送信すると、コンセンサスクライアントが他方の情報を実行エンジンに問い合わせる必要が生じますが、これは新しく同期するコンセンサスノードの文脈で行われるため、特にマージ後は実行エンジンも同期していない可能性が非常に高いでしょう。`deposit_root`フィールドも厳密には必要ありませんが、これを含めることで、新しく同期するコンセンサスノードは受け取ったスナップショットを自身で検証できます(「リファレンス実装」セクションの`calculate_root()`メソッドを参照)。

### なぜデポジットコントラクトから直接ツリーを再構築しないのか?

デポジットコントラクトは、チェーンの先頭のツリーしか提供できません。ベーコンチェーンのデポジットコントラクトに対する見方は、`ETH1_FOLLOW_DISTANCE`だけ実行チェーンの後ろに遅れているため、まだチェーンに含まれていないデポジットのプルーフを構築するには、ツリーの以前のバージョンが必要になります。

### なぜベーコンチェーンのデポジットから直接ツリーを再構築しないのか?

原理的には、ノードは弱いサブジェクティビティチェックポイントから始まるチェーンを逆方向にスキャンして、適切な[`Deposit`](https://github.com/ethereum/consensus-specs/blob/2b45496fe48fa75450ad29a05bdd48866f86528a/specs/phase0/beacon-chain.md#deposit)を見つけ、そこからツリーの最右ブランチを抽出することができます。ノードはまた、対応する`BeaconState`の`Eth1Data`から`execution_block_hash`を抽出する必要があります。この方法には以下のような理由から好ましくない点があります:

* 適切なデポジットを見つける際のエッジケースに対処する必要があるため、実装が複雑になる
* これにより、デポジットツリーを再構築するためにはベーコンブロックの埋め戻しが必要になり、ブロック生成の要件にもなる
* 弱いサブジェクティビティチェックポイントからこの情報を取得するよりも遅い

## 下位互換性

この提案は完全に下位互換性があります。

## テストケース

テストケースは[test_cases.yaml](../assets/eip-4881/test_cases.yaml)に含まれています。各ケースは以下のように構成されています:

```python
class DepositTestCase:
    deposit_data: DepositData     # これらはすべてデポジットコントラクトのdeposit()関数への入力
    deposit_data_root: Hash32     # このデポジットのツリーハッシュルート(便宜上計算)
    eth1_data: Eth1Data           # このツリーを確定させるために使用できるEth1Dataオブジェクト
    block_height: uint64          # この Eth1Data の実行ブロックの高さ
    snapshot: DepositTreeSnapshot # このデポジットの後にツリーが確定された場合の結果のDepositTreeSnapshotオブジェクト
```

このEIPには他にも以下のファイルが含まれています:

* [deposit_snapshot.py](../assets/eip-4881/deposit_snapshot.py)には[リファレンス実装](#リファレンス実装)と同じコードが含まれています
* [eip_4881.py](../assets/eip-4881/eip_4881.py)にはボイラープレートの宣言が含まれています
* [test_deposit_snapshot.py](../assets/eip-4881/test_deposit_snapshot.py)にはリファレンス実装に対してテストケースを実行するためのコードが含まれています

これらのファイルを同じディレクトリにダウンロードすれば、そのディレクトリで`pytest`を実行してテストケースを実行できます。

## リファレンス実装

この実装は完全なエラーチェックを欠いており、効率性よりも可読性を重視しています。`tree`が`DepositTree`の場合、`tree.get_snapshot()`を呼び出して`DepositTreeSnapshot`を取得し、`DepositTree.from_snapshot()`を呼び出してツリーの新しいインスタンスを復元できます。[デポジットの確定条件](#デポジットの確定条件)セクションで説明されているように、ツリーを`tree.finalize()`を呼び出してプルーニングできます。

以前のツリーのバージョンに対するデポジットのプルーフを生成するのは、この実装では比較的高速です。`copy = DepositTree.from_snapshot(tree.get_snapshot())`でスナップショットからツリーのコピーを作成し、`copy.push_leaf(deposit)`で所望のカウントまでデポジットを追加すれば良いです。その後、`copy.get_proof(index)`でプルーフを取得できます。

```python
from __future__ import annotations
from typing import List, Optional, Tuple
from dataclasses import dataclass
from abc import ABC,abstractmethod
from eip_4881 import DEPOSIT_CONTRACT_DEPTH,Hash32,sha256,to_le_bytes,zerohashes

@dataclass
class DepositTreeSnapshot:
    finalized: List[Hash32, DEPOSIT_CONTRACT_DEPTH]
    deposit_root: Hash32
    deposit_count: uint64
    execution_block_hash: Hash32
    execution_block_height: uint64

    def calculate_root(self) -> Hash32:
        size = self.deposit_count
        index = len(self.finalized)
        root = zerohashes[0]
        for level in range(0, DEPOSIT_CONTRACT_DEPTH):
            if (size & 1) == 1:
                index -= 1
                root = sha256(self.finalized[index] + root)
            else:
                root = sha256(root + zerohashes[level])
            size >>= 1
        return sha256(root + to_le_bytes(self.deposit_count))
    def from_tree_parts(finalized: List[Hash32],
                        deposit_count: uint64,
                        execution_block: Tuple[Hash32, uint64]) -> DepositTreeSnapshot:
        snapshot = DepositTreeSnapshot(
            finalized, zerohashes[0], deposit_count, execution_block[0], execution_block[1])
        # 実際の実装では、DepositTree.finalize()で渡されたeth1_dataからdeposit_rootを保存する必要がある。
        # これにより、calculate_root()を使ってスナップショットを検証できる。
        snapshot.deposit_root = snapshot.calculate_root()
        return snapshot

@dataclass
class DepositTree:
    tree: MerkleTree
    mix_in_length: uint
    finalized_execution_block: Optional[Tuple[Hash32, uint64]]
    def new() -> DepositTree:
        merkle = MerkleTree.create([], DEPOSIT_CONTRACT_DEPTH)
        return DepositTree(merkle, 0, None)
    def get_snapshot(self) -> DepositTreeSnapshot:
        assert(self.finalized_execution_block is not None)
        finalized = []
        deposit_count = self.tree.get_finalized(finalized)
        return DepositTreeSnapshot.from_tree_parts(
            finalized, deposit_count, self.finalized_execution_block)
    def from_snapshot(snapshot: DepositTreeSnapshot) -> DepositTree:
        # スナップショットの妥当性チェック
        assert(snapshot.deposit_root == snapshot.calculate_root())
        finalized_execution_block = (snapshot.execution_block_hash, snapshot.execution_block_height)
        tree = MerkleTree.from_snapshot_parts(
            snapshot.finalized, snapshot.deposit_count, DEPOSIT_CONTRACT_DEPTH)
        return DepositTree(tree, snapshot.deposit_count, finalized_execution_block)
    def finalize(self, eth1_data: Eth1Data, execution_block_height: uint64):
        self.finalized_execution_block = (eth1_data.block_hash, execution_block_height)
        self.tree.finalize(eth1_data.deposit_count, DEPOSIT_CONTRACT_DEPTH)
    def get_proof(self, index: uint) -> Tuple[Hash32, List[Hash32]]:
        assert(self.mix_in_length > 0)
        # インデックスが確定済みのデポジットインデックスより大きいことを確認
        assert(index > self.tree.get_finalized([]) - 1)
        leaf, proof = self.tree.generate_proof(index, DEPOSIT_CONTRACT_
DEPTH)
        proof.append(to_le_bytes(self.mix_in_length))
        return leaf, proof
    def get_root(self) -> Hash32:
        return sha256(self.tree.get_root() + to_le_bytes(self.mix_in_length))
    def push_leaf(self, leaf: Hash32):
        self.mix_in_length += 1
        self.tree = self.tree.push_leaf(leaf, DEPOSIT_CONTRACT_DEPTH)

class MerkleTree():
    @abstractmethod
    def get_root(self) -> Hash32:
        pass
    @abstractmethod
    def is_full(self) -> bool:
        pass
    @abstractmethod
    def push_leaf(self, leaf: Hash32, level: uint) -> MerkleTree:
        pass
    @abstractmethod
    def finalize(self, deposits_to_finalize: uint, level: uint) -> MerkleTree:
        pass
    @abstractmethod
    def get_finalized(self, result: List[Hash32]) -> uint:
        # 確定済みのデポジット数を返し、結果にも確定済みのハッシュを入れる
        pass
    def create(leaves: List[Hash32], depth: uint) -> MerkleTree:
        if not(leaves):
            return Zero(depth)
        if not(depth):
            return Leaf(leaves[0])
        split = min(2**(depth - 1), len(leaves))
        left = MerkleTree.create(leaves[0:split], depth - 1)
        right = MerkleTree.create(leaves[split:], depth - 1)
        return Node(left, right)
    def from_snapshot_parts(finalized: List[Hash32], deposits: uint, level: uint) -> MerkleTree:
        if not(finalized) or not(deposits):
            # 空のツリー
            return Zero(level)
        if deposits == 2**level:
            return Finalized(deposits, finalized[0])
        left_subtree = 2**(level - 1)
        if deposits <= left_subtree:
            left = MerkleTree.from_snapshot_parts(finalized, deposits, level - 1)
            right = Zero(level - 1)
            return Node(left, right)
        else:
            left = Finalized(left_subtree, finalized[0])
            right = MerkleTree.from_snapshot_parts(finalized[1:], deposits - left_subtree, level - 1)
            return Node(left, right)
    def generate_proof(self, index: uint, depth: uint) -> Tuple[Hash32, List[Hash32]]:
        proof = []
        node = self
        while depth > 0:
            ith_bit = (index >> (depth - 1)) & 0x1
            if ith_bit == 1:
                proof.append(node.left.get_root())
                node = node.right
            else:
                proof.append(node.right.get_root())
                node = node.left
            depth -= 1
        proof.reverse()
        return node.get_root(), proof

@dataclass
class Finalized(MerkleTree):
    deposit_count: uint
    hash: Hash32
    def get_root(self) -> Hash32:
        return self.hash
    def is_full(self) -> bool:
        return True
    def finalize(self, deposits_to_finalize: uint, level: uint) -> MerkleTree:
        return self
    def get_finalized(self, result: List[Hash32]) -> uint:
        result.append(self.hash)
        return self.deposit_count

@dataclass
class Leaf(MerkleTree):
    hash: Hash32
    def get_root(self) -> Hash32:
        return self.hash
    def is_full(self) -> bool:
        return True
    def finalize(self, deposits_to_finalize: uint, level: uint) -> MerkleTree:
        return Finalized(1, self.hash)
    def get_finalized(self, result: List[Hash32]) -> uint:
        return 0

@dataclass
class Node(MerkleTree):
    left: MerkleTree
    right: MerkleTree
    def get_root(self) -> Hash32:
        return sha256(self.left.get_root() + self.right.get_root())
    def is_full(self) -> bool:
        return self.right.is_full()
    def push_leaf(self, leaf: Hash32, level: uint) -> MerkleTree:
        if not(self.left.is_full()):
            self.left = self.left.push_leaf(leaf, level - 1)
        else:
            self.right = self.right.push_leaf(leaf, level - 1)
        return self
    def finalize(self, deposits_to_finalize: uint, level: uint) -> MerkleTree:
        deposits = 2**level
        if deposits <= deposits_to_finalize:
            return Finalized(deposits, self.get_root())
        self.left = self.left.finalize(deposits_to_finalize, level - 1)
        if deposits_to_finalize > deposits / 2:
            remaining = deposits_to_finalize - deposits / 2
            self.right = self.right.finalize(remaining, level - 1)
        return self
    def get_finalized(self, result: List[Hash32]) -> uint:
        return self.left.get_finalized(result) + self.right.get_finalized(result)

@dataclass
class Zero(MerkleTree):
    n: uint64
    def get_root(self) -> Hash32:
        if self.n == DEPOSIT_CONTRACT_DEPTH:
            # 完全に空のツリーの場合を扱う。
            # 一貫性/明確性のために含めているが、
            # zerohashesの配列は通常DEPOSIT_CONTRACT_DEPTH - 1までしか定義されていない。
            return sha256(zerohashes[self.n - 1] + zerohashes[self.n - 1])
        return zerohashes[self.n]
    def is_full(self) -> bool:
        return False
    def push_leaf(self, leaf: Hash32, level: uint) -> MerkleTree:
        return MerkleTree.create([leaf], level)
    def get_finalized(self, result: List[Hash32]) -> uint:
        return 0
```

## セキュリティ上の考慮事項

### 弱いサブジェクティビティ同期への依存

PoSへの移行により、新しく同期したノードは長期攻撃に対抗するために有効な弱いサブジェクティビティチェックポイントに依存する必要があります。この提案は、クライアントが無効なWSチェックポイントでブートストラップしないという弱いサブジェクティビティの前提に依存しています。

### デポジットの確定条件

確定チェックポイントに完全に含まれていないデポジットを含むスナップショットを送信しないよう注意する必要があります。`state`を[`BeaconState`](https://github.com/ethereum/consensus-specs/blob/2b45496fe48fa75450ad29a05bdd48866f86528a/specs/phase0/beacon-chain.md#beaconstate)とします。通常の動作では、`state.eth1_data`に格納されている[`Eth1Data`](https://github.com/ethereum/consensus-specs/blob/2b45496fe48fa75450ad29a05bdd48866f86528a/specs/phase0/beacon-chain.md#eth1data)は`EPOCHS_PER_ETH1_VOTING_PERIOD`エポックごとに置き換えられます。したがって、デポジットツリーの確定は`state.eth1_data`の増分とともに進行します。`eth1data`を`Eth1Data`とします。`eth1data`を確定済みと見なすには、以下の2つの条件が満たされている必要があります:

1. 対応する`state`が`state.eth1_data == eth1data`である確定チェックポイントが存在すること
2. 対応する`state`が`state.eth1_deposit_index >= eth1data.deposit_count`である確定チェックポイントが存在すること

これらの条件が満たされると、[リファレンス実装](#リファレンス実装)でツリーを`tree.finalize(eth1data, execution_block_height)`を呼び出してプルーニングできます。

## 著作権

著作権およびそれに関連する権利は[CC0](../LICENSE.md)によって放棄されています。