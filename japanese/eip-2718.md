---
original: 876de14066ad67c9a1c0a87dc3bd18695325dcfc7d4b8326734de0bc174e4bf4
---

---
eip: 2718
title: 型付きトランザクション エンベロープ
description: 将来のトランザクション タイプのエンベロープとなる新しいトランザクション タイプを定義します。
author: Micah Zoltu (@MicahZoltu)
discussions-to: https://ethereum-magicians.org/t/eip-2718-typed-transaction-envelope/4355
status: 最終
type: 標準トラック
category: コア
created: 2020-06-13
---

## 概要
`TransactionType || TransactionPayload` は有効なトランザクションであり、`TransactionType || ReceiptPayload` は有効なトランザクション レシートです。ここで `TransactionType` はトランザクションの形式を識別し、`*Payload` はトランザクション/レシートの内容で、将来の EIP で定義されます。

## 動機
過去には、新しいトランザクション タイプを追加する際、すべての他のトランザクションとの下位互換性を確保する必要がありました。つまり、エンコードされたペイロードのみから区別できるようにする必要があり、両方のタイプに一致するトランザクションを持つことはできませんでした。
これは [EIP-155](./eip-155.md) で新しい値がビットパックされた1つのエンコードされたフィールドで見られました。
EOA アカウントがそのコンテキスト内で直接コードを実行できるようにするもの、`msg.sender` 以外が gas を支払えるようにするもの、レイヤー1 マルチシグ トランザクションに関連するものなど、新しいトランザクション タイプを定義する複数の提案が議論されています。
これらはすべて、相互に互換性のある方法で定義する必要があり、これは EIP 作成者とクライアントの両方にとって煩わしくなります。

エンベロープ トランザクション タイプを導入することで、既存のトランザクションとの下位互換性を確保するだけで済み、その後は `TransactionType` 間の番号の競合を解決するという簡単な問題を解決するだけで済みます。

## 仕様
### 定義
* `||` はバイト/バイト配列の連結演算子です。

### トランザクション
`FORK_BLOCK_NUMBER` 以降、ブロック ヘッダーのトランザクション ルートは `patriciaTrie(rlp(Index) => Transaction)` のルート ハッシュでなければなりません。ここで:
* `Index` はこのトランザクションのブロック内のインデックスです
* `Transaction` は `TransactionType || TransactionPayload` または `LegacyTransaction` のいずれかです
* `TransactionType` は `0` から `0x7f` の範囲の正の符号なし 8 ビット数で、トランザクションの種類を表します
* `TransactionPayload` は、`TransactionType` に依存し、将来の EIP で定義される不透明なバイト配列です
* `LegacyTransaction` は `rlp([nonce, gasPrice, gasLimit, to, value, data, v, r, s])` です

将来のすべてのトランザクション タイプの署名には、**SHOULD** 署名データの最初のバイトとして `TransactionType` を含める必要があります。
これにより、ある1つのトランザクション タイプの署名が別のトランザクション タイプで使用されるのを心配する必要がなくなります。

### レシート
`FORK_BLOCK_NUMBER` 以降、ブロック ヘッダーのレシート ルートは `patriciaTrie(rlp(Index) => Receipt)` のルート ハッシュでなければなりません。ここで:
* `Index` はこのレシートに対応するトランザクションのブロック内のインデックスです
* `Receipt` は `TransactionType || ReceiptPayload` または `LegacyReceipt` のいずれかです
* `TransactionType` は `0` から `0x7f` の範囲の正の符号なし 8 ビット数で、トランザクションの種類を表します
* `ReceiptPayload` は、`TransactionType` に依存し、将来の EIP で定義される不透明なバイト配列です
* `LegacyReceipt` は `rlp([status, cumulativeGasUsed, logsBloom, logs])` です

レシートの `TransactionType` は、一致する `Index` のトランザクションの `TransactionType` と一致しなければなりません。

## 根拠
### TransactionType は 0x7f まで
当面の間、0x7f で十分であり、範囲を拡張するためのオプションが多数残されています。たとえば、最上位ビットを継続ビットとして使用するなどです。
これにより、レガシー トランザクション タイプとの競合を防ぐこともできます。レガシー トランザクション タイプは常に `>= 0xc0` のバイトで始まります。
### 署名データの最初のバイトとして TransactionType を使用する **SHOULD** 代わりに **MUST**
将来のすべてのトランザクションで最初のバイトに `TransactionType` を含めることを強く推奨しますが、常に可能とは限りません。
これが不可能な例としては、レガシー署名スキームと互換性のあるラップされたレガシー トランザクションがあります。
また、トランザクションに従来の意味での署名がなく、有効性を判断するメカニズムが別にある場合もあります。
### TransactionType 選択アルゴリズム
`TransactionType` 識別子の割り当て/選択アルゴリズムを本規格で定義することについて議論がありました。
割り当てのための標準化されたメカニズムがあると便利ですが、本規格の作成時点では強い需要がないため、範囲外とみなされました。
必要と判断された場合、将来の EIP でTransactionType 識別子の割り当てに関する標準が導入される可能性があります。
### 不透明なバイト配列ではなく RLP 配列
トランザクション ペイロードの第2バイトを不透明なバイトではなく RLP (または他のエンコーディング) リストにすると、将来的に SSZ、LEB128、または固定幅フォーマットなど、異なるエンコーディング形式をサポートできます。
### ORIGIN と CALLER
トランザクション タイプごとに ORIGIN と CALLER オペコードの動作を定義することについて議論がありました。
ただし、コントラクトがトランザクション タイプを区別することを避けたいという要望があります。
また、ORIGIN と CALLER オペコードに関する既存のコントラクトの前提条件との下位互換性の懸念もありました。
今後は、すべてのトランザクション タイプで最初の EVM フレームの `CALLER` を合理的に表すアドレスがあり、`ORIGIN` もすべての場合で同じアドレスであると想定します。
トランザクション タイプが追加の情報をコントラクトに提供する必要がある場合は、新しいオペコードを使用する必要があります。

## 下位互換性
クライアントは、最初のバイトを見ることで、レガシー トランザクションと型付きトランザクションを区別できます。
値が `[0, 0x7f]` の範囲にある場合は新しいトランザクション タイプ、`[0xc0, 0xfe]` の範囲にある場合はレガシー トランザクション タイプです。
`0xff` は RLP でエンコードされたトランザクションとしては現実的ではないため、将来の拡張用のセンチネル値として予約されています。

## セキュリティ上の考慮事項
新しい 2718 トランザクション タイプを設計する際は、**STRONGLY** 署名ペイロードの最初のバイトにトランザクション タイプを含めることをお勧めします。これを行わないと、別のタイプのトランザクションと署名が互換になる可能性があり、ユーザーのセキュリティ上の脆弱性につながる可能性があります。

## 著作権
[CC0](../LICENSE.md) によりすべての著作権およびそれに関連する権利が放棄されています。