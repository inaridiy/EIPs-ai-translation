---
original: 3d4be310652300811c9099ee903222bb93ea03ce813e614e6d33e9023684ecc6
---

---
eip: 1884
title: トライサイズ依存オペコードの再価格付け
author: Martin Holst Swende (@holiman)
type: Standards Track
category: Core
discussions-to: https://ethereum-magicians.org/t/opcode-repricing/3024
status: Final
created: 2019-03-28
requires: 150, 1052
---


## 簡単な要約

このEIPは、ガス支出と資源消費の良いバランスを得るために、特定のオペコードの再価格付けを提案しています。

## 概要

Ethereumの状態の成長により、特定のオペコードがこれまでよりもリソース集約的になっています。このEIPは、これらのオペコードのガスコストを引き上げることを提案しています。

## 動機

操作の価格と資源消費(CPU時間、メモリなど)の間のアンバランスには、いくつかの欠点があります:

- 過小評価されたオペレーションで満たされたブロックを使って攻撃に使われる可能性があります。これにより、ブロック処理時間が過剰になります。
- 過小評価されたオペコードにより、ブロックガスリミットが歪められ、時にはブロックが素早く完了しますが、同様のガス使用量のブロックでは遅くなります。

操作のバランスが取れていれば、ブロックガスリミットを最大化し、処理時間をより安定させることができます。

## 仕様

ブロック `N` において、

- `SLOAD` (`0x54`) オペレーションは `200` から `800` ガスに変更されます。
- `BALANCE` (`0x31`) オペレーションは `400` から `700` ガスに変更されます。
- `EXTCODEHASH` (`0x3F`) オペレーションは `400` から `700` ガスに変更されます。
- 新しいオペコード `SELFBALANCE` が `0x47` で導入されます。
  - `SELFBALANCE` はスタックから `0` 個の引数をポップします。
  - `SELFBALANCE` は現在のアドレスの `balance` をスタックにプッシュします。
  - `SELFBALANCE` は `GasFastStep` で価格付けされ、`5` ガスです。

## 根拠

Gethを使ったフルシンクから得られた2つのグラフを以下に示します。5M~6Mブロックと6M~7Mブロックの範囲で、各オペコードの実行時間を集計し、上位25個の「重い」オペコードを示しています:

![bars1](../assets/eip-1884/run3.total-bars-5.png) 
![bars2](../assets/eip-1884/run3.total-bars-6.png) 

注: `SLOAD` が上位に移動していることがわかります。`GASPRICE` (`0x3a`) オペコードが1位ですが、これはクライアント内で最適化できると考えられます。一方、`SLOAD`/`BALANCE`はそうではありません。

また、Gethによるフルシンクの結果を示すグラフがこちらです。ブロック `0` から `5.7M` までのものですが、ブロック処理時間がどのように使われているかを示しています。

![geth](../assets/eip-1884/geth_processing.png)

`storage_reads` と `account_reads` が、ブロック処理時間に最も大きく寄与していることがわかります。

### `SLOAD`

`SLOAD` は[EIP-150][eip-150]で `50` から `200` に再価格付けされました。
以下のグラフは、go-ethereumのフルシンクを示しており、各データポイントは10Kブロックを表しています。その10Kブロックの間に、オペコードの実行時間が集計されています。

![graph](../assets/eip-1884/SLOAD-run3.png)

[EIP-150][eip-150]での再価格付けにより、約 `67` から `23` に急激に下がったことがわかります。
ブロック `5M` 付近から、[EIP-150][eip-150]以前のレベルに戻り始め、ブロック `7M` では平均して `150` 前後 - [EIP-150][eip-150]以前の2倍以上 - になっています。

`SLOAD` のコストを `4` 倍に引き上げると、約 `40` まで下がると考えられます。
ただし、状態クリアの取り組みが行われない限り、将来的にまた上昇していくことが予想されます。

### `BALANCE` 

`BALANCE` (別名 `EXTBALANCE`) は、状態トライからデータを取得するオペレーションです。[EIP-150][eip-150]で `20` から `400` に再価格付けされました。

![graph](../assets/eip-1884/BALANCE-run3.png)

`EXTCODESIZE` や `EXTCODEHASH` と同等で、これらは既に `700` ガスに設定されています。

`BALANCE` には内在的な高い変動性があります。なぜなら、`this` のバランスをチェックするのは本質的に安価な操作ですが、任意のアカウントのバランスを調べるには、しばしばトライ(ディスク)アクセスが必要になるためです。

ひょっとすると、`EXTBALANCE(address)` と `SELFBALANCE` の2つのオペコードを用意し、それぞれ別の価格を設定するのが良かったかもしれません。

* このEIPは、現在のオペコードセットを拡張することを提案しています。
  * 残念ながら、`0x3X` オペコードの範囲はすでに埋まっているため、`SELFBALANCE` を `0x4X` 範囲に置くことを提案しています。
  * `5` (`GasFastStep`) ではなく `2` (`GasQuickStep`) で価格付けされていない理由は、EVM実行エンジンがまだ(キャッシュされた)トライへのルックアップを必要とし、`balance` は `gasPrice` や `timeStamp` のように実行中に一定ではないため、少し多くの固有のオーバーヘッドがあるためです。

### `EXTCODEHASH`

`EXTCODEHASH` は Constantinople で[EIP-1052](./eip-1052.md)で導入されました。その際の価格付けの理由は以下の通りです:

> ガスコストは `BALANCE` オペコードと同じ400ガスです。なぜなら、`EXTCODEHASH` の実行には `BALANCE` と同じアカウントルックアップが必要だからです。

したがって、`BALANCE` を引き上げる場合は、`EXTCODEHASH` も引き上げるべきです。

## 下位互換性

これらの変更にはハードフォークが必要です。変更には以下のような影響があります:

- 特定の呼び出しがより高価になります。
- デフォルト関数がストレージにアクセスし、場合によっては `2300` ガス(常に利用可能な最小ガス)を超える可能性があります。
- 呼び出し(または内部セクション)の固定ガスコストを前提としている契約が機能しなくなる可能性があります。
  - 固定ガスコストは[ERC-165](./eip-165.md)で指定されており、このインターフェイスの実装では影響を受けるオペコードが使用されています。
    - ERC-165メソッド `supportsInterface` は `bool` を返し、最大 `30,000` ガスを使用する必要があります。
    - 当時の2つの例示実装は、
      1. 入力に関わらず `586` ガス、
      2. `236` ガスでしたが、サポートするインターフェイスの数が増えると線形に増加します。
  - `supportsInterface` の実装が `30,000` ガスを超えることはまずないでしょう。そうなるには、2番目のバリアントが使用され、30個ほどのインターフェイスがサポートされる必要があります。
  - ただし、これらの操作は以前にも再価格付けされているので、「これらのオペレーションのガスコストは変更される可能性がある」ということは、固定ガスコストを前提とした実装を防ぐはずでした。

これらの変更により、同じオペコードを複数のモディファイアで `SLOAD` するようなパターンが使われなくなるでしょう。また、厳密に必要ではない `SLOAD` された値を含む `log` 操作も減少すると考えられます。

## テストケース

実装すべきテストケース:
- `selfbalance == balance(address)` であることのテスト
- `balance(this)` のコストが以前と同じであることのテスト
- `selfbalance` がスタックからポップしないことのテスト
- `SLOAD`、`EXTCODEHASH`、`SELFBALANCE` のガスコストの検証
- `SELFBALANCE` がIstanbul以前に無効であることの検証

一部のテストケースは、https://github.com/holiman/IstanbulTests/tree/master/GeneralStateTests にある状態テストとして実装されています。

## 実装

このEIPはまだどのクライアントにも実装されていません。
これらのオペコードは以前にも再価格付けされており、再価格付けを管理するクライアントの内部機能は既に用意されています。

### `SELFBALANCE`

go-ethereumにおける新しいオペコードの実装は以下の通りです:

```golang

func opSelfBalance(pc *uint64, interpreter *EVMInterpreter, contract *Contract, memory *Memory, stack *Stack) ([]byte, error) {
	stack.push(interpreter.intPool.get().Set(interpreter.evm.StateDB.GetBalance(contract.Address())
	return nil, nil
}

```

## セキュリティ上の考慮事項

- 下位互換性の項を参照してください。
- `SELFBALANCE` には特別なエッジケースはありません。`BALANCE` で `address` をスタックからポップするのではなく、現在のアドレスの `balance` を返すように定義すれば、`BALANCE` はすでに適切に定義されているためです。
- Solidityに、これらのオペレーションのガスコストに関する固定の期待値が含まれていないかを調査する必要があります。
- 多くの場合、`CALL` から `ether` を受け取った受取人は `LOG` を発行したいと思います。`LOG` オペレーションのコストは `375` + トピック1つあたり `375` ガスです。`LOG` が `SLOAD` も行う場合、この変更により一部の送金が失敗する可能性があります。

## 著作権
著作権およびそれに関連する権利は[CC0](../LICENSE.md)で放棄されています。

[eip-150]: ./eip-150.md