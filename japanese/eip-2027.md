---
original: c3e40681fb97777e2c89b3b3c3cd421d5d343e6f77e32c7ca1d7c688f705c81f
---

---
eip: 2027
title: State Rent C - ネットコントラクトサイズアカウンティング
author: Alexey Akhunov (@AlexeyAkhunov)
discussions-to: https://ethereum-magicians.org/t/eip-2027-net-contract-size-accounting-change-c-from-state-rent-v3-proposal/3275
status: 停滞
type: Standards Track
category: Core
created: 2019-05-14
---

## 簡単な要約
Ethereumは、コントラクトに満たされたストレージスロットの数と空になったストレージスロットの数を数え始めます。現在、既存のスロットの数はアカウントされていないため、実質的にスロットの純変化量のみが追跡されています。その後の変更である*グロスコントラクトサイズアカウンティング*では、ストレージスロットの総数の追跡が開始されます。

## 概要
これはState Rentロードマップの一部です。この特定の変更では、コントラクトストレージスロットの数の初期的な純アカウンティングを導入します。単独では非常に有用ではありませんが、ストレージスロットの総数のグロスアカウンティングを導入することができます。これは以下のようなことに役立ちます:
1. `SLOAD`および`SSTORE`などの操作のガスコストを増加させる必要があり、ブロックの証明に消費される余分な帯域幅を補償する必要があります。初めは固定コストになりますが、後に自動的に調整されるようになります。
2. *高速同期*、*ワープ同期*、*ファイアホース*、*レッドクイーン*などのスナップショット同期プロトコルは、状態内のコントラクトストレージのサイズを正しく把握できるようになり(したがってMerkleプルーフを介して証明可能になり)、恩恵を受けます。

## 動機
Ethereumは現在、コントラクトストレージスロットの数を全く追跡していません。ダウンロードした状態からそのような数を生成することは、定数時間*O(1)*では行えません。

## 仕様
各コントラクト(アカウントの`codeHash`フィールドが0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470(空のコードのハッシュ)ではない)に、新しいuint64フィールド`storagesize`が追加されます。ブロック`C`以降、`SSTORE`(`location`, `value`)操作のセマンティクスは次のように変更されます:
- 前の値が0で、新しい値が0以外の場合は、`storagesize`を*インクリメント*する(インクリメントのセマンティクスは以下を参照)
- 前の値が0以外で、新しい値が0の場合は、`storagesize`を*デクリメント*する(デクリメントのセマンティクスは以下を参照)
- 他の状態変更と同様に、`storagesize`の変更は実行フレームが巻き戻されると元に戻される。つまり、ストレージ値と同様の手法(Gethのジャーナリング、Parityのサブステート)を使用する必要がある。
`storagesize`の値は、この時点ではコントラクトから観察できません。

### *インクリメント* `storagesize`のセマンティクス
`storagesize`が存在しない場合、`storagesize` = `HUGE_NUMBER` + 1。
`storagesize`が存在する場合、`storagesize` = `storagesize` + 1。

### *デクリメント* `storagesize`のセマンティクス
`storagesize`が存在しない場合、`storagesize` = `HUGE_NUMBER` - 1。
`storagesize`が存在する場合、`storagesize` = `storagesize` - 1。

### `HUGE_NUMBER`について
`HUGE_NUMBER`という定数があります。これは、実際のメトリック(コントラクトストレージサイズ、アカウントの数、コントラクトの数、コードの総サイズ、ストレージの総サイズ)がこの数に到達することがないほど大きく、64ビットの符号なし整数に収まるほど小さい必要があります。
現在の提案は、`HUGE_NUMBER` = 2^63とすることです。これは64ビットの数値の中で1つのビットが立っているバイナリ表現になります。

この目的は、ストレージサイズがインクリメント/デクリメントされたかどうか(フィールドの存在)、およびネットからグロスに変換されたかどうか(値が`HUGE_NUMBER/2`未満であるため、ブロック`C`時点でいかなるコントラクトも2^62を超えることはできない)を後で判断できるようにすることです。

## 根拠
コントラクトストレージサイズの推定メカニズムが[ここ](https://medium.com/@akhounov/estimation-approximate-of-the-size-of-contracst-in-ethereum-4642fe92d6fe)で提案されています。しかし、コンセンサスに複雑さ(推定アルゴリズム、さまざまなサイズのストレージに対応するためのエッジケースが多数)を導入するという大きな欠点があります。

## 下位互換性
この変更は下位互換性がなく、ハードフォークを行って有効化する必要があります。新しく導入されたフィールドは観察可能ではないため、この変更は既存のスマートコントラクトの操作に影響を与えません。

## テストケース
テストケースは参照実装から生成されます。

## 実装
仕様を洗練および明確化するためのプルーフオブコンセプト実装が行われます。

## 著作権
著作権およびそれに関連する権利は[CC0](../LICENSE.md)で放棄されています。