---
original: 4d601dfd6f0b7a855cce5b3324afe62b047834504b38ba193d368bc4c710aa01
---

---
eip: 1571
title: EthereumStratum/2.0.0
author: Andrea Lanfranchi (@AndreaLanfranchi), Pawel Bylica (@chfast), Marius Van Der Wijden (@MariusVanDerWijden)
discussions-to: https://github.com/AndreaLanfranchi/EthereumStratum-2.0.0/issues
status: Stagnant
type: Standards Track
category: Interface
created: 2018-11-09
---

## 概要
このドラフトには、Ethereumマイナーがマイニングプールサーバーと通信するための新しい標準Stratumプロトコルを定義するためのガイドラインが含まれています。

### 規約
この文書の中の `MUST`、`MUST NOT`、`REQUIRED`、`SHALL`、`SHALL NOT`、`SHOULD`、`SHOULD NOT`、`RECOMMENDED`、`MAY`、および `OPTIONAL` というキーワードは、[RFC 2119](https://tools.ietf.org/html/rfc2119)で説明されているように解釈されるものとします。
`マイニングプールサーバー`および複数形の定義は、`ワークプロバイダー`と解釈され、この文書の後半では `プール`または `サーバー`と省略されます。
`マイナー`および複数形の定義は、`ワークレシーバー/プロセッサー`と解釈され、この文書の後半では `マイナー`または `クライアント`と省略されます。

### 根拠
Ethereumには公式のStratumの実装がまだありません。公式にはgetWorkのみをサポートしており、これはマイナーが常にワークプロバイダーをプールする必要があります。最近になってgo-ethereumが[プッシュメカニズム](https://github.com/ethereum/go-ethereum/pull/17347)を実装して、クライアントにマイニングワークを通知するようになりましたが、大多数のマイナーがノードを実行していないため、その主な目的はマイニングプールを容易にすることです。
一方、Stratumプロトコルは、2方向の行ベースのメッセージの交換を可能にする標準的な状態保持TCPコネクションに依存しています。各行には、[JSON-RPC 1.0](https://www.jsonrpc.org/specification_v1)または[JSON-RPC 2.0](https://www.jsonrpc.org/specification)のルールに従ったJSON オブジェクトの文字列表現が含まれています。
残念ながら、明確な標準がないため、さまざまなバリエーションのStratumがEthereumマイニングのために派生して登場しています。唯一の標準化の試みは、NiceHashによる[EthereumStratum/1.0.0](https://github.com/nicehash/Specifications/blob/master/EthereumStratum_NiceHash_v1.0.0.txt)の実装でした。この作品はその主な源泉です。
マイニング活動、つまりプールとマイナーの間の相互作用は基本的に非常に単純で、「_入力としてこのデータに結合されたある数(ノンス)を見つけ、その出力が一定のターゲットを下回る_」と要約できます。セッション中に交換される可能性のある他のメッセージは、この基本的な概念をサポートするために必要です。
この主題の単純さのため、提案者は、[Google のProtocol Buffers](https://developers.google.com/protocol-buffers/docs/overview)のような冗長な解決策を調査するよりも、JSON形式のオブジェクトにとどまることにしました。

### Stratumの設計上の欠陥
Stratumの主な設計上の欠陥は、明確な標準の欠如です。これは、マイナー(およびマイニングソフトウェア開発者)が異なるバリエーションに苦労しなければならず、1つのプールから別のプールに切り替えたり、単一のプールが実装しているフレーバーを「推測」したりするのが難しいことを意味します。さらに、すべての実装はまだ、Ethereumのようなブロック時間が非常に短いチェーンでは過度の冗長性に悩まされています。いくつかの数字を見ると理解できます。通常の `mining.notify` メッセージは約 240 バイトの重さがあります。1ブロックあたり 1 つのワークを 50,000 台の接続された TCP ソケットに配信すると、1 か月で約 1.88 TB のデータが送信されることになります。これは大規模なプールにとって問題となる可能性があります。しかし、同じ数字を逆の方向から見ると、マイナーの観点から、インターネット接続の品質がマイニングの分散化に大きな影響を及ぼすことがよくわかります。

### 着想源
- [NiceHash EthereumStratum/1.0.0](https://github.com/nicehash/Specifications/blob/master/EthereumStratum_NiceHash_v1.0.0.txt)
- [ZcashバージョンのStratumプロトコル](https://github.com/zcash/zips/blob/23d74b0373c824dd51c7854c0e3ea22489ba1b76/drafts/str4d-stratum/draft1.rst#json-rpc-1-0)

## 仕様
Stratumプロトコルは[JSON-RPC-2.0](https://www.jsonrpc.org/specification)のインスタンスです。マイナーはJSON-RPCクライアント、サーバーはJSON-RPCサーバーです。すべての通信は `セッション`の範囲内で行われます。セッションは、クライアントがサーバーにTCPコネクションを開いた時点から、どちらかの当事者が自発的にその同じコネクションを閉じるか、それが切断されるまで続きます。サーバーは、最初のセッション ハンドシェイクで交渉された場合、セッションの再開をサポートする **かもしれません**。セッション中、サーバーとクライアントの間で交換されるすべてのメッセージは行ベースであり、つまりすべてのメッセージがASCII LF文字(この文書では `\n` と表記される)で終了するJSON文字列です。LF文字は **MUST NOT** メッセージ内の他の場所に現れます。クライアントとサーバーの実装 **MUST** LF文字を読み取ったら、現在のメッセージが完全に受信され、処理できると想定する。
ラインメッセージには3つのタイプがあります:
- `リクエスト`: 発行者が応答を期待するメッセージ。受信者は **MUST** 個別にリクエストに応答する
- `レスポンス`: 前のリクエストによって要求されたメッセージ。応答者 **MUST** 元のリクエストと同じ識別子でレスポンスにラベル付けする
- `通知`: 発行者が応答を求めていない unsolicited メッセージ。ただし、受信者が (例えば確認応答) 応答を送信する **かもしれません**

`セッション`中、両当事者は上記の3つのタイプのメッセージを交換する **ことができます**。

### JSON-RPC-2.0 の準拠

[JSON-RPC-2.0](https://www.jsonrpc.org/specification)の仕様に従い、リクエストとレスポンスは JSON オブジェクトの `id` メンバーによって通知と区別されます:
- リクエストには `id` メンバーが **MUST** ある
- レスポンスには、このレスポンスが対応するリクエストの `id` メンバーと正確に同じ値の `id` メンバーが **MUST** ある
- 通知には `id` メンバーが **MUST NOT** ある

### JSON-RPC-2.0 からの逸脱

当事者間のセッション/会話で最も簡潔なメッセージを得るために、この実装は以下の逸脱を強制します:
- `jsonrpc` JSON メンバー (常に "2.0" の値) **MUST ALWAYS BE OMITTED**
- `id` JSON メンバーは **MUST NOT** `null` である。メンバーが存在する場合は、必須でリクエストとレスポンスでなければならず、0 から 65535 の範囲の整数番号でなければなりません。`"id": 0` のメッセージは **MUST NOT** 通知として解釈される: これは識別子 0 のリクエストです
- `id` JSON メンバーは **MUST** プリミティブ番号のみのタイプでなければならない。他の識別子タイプ (文字列など) の削除は、転送バイト数を減らす必要があるためです。

## 規約
- JSON オブジェクトの表現は、基本的には文字列です
- クライアントとサーバーの会話は文字列で構成されます。各文字列の末尾にLF (ASCII文字 10) があるものが `ライン`を表します。各ラインには **MUST** 1つのJSONルートオブジェクトのみが含まれています。最終的にルートオブジェクトには、そのメンバーにさらにJSONオブジェクトが含まれる **かもしれません**
- `LF`区切り文字以外に、各 `ライン` **MUST** 印刷可能なASCII文字の範囲 32..126 のみで構成されている
- 各ラインメッセージは、適切にフォーマットされたJSONオブジェクトに対応することが暗黙的かつ必須です: [JSON documentation](https://www.json.org/)を参照
- JSONオブジェクトは、文字列/数値のプリミティブ、JSONオブジェクト、JSONの配列などのタイプのメンバーで構成されています
- JSON `メンバー`の名前は、ASCII範囲 48..57 (数字) と 97..122 (小文字) の印刷可能な文字のみで構成されている文字列でなければなりません
- JSON `メンバー`の名前は **MUST NOT** 数字で始まる
- JSON値 `配列`: JSONの表記法では、同じ配列内に異なるデータ型を挿入することができますが、一般にプログラミング言語ではこの動作は受け入れられません。このため、EthereumStratum/2.0.0 の手段により、すべての実装者は、配列が同じデータ型の要素で構成されていると想定しなければなりません
- JSON値 `ブール値`: JSONの表記法では、ブール値を `true` または `false` として表現できます。EthereumStratum/2.0.0 では、配列内での互換性を向上させるため、ブール値は "0" (false) または "1" (true) の16進形式で表現されます
- JSON値 `文字列`: 任意の文字列値は **MUST** ASCII範囲 32..126 の印刷可能な文字のみで構成されている。各文字列は、開始と終了に `"` (ASCII 34) で囲まれています。文字列値に `"` が含まれる場合は、`\"` とエスケープする必要があります
- 16進値: 数値の16進表現は実際には文字列データ型です。規約として、そして送信バイト数を減らすために、接頭辞 "0x" **MUST** 常に省略されます。さらに、任意の16進数 **MUST** 重要な部分のみ転送される (つまり、先行するゼロは省略される) (例: 10進数 `456` は `"1c8"` と表現され、`"01c8"` ではありません)。ただし、ハッシュとextranoncesには適用されません
- 16進値の大文字/小文字: 16進値のすべての文字は **MUST** 小文字でなければなりません (例: 10進数 `456` は `"1c8"` と表現され、`"1C8"` ではありません)。ただし、ハッシュには適用されません

### リクエスト
`リクエスト`オブジェクトのJSON表現は、以下の部分で構成されています:
- 必須の `id` メンバー (整数型): 発行者が設定した識別子
- 必須の `method` メンバー (文字列型): 受信者側で呼び出すメソッドの名前
- オプションの `params` メンバー: メソッドの呼び出しに追加のパラメーターが必要な場合。タイプは **かもしれない** オブジェクト (異なるタイプの名前付きメンバー) または単一タイプの配列。配列の場合、パラメーターは順序位置によって適用されます。受信側のメソッド呼び出しに追加のパラメーターが必要ない場合、このメンバーは **MUST NOT** 存在する。 `"params" : null` の表記 **IS NOT PERMITTED**

### レスポンス
`レスポンス`オブジェクトのJSON表現は、以下の部分で構成されています:
- 必須の `id` メンバー (整数型): このレスポンスが対応するリクエストの識別子
- オプションの `error` メンバー: メソッドの解析中またはその実行中にエラーが発生した場合、このメンバーは **MUST** 存在し、値が設定されている。エラーが発生しなかった場合、このメンバーは **MUST NOT** 存在する。`error` メンバーの
詳細な構造については、以下を参照してください。
- オプションの `result` メンバー: 対応するリクエストが結果を要求する場合、これを設定する必要があります。エラーが発生しなかった場合、このメンバーは **MUST** 存在する (ただし、データがnullの場合もある)。タイプはオブジェクトまたは単一タイプの配列やプリミティブ文字列/数値になる **かもしれない**。データを返す必要がない (受信者側のメソッドがvoid) またはエラーが発生した場合、このメンバーは **MUST NOT** 存在する。

標準のJSON-RPC-2.0とはいくつかの違いがあることに気づくでしょう。特に、結果メンバーは常に必要ではありません。基本的に、このようなレスポンスです:
```json
{"id": 2}
```
これは「リクエストを正常に受信して処理しましたが、返すデータはありません」を意味します。

概念をより明確にし、自由な解釈の余地を排除するために、別の**誤ったレスポンス**の例を見てみましょう。
```json
{"id": 2, "result": false}
```
このレスポンスの構文では、多くの解釈の余地が残されています。エラーですか? `false` は発行されたリクエストの正当な応答値ですか?

このため、レスポンスは2つのタイプのいずれかでなければなりません:
- 成功レスポンス: 処理中にエラーは発生せず、リクエストは有効で構文的に正しく、受信者は問題なく処理できました。このタイプのレスポンスには `error` メンバーが **MUST NOT** 存在し、発行者に値を返す必要がある場合は `result` メンバーが **かもしれない**。
- 失敗レスポンス: リクエストに何か問題があり、構文、有効範囲、またはサーバー処理の問題があります。このタイプのレスポンスには `error` メンバーが **MUST** 存在し、`result` メンバーが **かもしれない**。

後者についてもう少し説明が必要です。失敗レスポンスは重大度によって区別できます。
例1: クライアントがソリューションを送信し、サーバーがターゲットを下回っていないため拒否します。サーバーは以下のように応答する **MUST**:
```json
{
  "id": 31,
  "error": {
      "code": 406,
      "message" : "Bad nonce"
  }
}
```
例2: クライアントがソリューションを送信し、サーバーが **受け入れる** が、それをスタールとしてカウントします。サーバーは以下のように応答する **MUST**:
```json
{
  "id": 31,
  "error": {
      "code": 202,
      "message" : "Stale"
  }
}
```
例3: クライアントが無効なワーカー名を指定して認証リクエストを送信します。サーバーはアカウントを承認しますが、ワーカー名を拒否します。サーバーは以下のように応答する **MUST**:
```json
{
  "id": 1,
  "error": {
      "code": 215,
      "message" : "Invalid Worker Name"
  }
}
```

例1は深刻な障害の状態を示しており、例2と3は、クライアントが期待する結果ではないが、リクエストが正常に受け入れられ処理された状況を示しています。
クライアントはエラーの重大度を評価し、続行するかどうかを決める必要があります。

適切なエラーコードを使用することで、プールはマイナーにリクエストの状態を適切に通知できます。エラーコードは以下のスキームに従う **MUST**:

- エラーコード 2xx: リクエストは受け入れられ処理されましたが、`error` メンバーにヒントが含まれる可能性があります
- エラーコード 3xx: クライアントの認証不足により、サーバーはリクエストを処理できませんでした
- エラーコード 4xx: サーバーはメソッドが見つからない、パラメーターが不足している、データ型が間違っているなどの構文的な問題により、リクエストを処理できませんでした
- エラーコード 5xx: サーバーは内部エラーにより、リクエストを処理できませんでした

### 通知
通知メッセージは `リクエスト`と同じ表現を持ちますが、`id` メンバーが **MUST NOT** 存在する点が異なります。つまり、発行者は応答を求めておらず、期待していません。受信者は適切に対応する必要があります。例えば、受信者は **かもしれない** メソッドを実行するか、エラーや許可されていないメソッドの場合は接続を切断してセッションを閉じる **かもしれない**。

#### errorメンバー
上述のように、`レスポンス`に `error` メンバーが含まれる **かもしれない**。存在する場合、このメンバーは以下のオブジェクトでなければなりません:
- 必須メンバー `code`: 発生したエラーを識別する番号
- 必須メンバー `message`: 発生したエラーを説明する簡単な人間可読の文章
- オプションメンバー `data`: エラーに関する追加情報を含む構造化または基本的な値。このメンバーの値はサーバーによって定義されます (例: 詳細なエラー情報、ネストされたエラーなど)。

## プロトコルフロー
- クライアントがセッションを開始するためにサーバーにTCPソケットを開きます
- クライアントがプロトコルの互換性をアドバタイズし、リクエストします
- サーバーが互換性を確認し、準備完了を宣言します
- クライアントがセッションを開始/再開します
- クライアントが各ワーカーの認証をリクエストします
- サーバーが各認証のレスポンスを返します
- サーバーが `mining.set` を送信し、後続のマイニングジョブに採用する定数値を宣言します
- サーバーが最小限のジョブ情報を含む `mining.notify` を送信します
- クライアントがジョブでマイニングします
- クライアントが見つかったソリューションを `mining.submit` で送信します
- サーバーがソリューションを受け入れるかどうかを返信します
- サーバーが必要に応じて `mining.set` を送信し、後続のマイニングジョブに採用する定数値を宣言します (何かが変更された場合)
- サーバーが最小限のジョブ情報を含む `mining.notify` を送信します
- ... (続行)
- 最終的に、どちらかの当事者がセッションとTCPコネクションを閉じます

### セッション処理 - Hello
~~これまでの最悪の煩わしさの1つは、サーバーがソケット接続の瞬間に、実装されているStratumフレーバーに関する有用な情報を提供しないことです。つまり、クライアントは異なるプロトコルフレーバーを試行錯誤的に接続を開始する必要があります。この提案は、サーバーがクライアントにアドバタイズする義務を課すことで、この状況を改善します。
新しいクライアントがサーバーに接続すると、サーバーは **MUST** `mining.hello` 通知を送信しなければなりません:~~

サーバーに最初のメッセージを送信する義務を課すことは、スプーフィングされたIPアドレスを使ったトラフィック増幅攻撃や従来のDDoS攻撃において、サーバーに大きなパケットを送り返させる可能性があるため、有害である可能性があることが指摘されています。
このため、最初の広告の義務はクライアントに課され、以下のように `mining.hello` リクエストを発行します:

```json
{
  "id" : 0,
  "method": "mining.hello", 
  "params": 
  { 
    "agent": "ethminer-0.17",
    "host" : "somemininigpool.com",
    "port" : "4d2",
    "proto": "EthereumStratum/2.0.0"
  }
}
```
`params` メンバーオブジェクトには以下の必須メンバーがあります:
- `agent` (文字列) マイニングソフトウェアのバージョン
- `host` (文字列) 接続しようとしているサーバーのホスト名
- `port` (16進数) 接続しようとしているサーバーのポート番号
- `proto` (文字列) クライアントが要求し、サーバーが実装していると期待するStratumのバージョン

ホストとポートを送信する理由は、仮想ホスティングを可能にすることで、DDoS保護のために使用される仮想プールやプライベートURLを、Stratumサーバーのバックエンドで集約できるためです。HTTPと同様に、サーバーはホスト文字列を信頼できません。ポートは、クライアント.reconnect メソッド (以下参照) と並行して含まれています。

サーバーがそのような要件でセッションの開始/再開に備えている場合、以下のように応答する **MUST**:
```json
{
  "id" : 0,
  "result": 
  { 
    "proto" : "EthereumStratum/2.0.0",
    "encoding" : "gzip",
    "resume" : "1",
    "timeout" : "b4",
    "maxerrors" : "5",
    "node" : "Geth/v1.8.18-unstable-f08f596a/linux-amd64/go1.10.4"
  } 
}
```
ここで `result` は5つの必須メンバーからなるオブジェクトです:
- `proto` (文字列) クライアントが要求した正確なバージョンと **MUST** 一致する
- `encoding` (文字列) 次のすべてのメッセージを gzip 圧縮するか否かを示す値。可能な値は "gzip" または "plain"
- `resume` (16進数) ホストがセッションの再開に備えているかどうかを示す値
- `timeout` (16進数) サーバーがクライアントからメッセージがない場合に接続を切断してよい秒数
- `maxerrors` (16進数) サーバーが許容する最大エラー数の後、接続を強制的に閉じる
- `node` (文字列) プールの基盤となるノードソフトウェアのバージョン

サーバーがこの応答で `"encoding" : "gzip"` とクライアントに返信した場合、両当事者は次のすべてのメッセージを gzip 圧縮する **MUST**。クライアントが圧縮に対応できない場合は、直ちに接続を閉じる **MUST**。
サーバーがこの応答の後に平文のメッセージを受け取った場合、接続を閉じる **MUST**。

最終的に、クライアントは `mining.subscribe` (後述) を続行します。

一方、エラーや会話の開始を拒否した場合、サーバーは有用な情報を提供するエラーで応答する **かもしれない**、または管理者の裁量で接続を強制的に閉じる **かもしれない**。
```json
{
  "id" : 0,
  "error": 
  { 
      "code": 400,
      "message" : "Bad protocol request"
  } 
}
```
または
```json
{
  "id" : 0,
  "error": 
  { 
      "code": 403,
      "message" : "Forbidden - Banned IP address"
  } 
}
```
_上記の2つのJSONエラー値は単なる例です_
最終的にサーバーは接続を閉じます。

なぜプールがノードのバージョンをアドバタイズする必要があるのでしょうか? これは透明性の問題です。マイナーは、プールがノードソフトウェアの最新のパッチ/リリースにアップグレードしているかどうかを知る必要があります。

### セッション処理 - Bye
Stratumでは、切断が適切に処理されていません。プールからのクライアントの切断は、さまざまなエラーが原因で発生する可能性があり、これにより、サーバー側のTCPソケットが無駄になり、キープアライブタイムアウトを待つことになります。有用な通知は `mining.bye` で、これが処理されると、セッションの両当事者が受信を停止し、TCP接続を適切に閉じることができます。
```json
{
  "method": "mining.bye"
}
```
このメッセージを受け取った当事者は、相手が会話を停止したことを認識し、ソケットを閉じます。発行者も閉じます。この通知を明示的に発行することで、セッションは放棄されるため、サーバーがセッション再開をサポートしている場合でも、再開は不可能になります。同じサーバーに再接続するクライアントは **SHOULD** 新しいセッションIDを期待し、すべ
てのワーカーを再認証する **MUST**。

### セッション処理 - セッションサブスクリプション
サーバーからの `mining.hello` への応答を受け取った後、クライアントは、サーバーがセッション再開をサポートしている場合、以前中断されたセッションを再開するよう `mining.subscribe` リクエストを送信する **かもしれない**:
```json
{
  "id": 1,
  "method": "mining.subscribe", 
  "params": "s-12345"
}
```
ここで `params` は、クライアントが再開したいセッションのIDです。

一方、クライアントが新しいセッションを開始したい **OR** サーバーがセッション再開をサポートしていない場合、サブスクリプションのリクエストから `params` メンバーを省略する **MUST**:
```json
{
  "id": 1,
  "method": "mining.subscribe"
}
```

### セッション処理 - サブスクリプションへの応答
クライアントのセッションサブスクリプションを受け取ったサーバーは、以下のように応答する **MUST**:
```json
{
  "id": 1,
  "result": "s-12345"
}
```
クライアントが `params` にセッションIDを含むサブスクリプションリクエストを送信した場合、以下のようなケースが考えられます:
- セッション再開がサポートされていない場合、`result` には新しいセッションIDが含まれ、クライアントが前回の `mining.subscribe` メソッドで発行したセッションIDとは異なる値になります
- セッション再開がサポートされている場合、サーバーはキャッシュから動作値を取得し、クライアントが要求したのと同じIDが `result` に含まれます。これはセッションが "再開された" ことを意味します。その結果、サーバーは `mining.set` を先行して送信することなくジョブの送信を開始でき、クライアントは前のセッションスコープで最後に受信した値を継続して使用する **MUST**。さらに、クライアントはすべてのワーカーを再認証する必要がない **かもしれない**
- セッション再開がサポートされているが、要求されたセッションが期限切れまたはキャッシュ値が消去された場合、`result` には、クライアントが前回の `mining.subscribe` メソッドで発行したセッションIDとは異なる新しいセッションIDが含まれます。その結果、サーバーはクライアントがワーカーの認証を要求するのを待ち、ジョブを送信する前に `mining.set` の値を送信する **MUST**。クライアントは (もしあれば) 以前にキャッシュした値をすべて破棄し、新しいセッションの準備をする **MUST**

セッション再開をサポートするサーバーは以下をキャッシュする **MUST**:
- セッションID
- セッションごとのアクティブなジョブ
- エクストラノンス
- 認証済みのワーカー

サーバーは独自のスケジュールでキャッシュエントリを破棄する **かもしれない**。同じエージェントおよび/またはIPのセッション検証を強制するのは、サーバーの責任です。

セッションを正常に購読し再開したクライアント (サーバーの応答のセッションの値がクライアントが `mining.subscribe` で要求したセッションの値と同一) は、ワーカーの認証リクエストを省略する **ことができる**。

### セッション処理 - Noop
マイナーが合理的な時間内にソリューションを見つけられない場合、サーバーが課したタイムアウト (サーバーがクライアントが切断されたと思う可能性がある) をトリガーする可能性があります。この問題を軽減するために、新しいメソッド `mining.noop`(追加のパラメーターなし)をクライアントがリクエストできます。
```json
{
  "id": 50,
  "method": "mining.noop"
}
```
### セッション処理 - Reconnect
特定の状況下では、サーバーがリソースを解放したり、別のマシンにマイナーを再配置したりする必要がある場合があります。これまでは、サーバーが接続を強制的に閉じるしかありませんでした。マイナーの側では、これはサーバーの障害と解釈され、ほとんどの場合、フェイルオーバープールに切り替えます。
`mining.reconnect` 通知の実装により、クライアントが大規模なマイニングプールの処理ロジックに適応しやすくなります。
```json
{
  "method": "mining.reconnect",
  "params": {
      "host": "someotherhost.com",
      "port": "d80",
      "resume": "1"
  }
}
```
この通知はサーバーからクライアントにのみ送信されることを意味しています。サーバーがこの通知を受け取った場合、単に無視します。通知が適切に送信された後、サーバーは接続を閉じることが許可されますが、クライアントは提案されたエンドポイントに再接続する適切な措置を講じます。
`params` オブジェクトの `host` メンバーは、IPアドレスではなく、ホストDNS名を報告 **SHOULD** します。TLS暗号化接続では、証明書のCN名の検証が必要で、99%の場合はホスト名です。
`params` オブジェクトの3番目のメンバー `resume` は、受信サーバーがセッション再開に備えているかどうかを設定します。
このような通知がサーバーから発行された後、クライアントは他のメッセージを期待せず、切断する **MUST**。

### ワーカーの認証
マイナーは、ジョブの受信とソリューションまたはハッシュレートの送信を開始するために、少なくとも1人のワーカーを認証する **MUST**。マイナーは、同じセッション内で複数のワーカーを認証する **かもしれない**。サーバーは、セッション内での複数のワーカーの認証を許可し、クライアントがジョブの送信を開始する前に、少なくとも1つの認証を検証する **MUST**。`ワーカー`は、報酬が付与されるアカウントと、実際に作業を行うマシンの識別子のペアです。Ethereumの一般的な形式は `<account>.<MachineName>` です。同じアカウントを複数のマシンにバインドできます。匿名マイニングを許可するプールでは、アカウントは報酬が付与されるアドレスですが、登録を要求するプールでは、アカウントはログイン名です。クライアントが解を送信するたびに、ワーカー識別子でラベル付けする必要があります。サーバーは、さまざまなアドレスの正しい会計を維持する責任があります。

認証リクエストの構文は以下の通りです:
```json
{
  "id": 2,
  "method": "mining.authorize", 
  "params": ["<account>[.<MachineName>]", "password"]
}
```
`params` メンバーは2つの文字列要素の配列でなければなりません。匿名マイニングの場合、"password" は任意の文字列値または空の文字列ですが、nullではありません。匿名マイニングを許可するプールは単に値を無視します。
サーバーは、エラーか、成功の場合は以下のように応答する **MUST**:
```json
{
  "id": 2,
  "result": "w-123"
}
```
ここで `result` メンバーは、`セッション`スコープ内で一意のトークンを保持し、認証されたワーカーを識別します。クライアントが発行するすべての後続のリクエストで、ワーカーに関連するものは、サーバーの `mining.authorize` リクエストへの応答で与えられたトークンを使用する **MUST**。これにより、ソリューションおよび/またはハッシュレートの送信に必要なバイト数が減少します。

クライアントが以前のセッションを再開している場合、ワーカーの認証リクエストを省略する **ことができ**、その場合、元のセッションで割り当てられたトークンを使用する **MUST**。ワーカーとトークンの正しいマッピングを維持するのはサーバーの責任です。
同じセッション内で以前に認証されたクレデンシャルと一致する認証リクエストを受け取ったサーバーは、以前に生成された一意のトークンで応答する **MUST**。

### マイニングの準備
多くのデータが無駄な冗長性で何度も送信されます。たとえば、シードハッシュは約30,000ブロック (約5日) ごとにしか変更されませんが、固定難易度のプールはワークターゲットをほとんど変更しません。さらに、プールはマイナー間のサーチセグメントを最適化し、各セッションに異なる "startNonce" (別名 extranonce) を割り当てる必要があります。
このため、`通知`メソッド `mining.set` により、頻繁に変更されない値のみをマイナーの側に設定できます。サーバーはシード、ターゲット、extranonce をセッションレベルで追跡し、これらの値のいずれか (またはすべて) が変更されるたびに、接続しているマイナーに `mining.set` 通知を送信します。
```json
{
  "method": "mining.set", 
  "params": {
      "epoch" : "dc",
      "target" : "0112e0be826d694b2e62d01511f12a6061fbaec8bc02357593e70e52ba",
      "algo" : "ethash",
      "extranonce" : "af4c"
  }
}
```
各 `セッション` の開始時に、サーバーは `mining.notify` を送信する前に、必ずこの通知を送信しなければなりません。この通知で渡された値は、新しい `mining.set` 通知が値を上書きするまで、次のすべてのジョブに有効です。メンバーの説明は以下の通りです:
- オプションの `epoch` (16進数): 実際のすべてのStratrum実装とは異なり、サーバーはクライアントにシードハッシュの代わりにエポック番号を通知する必要があります。これは2つの理由によって強制されています。主な理由は、クライアントがエポック0から順に増加するエポックを試行錯誤的に検索して、ハッシュがシードハッシュと一致するまで探索する以外に方法がないことです。2つ目の理由は、エポック番号がシードハッシュよりも簡潔であることです。結局のところ、シードハッシュはクライアントにエポックを通知するためにのみ送信され、マイニングアルゴリズムには関与しません。
- オプションの `target` (16進数): これはプールの難易度に合わせて調整されたバウンダリーハッシュです。EthereumStratum/1.0.0 では `mining.set_difficulty` 通知で _難易度のインデックス_ が提供されていましたが、提案者は直接バウンダリーハッシュを渡すことにしました。省略された場合、クライアントは `"0x00000000ffff0000000000000000000000000000000000000000000000000000"` のバウンダリーを **MUST** 想定する
- オプションの `algo` (文字列): マイナーが採掘することが期待されるアルゴリズム。省略された場合、クライアントは `"algo": "ethash"` と **MUST** 想定する
- オプションの `extranonce` (16進数): サーバーがクライアントに割り当てる開始検索セグメントのノンス。サーバーが以前に設定したextranonce をキャンセルしたい場合は、この値を空の文字列として渡す必要があります。

サーバーが、セッション内の1つ、2つ、3つ、または4つの値が変更されたことを検出するたびに、`params` オブジェクトに1つ、2つ、3つ、または4つのメンバーを含む通知を発行します。このため、新しい **セッション** では、サーバーは必ず4つのメンバーすべてを渡さなければなりません。その結果、マイナーは **次の** ジョブに合わせてそれらの値を適応させるよう指示されます。
新しい `algo` メンバーは、ethashの変種であるethash1aやProgPowなどのアルゴリズムの存在に備えるために定義されています。
マルチコインスイッチングを提供するプールは、スイッチ後にジョブを送信する前に、マイナーに新しい `mining.set` を送信する必要があります。
`mining.set` 通知で提供されたデータをサポートできないクライアントは、接続を閉じる **かもしれない** か、新しい値が自分の構成に適合するまで待機する **かもしれない** (see `mining.noop`)。
すべてのクライアントの実装は、セッション中に新しいextranoncesを受
け入れる準備をする **MUST**。EthereumStratum/1.0.0 とは異なり、オプションのクライアントアドバタイズメント `mining.extranonce.subscribe` は、ここでは暗黙的かつ必須です。

マイナーが `extranonce` を受け取ると、次のジョブのための検索セグメントを初期化し、extranonce を16バイトの16進数に調整して、必要に応じてゼロを追加する **MUST**。
extranonce "af4c" は "_次のジョブの検索セグメントは 0xaf4c000000000000 から始まる_" を意味します。
`extranonce` が空の文字列の場合、またはセッションスコープ内で一度も設定されていない場合、クライアントは後続の `mining.notify` ジョブで自身の検索セグメントの開始点を自由に選択できます。

### "extranonce"の詳細

プールに接続しているマイナーは、同じノンスを処理する可能性が高く、多くの重複ジョブが無駄になります。`ノンス`は、アルゴリズムとジョブの仕様に適用すると、ある一定のターゲットを下回る結果を生み出す有効な数値です。サーバーがクライアントに送信する各ジョブについて、2^64 の可能なノンスがあります。

以下の点に注意が必要です:
- 2^64 の範囲内の任意のノンスには、正解になる可能性が同じです。
- 特定のハッシュ処理ジョブは、複数のノンスで解決できる

数値をテストする各操作を `ハッシュ` と呼びます。ブロックごとにジョブを受け取るマイナーを想定し、現在の平均ブロック時間が15秒であることを考えると、マイナーは

```
  ( 2^64 / 15 ) / 1T ~ 1,229,782.94 テラハッシュ/秒
```

のコンピューティング能力を持つ必要があります。これは、市場にある任意のマイナー (ASICを含む) の能力を大幅に超えています。このため、単一のマイナーは、この膨大な範囲の小さな部分 (セグメント) のみを処理できます。マイナーがどのようにセグメントを選択するかは、この作業の範囲外です。ただし、マイナーが調整されていないため、単一のマイナーには、他のマイナーが選択したセグメントについての知識はありません。
extranonce の概念は、サーバー (ワークプロバイダー) に重複ジョブを課すのを軽減するために導入されています。

上記の前提に基づいて、ノンスは以下の16進範囲の任意の数値と表現できます:

```
  最小 0x0000000000000000
  最大 0xffffffffffffffff
```
_接頭辞 0x は、視覚的な表現を良くするためにわざと挿入されています_。

`extranonce` は、基本的には、クライアントに "_検索を開始する最初の数値を与える_" というサーバーからのメッセージです。より詳細に説明すると、`extranonce` は、その数値の最左部分です。
プールがクライアントに extranonce `ab5d` を通知したと仮定すると、クライアントの検索セグメントは以下のように狭くなります。
```
  最小 0xab5d000000000000
  最大 0xab5dffffffffffff
```
4バイトの extranonce (例のように) を送信することで、プールは65,535 人の (または 0xffff 人の) マイナーを分離できますが、マイナーにはまだ2^48 個の可能なノンスを検索するセグメントが残されます。
上記のように再計算すると、このセグメントを検索するために必要なコンピューティング能力は
```
  ( 2^48 / 15 ) / 1T ~ 18.76 テラハッシュ/秒
```
となり、これはマイナーが内部の検索セグメントをランダムに (または他の ergodic 手法を使って) 選択できる十分な範囲です。

extranonce **MUST** 関連するすべてのバイトで渡される (左側のゼロを省略しない) 理由がある。例えば extranonce が "01ac" の場合、10進数の値は "1ac" と同じですが、バイト数が変わるため、利用可能な検索セグメントが変わります。

```
  "01ac" の場合            "1ac" の場合
  セグメントは             セグメントは
  最小 0x01ac000000000000  最小 0x1ac0000000000000
  最大 0x01acffffffffffff  最大 0x1acfffffffffffff
```
ご覧のように、結果のセグメントはかなり異なります。

以上を踏まえ、extranonce を使用する場合、プール (サーバー) は最大6バイト (16進数) の長さを遵守する **MUST**。

### ジョブ通知
利用可能になると、サーバーは `mining.notify` 通知を発行してマイナーにジョブを配信します。
```json
{
  "method": "mining.notify", 
  "params": [
      "bf0488aa",
      "6526d5"
      "645cf20198c2f3861e947d4f67e3ab63b7b2e24dcc9095bd9123e7b33371f6cc",
      "0"
  ]
}
```
`params` メンバーは4つの必須要素で構成されています:
- 1つ目の要素はプールが指定したジョブID。プールは、送信するジョブIDを可能な限り簡潔に保つ **SHOULD**。ヘッダーハッシュと同じジョブIDを送信するのは良くない慣行で、強く推奨されません。
- 2つ目の要素はブロックIDの16進数
- 3つ目の要素はヘッダーハッシュ
- 4つ目の要素は、前のジョブから見つかったシェアが確実にスタールとしてカウントされるかどうかを示す16進数のブール値

### ソリューションの送信
マイナーがジョブのソリューションを見つけると、`mining.submit` リクエストをサーバーに送信します。
```json
{
  "id": 31,
  "method": "mining.submit", 
  "params": [
      "bf0488aa",
      "68765fccd712",
      "w-123"
  ]
}
```
`params` 配列の最初の要素は、(サーバーから送信された `mining.notify` メッセージで送信された) このソリューションが参照するジョブIDです。2番目の要素は `マイナーノンス` の16進数です。3番目の要素は、前の `mining.authorize` リクエストで与えられたトークンです。正常に認証されていないワーカー (セッション内にトークンが存在しない) に関連する `mining.submit` リクエストは **MUST** 拒否されます。

上記のサンプルでは、`マイナーノンス` が12バイトしかありません (16バイトである必要があります)。なぜでしょうか?
それは、前の `mining.set` でサーバーが `extranonce` を `af4c` に設定したためです。これは、完全なノンスが `af4c68765fccd712` であることを意味します。
extranonce が存在する場合、マイナーは extranonce に追加する文字のみを送信する **MUST**。セッションまたはワークに extranonce が設定されていない場合、マイナーは16バイト全体を送信する **MUST**。

サーバーは、セッション内の `ジョブID <-> extranonce` のタプルを追跡する責任があります。

サーバーがこのリクエストを受信すると、成功の場合は短い形式で応答します。
```json
{"id": 31}
```
エラーや条件がある場合は、詳細なエラーオブジェクトで応答します。
```json
{
  "id": 31,
  "error": {
      "code": 404,
      "message" : "Job not found"
  }
}
```

クライアントは、エラーを "ソフト" エラー (スタール) または "ハード" (ノンスの計算が間違っている、ジョブが見つからないなど) として扱う **SHOULD**。5xxのエラーはサーバーエラーを示し、マイナーは接続を放棄し、フェイルオーバーに切り替える必要があります。

### ハッシュレート
ほとんどのプールは、グラフや API 呼び出しの形式で、マイナーが計算したハッシュレートに関する統計情報を提供しています。マイナーは、自分のデバイスで読み取ったハッシュレートとこのデータを比較したいと考えています。これらの情報の当事者間の通信は、Stratumでは決して実装されていませんでしたが、ほとんどのプールは getWork から `eth_submitHashrate` メソッドを採用しています。
このドキュメントでは、`mining.hashrate` リクエストの公式実装を提案しています。
このメソッドは、クライアントまたはサーバーから発行された場合に異なる動作をします。
#### クライアントがサーバーにハッシュレートを通知する
```json
{
  "id" : 16,
  "method": "mining.hashrate",
  "params": [
      "500000",
      "w-123"
      ]
}
```
ここで `params` は2つの要素の配列で、最初の要素はマイナーがデバイス上で読み取ったハッシュレートの16進数表現 (32バイト) で、2番目の要素は `mining.authorization` で発行されたワーカートークンです。
サーバーは、確認応答メッセージで応答する **MUST**
```json
{"id": 16 }
```
オプションで、サーバーは **同じワーカー** について計算したハッシュレートを報告する応答を返すことができます。
```json
{
  "id": 16,
  "result" : [
      "4f0000",
      "w-123"
      ]
}
```
エラーの場合 (例えば、クライアントが頻繁に送信する) は以下のように応答します。
```json
{
  "id": 16,
  "error" : {
    "code": 220,
    "message": "Enhance your calm. Too many requests"
  }
}
```
#### サーバーがクライアントにハッシュレートを通知する
オプションで、サーバーは (サーバー側のスケジュールに従って) **全体のパフォーマンスについて** クライアントに `mining.hashrate` 通知を送信できます。
```json
{
  "method": "mining.hashrate",
  "params": {
      "interval": 60,
      "hr": "500000",
      "accepted": [3692,20],
      "rejected": 0,
  }
}
```
ここで `params` は、**セッション全体**の以下のメンバーを保持するオブジェクトです:
- `interval` (数値) 観察ウィンドウの幅 (分単位)。"_過去 x 分間、私たちが計算したのは ..._"
- `hr` (16進数) プールがマイナーに対して計算したハッシュレートの表現
- `accepted` は2つの数値要素の配列: 最初は受け入れられたシェアの総数、2番目はスタールシェアの数。この配列は "合計受け入れられたうち x がスタール" と解釈される必要がある
- `rejected` (数値) 拒否されたシェアの総数

クライアントは最終的に、内部アクションを取ってワーカーをリセット/再起動する。

## 著作権
著作権およびその関連権利は [CC0](../LICENSE.md) で放棄されています。