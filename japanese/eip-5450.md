---
original: 845654354588cf772f0ea5984d3e4d9338a453d14e2d83e93f45b0e5393c0028
---

---
eip: 5450
title: EOF - スタック検証
description: EOF関数のスタック使用量に対するデプロイ時検証。
author: Andrei Maiboroda (@gumb0)、Paweł Bylica (@chfast)、Alex Beregszaszi (@axic)、Danno Ferrin (@shemnon)
discussions-to: https://ethereum-magicians.org/t/eip-5450-eof-stack-validation/10410
status: Review
type: Standards Track
category: Core
created: 2022-08-12
requires: 3540, 3670, 4200, 4750
---

## 概要

検証済みのコントラクトの実行中にスタックアンダーフローやオーバーフローが発生しないことを保証するため、EOF (Ethereum Object Format) コードセクションの拡張検証を導入する。

## 動機

現在のEVMでは、各実行命令について、定義されている命令であるかの確認、スタックオーバーフローとアンダーフローの確認、ガス残量の確認など、さまざまな有効性チェックが行われています。

このEIPでは、例外的な状況が発生しないことを事前に検証し、無効なコードの実行とデプロイを防ぐことで、実行時に必要なチェック数を最小限に抑えます。

オペランドスタックの検証には以下のような利点があります:

- すべての命令のスタックアンダーフローチェックを不要にする
- `CALLF`と`JUMPF`(`JUMPF`は別のEIPで導入)を除くすべての命令のスタックオーバーフローチェックを不要にする
- 終了命令で実行が終了することを保証する
- 到達不能な命令のデプロイを防ぐことで、コードセクションのデータ保存への利用を抑制する

一方で以下のような欠点もあります:

- コードの構造に制約が加わる(JVM、CPythonバイトコード、WebAssemblyなどと同様)が、ユーザーに不便とされる場合は後方互換性を維持しつつ制約を緩和できる
- 2段階の検証パスとして実装するのが自然だが、必須ではなく、どの実装バリアントでも計算量とメモリ使用量は線形のままである

これらの検証ルールによって得られる保証は、EVMコードの事前コンパイルや即時コンパイルの実現可能性を高めます。単一パスのトランスパイルを安全に実行でき、スタック高さの検証によって高度なスタック/レジスタ処理を適用できます。メインネットのバリデーターノードにとっては影響は小さいかもしれませんが、ウィットネス検証やその他のメインネット以外の用途では大幅な高速化が期待できます。

## 仕様

### コード検証

*注記:* オペランドスタックと型セクションの概念は[EIP-4750](./eip-4750.md)で定義されているものを使用します。

各コードセクションは独立して検証されます。

#### 命令検証

[EIP-3670](./eip-3670.md)(および[EIP-4200](./eip-4200.md)と[EIP-4750](./eip-4750.md)による拡張)で定義された最初の検証フェーズでは、命令のオペコードと即値が有効かどうかを個別に確認します。

#### オペランドスタック検証

2番目の検証フェーズでは、コードに対してコントロールフロー解析を行います。

ここでの*オペランドスタック高さ*とは、この関数で参照可能なスタック値の数を指し、呼び出し元関数のフレームの値は含まれません(ただし、この関数の入力は含まれます)。検証手順では実際のオペランドスタック実装は必要ありません。高さの管理だけで十分です。

*終了命令*とは以下のいずれかの命令を指します:

- 関数の実行を終了する命令: `RETF`、`JUMPF`
- EVMの実行を終了する命令: `STOP`、`RETURN`、`RETURNCONTRACT`、`REVERT`、`INVALID`

*前方ジャンプ*は`RJUMP`/`RJUMPI`/`RJUMPV`命令のうち、相対オフセットが0以上のものを指します。*後方ジャンプ*は同じ命令のうち、相対オフセットが0未満のものを指します(同じジャンプ命令へのジャンプを含む)。

命令はコードを1回線形走査することで検証されます。各命令について、オペランドスタック高さの下限と上限を`stack_height_min`と`stack_height_max`として記録します。

最初の命令のスタック高さ範囲は、コードに対応する関数型の入力数と等しく初期化されます(`stack_height_min = stack_height_max = type[code_section_index].inputs`)。

各命令について以下の処理を行います:

1. **チェック**: この命令にスタック高さ範囲が記録されているかどうか。記録されていない場合、前方ジャンプの対象にもなっておらず、順次実行の一部でもないため、検証に失敗します。
   - これは検証アルゴリズムの前提条件であり、コードジェネレーターはベーシックブロックを後方ジャンプからのみ参照されるようには配置しない必要があります。
2. 命令がオペランドスタックに与える影響を判断する:
   1. **チェック**: 記録されたスタック高さ範囲が命令の要件を満たしているかどうか。具体的には:
      - `CALLF`命令の場合、記録された下限が呼び出し先関数の入力数以上であること
      - `RETF`命令の場合、記録された下限と上限が等しく、かつ呼び出し元関数の出力数と一致すること
      - `JUMPF`で呼び出し元関数から呼び出し先関数に移る場合、記録された下限と上限が`type[current_section_index].outputs + type[target_section_index].inputs - type[target_section_index].outputs`と一致すること
      - `JUMPF`で非終了関数に移る場合、記録された下限が呼び出し先関数の入力数以上であること
      - その他の命令の場合、記録された下限が命令の入力数以上であること
      - `RETF`と`JUMPF`以外の終了命令については、スタックに余分な値が残っていても問題ない
   2. `CALLF`と`JUMPF`について、**チェック**: 記録された上限が`1024 - types[target_section_index].max_stack_height + types[target_section_index].inputs`を超えていないこと(スタックオーバーフローチェック)。検証に失敗する。
   3. 命令実行後のスタック高さ範囲を計算する:
      - `CALLF`後は`types[target_section_index].outputs - types[target_section_index].inputs`分だけ調整する
      - その他の非終了命令後は、入力数を減らし出力数を加える
      - 終了命令後は範囲を更新する必要がない
3. 現在の命令の後続命令のリストを決定する:
   1. 終了命令と無条件ジャンプ以外の場合は次の命令
   2. 条件付きジャンプや無条件ジャンプの全ターゲット
4. 各後続命令について:
   1. **チェック**: 命令がコード内に存在すること(コードの外に"落ちる"ことがないこと)
   2. 前方ジャンプや順次実行で到達する場合:
      1. まだ記録されていない場合は、2.3で計算した範囲を記録する
      2. 既に記録されている場合は、記録された範囲と2.3の範囲を統合する(下限は小さい方、上限は大きい方)
   3. 後方ジャンプで到達する場合、**チェック**: 記録された範囲が2.3の範囲と一致すること。一致しない場合は検証に失敗(異なるスタック高さへの後方ジャンプ)

すべての命令を走査した後、関数の最大オペランドスタック高さを決定する:

1. 記録された上限の最大値を計算する
2. **チェック**: 最大高さが1023(`0x3FF`)を超えていないこと
3. **チェック**: 最大高さが型セクションの`max_stack_height`と一致すること

この検証パスの計算量とメモリ使用量は*O(len(code))*である。各命令は最大1回しか走査されない。

### 実行

デプロイ時の検証により、EVM実装では各命令の実行時にスタックアンダーフローやオーバーフローのチェックを行う必要がなくなる。例外は`CALLF`と`JUMPF`で、呼び出し先関数全体のスタックオーバーフローチェックを行う。

## 根拠

### 検証済みコードの性質

オペランドスタック検証に合格したコードセクションには以下の性質がある:

1. 到達不能な命令がない
2. 後方ジャンプからのみ到達可能な命令がない
3. スタックアンダーフローは発生しない
4. スタックオーバーフローは`CALLF`または`JUMPF`でのみ発生する可能性がある
5. 異なるスタック高さから同じ命令に前方ジャンプできる。ターゲットブロックのスタックは全ての可能な高さに対して検証される
6. 後方ジャンプ命令は常に同じスタック高さのターゲットを指す。スタックの無限プッシュやポップを伴うループはデプロイできない
7. コードセクションの最終命令は終了命令か`RJUMP`

### CALLF/JUMPFでのみスタックオーバーフローチェック

このEIPでは、`CALLF`と`JUMPF`命令でのみ呼び出し先関数の`max_stack_height`情報を使ってスタックオーバーフローチェックを行う効率的な実装を提案する。これにより、EVMプログラムの柔軟性は低下するが、`max_stack_height`は関数内の最悪ケースのコントロールフローパスに対応するため。

### 到達不能コード

オペランドスタック検証アルゴリズムは、到達不能な命令を含むコードを拒否する。この検査は非常に安価に行えるため、デグレードしたコードのデプロイを防ぐことができる。さらに、命令検証とオペランドスタック検証を単一パスで組み合わせることができる。

### 終了時のクリーンなスタック

現在、`RETF`命令実行後にオペランドスタックが空(現在の関数コンテキストで)であることが要求されている。そうしないと`RETF`の意味論がより複雑になる。関数の出力数をnとしたとき、`RETF`時のスタック高さをsとすると、EVMは`s-n`の非トップスタック項目を消去し、nの項目をその場所に移動する必要がある。この操作のコストは比較的安価だが定数ではない。
ただし、この要求を緩和し、上記のような`RETF`の意味論の変更は後方互換性を維持したまま将来的に導入できる。

### より制限的なスタック検証

当初提案されていた別のスタック検証の方式では、コードセクション全体を幅優先探索で走査し、各命令到達時のスタック高さを追跡し、全ての到達パスでスタック高さが一定であることを確認するというものだった。

この方式の利点は、アルゴリズムがやや単純(スタック高さ範囲を追跡する必要がなく、単一の高さ値のみ)で、ベーシックブロックの順序に制約がないことだった。

しかし、コンパイラチームからは、このような厳格なスタック高さ要件に反対意見があった。コンパイラで一般的に使われるパターンの1つに、異なるスタック高さから共通の終了ヘルパー(`RETURN`や`REVERT`で終了するコードブロック)にジャンプするというものがあるが、これが不可能になるためである。例えば、一連の`assert`文をそれぞれ`RJUMPI`でヘルパーにジャンプするように実装するのは一般的だが、スタック高さ一定要件だと、ヘルパーにジャンプする前に余分な項目をポップアップする必要があり、コード容量とガス消費が大幅に増加し、ヘルパーを抽出する意味がなくなってしまう。

### ベーシックブロックの順序

スタック検証アルゴリズムの前提条件として、ベーシックブロックが後方ジャンプからのみ参照されるようには配置されていることが必要である。

これは、コードセクションを1回の線形走査で検証できるようにするためである
前方走査によりジャンプ先のスタック高さ範囲を"展開"できるため、計算量を線形に抑えられる。一方、幅優先探索でコードを走査しながらジャンプ先の範囲を展開しようとすると、範囲が展開された後にパス全体を再検査する必要があり、計算量が二次になってしまう。

## 後方互換性

このルール変更はコンセンサスルールを変更するため、"ネットワークアップグレード"が必要となる。

ただし、EOF1コントラクトでのみ適用されるため、既存のコントラクトで未定義の命令を使用しているものはなく、後方互換性のリスクはない。新しい命令はレガシーバイトコード(EOF形式ではないコード)には導入されない。

## セキュリティ上の考慮事項

議論が必要。

## 著作権

著作権およびそれに関連する権利は[CC0](../LICENSE.md)で放棄されています。