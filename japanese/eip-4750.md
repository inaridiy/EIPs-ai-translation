---
original: 926ffc8f5ea019558957ea73deed0495e791c43f4432d23867af974a096a34d7
---

---
eip: 4750
title: EOF - 関数
description: `CALLF`と`RETF`命令を使った関数の個別セクション
author: Andrei Maiboroda (@gumb0)、Alex Beregszaszi (@axic)、Paweł Bylica (@chfast)
discussions-to: https://ethereum-magicians.org/t/eip-4750-eof-functions/8195
status: レビュー
type: Standards Track
category: Core
created: 2022-01-10
requires: 3540, 3670, 5450
---

## 概要

EOF形式([EIP-3540](./eip-3540.md))のバイトコードに、それぞれがサブルーチン/関数を表す複数のコードセクションを持つ機能を導入します。`CALLF`と`RETF`の2つの新しい命令が、そのような関数の呼び出しと返却に使用されます。動的ジャンプ命令は許可されません。

## 動機

現在、EVMでは全てが動的ジャンプです。Solidityのような言語は、ほとんどのジャンプを静的な方法で生成します(つまり、ジャンプ先がスタックにプッシュされる直前に`PUSHn .. JUMP`)。しかし、検証/分析の要件のために、ほとんどのEVM実装ではこれを使うことができません。これにより、ジャンプのコストを削減する最適化も制限されます。

[EIP-4200](./eip-4200.md)は静的ジャンプ命令を導入し、ほとんどの動的ジャンプのユースケースを解決しますが、すべてを解決できるわけではありません。

このEIPは、関数の呼び出しと返却を提供することで、動的ジャンプの必要性と使用を排除することを目的としています。

さらに、各関数の入力と出力の数をエンコードし、各関数のスタックを分離することで(つまり、関数はコーラー/コーリーのスタックを読み取ることはできません)、分析の機会を改善することを目的としています。

## 仕様

### タイプセクション

EOF コンテナのタイプセクションは以下の要件に従う必要があります:

1. セクションは、メタデータのリストで構成されます。メタデータのインデックスはコードセクションのインデックスに対応します。したがって、タイプセクションのサイズは `n * 4` バイトでなければならず、`n` はコードセクションの数です。
2. 各メタデータ項目には3つの属性があります: uint8 `inputs`、uint8 `outputs`、uint16 `max_stack_height`。*注意:* これは、入力と出力の両方で最大255スタックアイテムがあることを意味します。さらに、上位ビットが将来の使用のために予約されているため(「outputs == 0x80」はEOF1で既に非返却関数を示すために使用されています)、127スタックアイテムに制限されます。`max_stack_height`は[EIP-5450](./eip-5450.md)でさらに定義されています。
3. 0番目のコードセクションには0個の入力と0個の出力がなければなりません。

well-formed EOF バイトコードの完全な構造については、[EIP-3540](./eip-3540.md)を参照してください。

### EVMの新しい実行状態

戻りスタックが導入されます。これは、関数の実行が終了した後に戻る実行状態を表すスタックです。各アイテムは、コードセクションのインデックスとコードセクション内のオフセット(PCの値)で構成されます。

注意: 実装は、スタックアイテムの特定のエンコーディングを選択できます。以下の仕様では、2つの符号なし整数: `code_section_index`、`offset`を使用していると仮定しています。

戻りスタックは最大1024アイテムに制限されます。

さらに、EVMは現在実行中のセクションのインデックス `current_section_index` を追跡します。

### 新しい命令

2つの新しい命令を導入します:

1. `CALLF` (`0xe3`) - 関数を呼び出す
2. `RETF` (`0xe4`) - 関数から返る

コードがレガシーバイトコードの場合、これらの命令のいずれかを使用すると*例外的な停止*が発生します。(*注意: これは動作の変更はありません。*)

まず、いくつかのヘルパー値を定義します:

- `type[i].inputs = type_section_contents[i * 4]` - i番目のコードセクションの入力数
- `type[i].outputs = type_section_contents[i * 4 + 1]` - i番目のコードセクションの出力数
- `type[i].max_stack_height = type_section_contents[i * 4 + 2:i * 4 + 4]` - i番目のコードセクションの最大オペランドスタックの高さ

コードがEOF1として有効な場合、以下の実行ルールが適用されます:

#### `CALLF`

1. 1つの即値引数 `target_section_index` があり、これは16ビットの符号なし ビッグエンディアン値でエンコードされています。
2. *注意:* EOF検証[EIP-5450](./eip-5450.md)により、オペランドスタックにはコーリー関数の入力として使用できるだけの十分なアイテムがあることが保証されます。
3. オペランドスタックのサイズが `1024 - type[target_section_index].max_stack_height + type[target_section_index].inputs` を超える場合(つまり、呼び出された関数がグローバルスタックの高さ制限を超える可能性がある場合)、実行は例外的な停止になります。これにより、呼び出し後のスタックの高さが制限内に収まることも保証されます。
4. 戻りスタックに既に `1024` アイテムがある場合、実行は例外的な停止になります。
5. 5ガスを請求します。
6. オペランドスタックからは何もポップせず、何もプッシュしません。
7. 戻りスタックにアイテムをプッシュします:

   ```
   (code_section_index = current_section_index, 
   offset = PC_post_instruction)
   ```
   
   `PC_post_instruction`は、`CALLF`の即値引数全体の後のPC位置を意味します。
   
   *注意:* EOF検証[EIP-5450](./eip-5450.md)により、`CALLF`の後には必ず命令があることが保証されています(終了命令または無条件ジャンプがセクションの最後の命令である必要があるため)。したがって、`PC_post_instruction`はセクション内の命令を常に指しています。
8. `current_section_index`を`target_section_index`に、`PC`を`0`に設定し、呼び出されたセクションで実行を続行します。

#### `RETF`

1. 即値引数はありません。
2. *注意:* EOF検証[EIP-5450](./eip-5450.md)により、オペランドスタックには出力として使用できる正確な数のアイテムがあることが保証されます。
3. 3ガスを請求します。
4. オペランドスタックからは何もポップせず、何もプッシュしません。
5. 戻りスタックからアイテムをポップし、そのアイテムの値を `current_section_index` と `PC` に設定します。

*注意:* 0番目のコードセクションが非返却であるという EOF検証の要件(別のEIPで導入される非返却セクション)により、`RETF`の前に戻りスタックが空になることはありません。

### コード検証

上記のコンテナ形式の検証ルールに加えて、コードセクションの検証ルール(EIP-3670で定義されているとおり)を拡張します。

1. EIP-3670で定義されているコード検証ルールが、すべてのコードセクションに適用されます。
2. `CALLF`の即値引数がコードセクションの総数以上の場合、コードセクションは無効です。
3. `RJUMP`、`RJUMPI`、`RJUMPV`の即値引数(ジャンプ先のオフセット)の検証:
    1. ジャンプ先のオフセットがセクション境界外を指す場合、コードセクションは無効です。
    2. ジャンプ先のオフセットが`CALLF`命令の直後の2バイトを指す場合、コードセクションは無効です。
5. 到達不可能なコードセクションは許可されません。つまり、0番目のコードセクションから`CALLF` / `JUMPF`(`JUMPF`は別のEIPで導入される)命令のシーケンスでアクセスできるすべてのコードセクションが到達可能でなければなりません(0番目のコードセクションは常に到達可能です)。

### 禁止された命令

動的ジャンプ命令の`JUMP` (`0x56`)と`JUMPI` (`0x57`)は無効で、それらのオペコードは未定義です。

`JUMPDEST` (`0x5b`)命令は、動作の変更なしに`NOP`("no operation")に名称変更されます。つまり、オペランドスタックからは何もポップせず、何もプッシュせず、`PC`のインクリメントと1ガスの請求以外の効果はありません。

`PC` (0x58)命令は無効となり、そのオペコードは未定義です。

*注意:* この変更により、EOFコードのJUMPDEST分析は不要になります。

### 実行

1. 実行は0番目のコードセクションの最初のバイトから始まり、PCは0に設定されます。
2. 戻りスタックは空で初期化されます。
3. スタックアンダーフローチェックは不要になりました。*注意:* EOF検証[EIP-5450](./eip-5450.md)により、実行時に発生しないことが保証されます。
3. スタックオーバーフローチェックは不要になりました。ただし、上記の`CALLF`の際は例外です。

## 根拠

### トップフレームでの`RETF`の終了vs例外的停止vs検証時の許可

`RETF`のトップフレームでの動作の代替案としては、以下のようなものが考えられます:

- 戻りスタックが`RETF`によって空になった場合は終了する
- 戻りスタックが空の状態で`RETF`が実行された場合は例外的停止する

しかし、これらは、別のEIPで導入される非返却セクションの検証ルールによって不要になりました。関数の非返却ステータスを検証することは、他の理由からも価値があるためです。したがって、トップフレームでの`RETF`の実行時動作に関する考慮事項はすべて時代遅れになりました。

### コードセクションの上限とインストラクションサイズ

コードセクションの数は1024に制限されています。これにより、`CALLF`の即値引数に2バイトが必要となり、将来の上限の増加の余地が残されています。256の上限(1バイトの即値)についても議論されましたが、それでは不十分かもしれないという懸念が示されました。

### `NOP`命令

`JUMPDEST`を非推奨にする代わりに、`NOP`命令として再利用します。なぜなら、`JUMPDEST`は実質的に"no-operation"命令であり、様々な文脈で既にそのように使用されていたためです。オフチェーンツールでの実装ベンチマーキング(NOPの性能はEVM実装ループの性能)、コードアラインメントの強制、動的コード構成のプレースホルダーなどに役立つ可能性があります。

### `JUMPDEST`分析の非推奨化

`JUMPDEST`分析の目的は、`PUSH`の即値データの内部ではない有効な`JUMPDEST`バイトを見つけることでした。動的ジャンプ命令(`JUMP`、`JUMPI`)のみが、ジャンプ先が`JUMPDEST`命令である必要がありました。相対静的ジャンプ(`RJUMP`と`RJUMPI`)にはこの要件はありません。デプロイ時のEOF命令検証で一度検証されます。したがって、動的ジャンプ命令がなくなれば、`JUMPDEST`分析は不要になります。

## 下位互換性

この変更は下位互換性のリスクはありません。EOF1コントラクトにのみ導入されるため、未定義の命令をデプロイする既存のコントラクトはありません。新しい命令はレガシーバイトコード(EOF形式ではないコード)には導入されません。

新しい実行状態とマルチセクションのコントロールフローは、単一のコードセクションの実行を一般化したものであるため、下位互換性のリスクはありません。既存のコントラクト(レガシーとEOF1の両方)の実行には、ユーザーが観察できる変更はありません。

## セキュリティ上の考慮事項

T
## 著作権

著作権およびそれに関連する権利は[CC0](../LICENSE.md)によって放棄されています。