---
original: 75fe54c3bccfbd89b672df8e78c0f2c6e6499dc07d99f7601a154a4a8a440de4
---

---
eip: 2733
title: トランザクションパッケージ
author: Matt Garnett (@lightclient)
discussions-to: https://ethereum-magicians.org/t/eip-transaction-package/4365
status: 取り下げられた
type: Standards Track
category: Core
created: 2020-06-16
requires: 2718
withdrawal-reason: EIP-3074をトランザクションパッケージの好ましい解決策として追求することにしました。
---

## 簡単な要約
1つ以上のトランザクションを実行するパッケージを含む新しいトランザクションタイプを作成し、後続のトランザクションにステータス情報を渡します。

## 概要
クライアントによって順次実行されるトランザクションのリストを含む新しいトランザクションタイプを導入します。実行情報(成功、gas_used等)は次のトランザクションに伝播されます。

## 動機
新しいユーザーがトランザクションの支払いに十分なイーサを取得する必要があるため、Ethereumへの参入が非常に困難でした。この障壁を解決するために多くのリソースが割り当てられてきました。現在の解決策はメタトランザクションです。残念ながら、これは脆弱な解決策で、スマートコントラクト内でメッセージの認証を行うために署名を回復する必要があります。このEIPは、リレーヤーが一度に多くのトランザクションを「スポンサー」できる柔軟なフレームワークを提供することを目的としています。

メタトランザクションは多くの場合、ノンスの管理と代替資産を使ってガスを支払うことを可能にするリレー契約を使用しています。過去には、内部トランザクションの巻き戻しを検知するために、利用可能なガスの一部しか内部呼び出しに渡さないように設計されていました。これにより、アカウントの処理など、外部呼び出しが完了するのに十分なガスがあることを確認できます。このような内部呼び出しは長らく悪い慣行とされてきましたが、サブコールを信頼できない場合は唯一の利用可能な解決策です。

トランザクションパッケージは、リレー契約と同様に、複数のトランザクションをパッケージ化して原子的に実行できる代替案です。トランザクションは結果を後続のトランザクションに渡すことができます。これにより、前のトランザクションの結果に基づいた条件付きのワークフローが可能になります。この機能は上述のように既に可能ですが、トランザクションパッケージを使用するワークフローはより堅牢です。なぜなら、ガススケジュールの将来の変更から保護されているためです。

このEIPの重要な副産物は、単一のユーザーのトランザクションをバンドルすることも可能になることです。

## 仕様
`id = 2`の新しい[EIP-2718](./eip-2718.md)トランザクションタイプを導入します。

#### 構造
```
struct TransactionPackage {
    chain_id: u256,
    children: [ChildPackage],
    nonce: u64,
    gas_price: u256,
    v: u256,
    r: u256,
    s: u256
}
```

##### ハッシュ
`keccak256(rlp([2, chain_id, children, nonce, gas_price, v, r, s])`

##### 署名ハッシュ
`keccak256(rlp([2, chain_id, children, nonce, gas_price])`

##### レシート
各`ChildTransaction`トランザクションの実行後に`ChildReceipt`が生成されます。これらのレシートは`Receipt`にまとめられます。

```
type Receipt = [ChildReceipt]
```

```
struct ChildReceipt {
    status: u256,
    cumulative_gas_used: u256,
    logs_bloom: [u8; 256],
    logs: [u8]
}
```

#### 子トランザクション
`ChildPackage`は次のように解釈されます。

```
struct ChildPackage {
    type: u8,
    nonce: u64,
    transactions: [ChildTransaction],
    max_gas_price: u256,
    v: u256,
    r: u256,
    s: u256
}
```

```
struct ChildTransaction {
    flags: u8,
    to: Address,
    value: u256,
    data: [u8],
    extra: [u8],
    gas_limit: u256
}
```

##### タイプ
`type`フィールドは、`Child`署名者が`max_gas_price`と`gas_limit`の選択を`TransactionPackage`署名者に委任するかどうかを示すために使用されます。

| type  | 署名ハッシュ  |
|---|---|
| `0x00` | `keccak256(rlp([0, nonce, transactions, max_gas_price])` |
| `0x01` | `keccak256(rlp([1, nonce, transactions_without_gas_limit])` |

### 有効性

`TransactionPackage`は次のように有効または無効と見なされます。

```rust    
fn is_valid(config: &Config, state: &State, tx: TransactionPackage) bool {
    if (
        config.chain_id() != tx.chain_id ||
        tx.children.len() == 0 ||
        state.nonce(tx.from()) + 1 != tx.nonce
    ) {
        return false;
    }

    let cum_limit = tx.children.map(|x| x.gas_limit).sum();
    if state.balance(tx.from()) < cum_limit * tx.gas_price + intrinsic_gas(tx) {
        return false;
    }
    
    for child in tx.children {
        if (
            child.nonce != state.nonce(child.from()) + 1 ||
            child.value > state.balance(child.from()) ||
            child.max_gas_price < tx.gas_price
        ) {
            return false;
        }
        
        for tx in child.txs {
            if (
                tx.flags != 0 ||
                tx.extra.len() != 0 ||
                tx.gas_limit < intrinsic_gas(tx)
            ) {
                return false;
            }
        }
    }
    
    true
}
```

### 結果

後続の`ChildTransaction`は、任意のサブコールを行う前に、実行の最初のフレームで`RETURNDATACOPY (0x3E)`を使って前の`ChildTransaction`の結果を受け取ることができます。各要素(最後のものを除く)は32バイトに左パディングされます。

```
struct Result {
    // 前のトランザクションのステータス
    success: bool,
    
    // 前のトランザクションの合計ガス使用量
    gas_used: u256,
    
    // 前のトランザクションの累積ガス使用量
    cum_gas_used: u256,
    
    // 返り値のサイズ
    return_size: u256,
    
    // 前のトランザクションの返り値
    return_value: [u8]
}
```

### 固有のコスト
トランザクションパッケージの固有のコストは次のように定義されます:

```
fn intrinsic_gas(tx: TransactionPackage) u256 {
    let data_gas = tx.children.map(|c| c.txs.map(|t| data_cost(&c.data)).sum()).sum();
    17000 + 8000 * tx.children.len() + data_gas
}
```

### 実行
トランザクションパッケージは次のように実行されるべきです:
1. 外部署名者の残高から累積コストを差し引きます。
2. 最初の子パッケージをロードし、最初の子トランザクションを実行します。
3. すべての状態変更、ログ、レシートを記録し、未使用のガスを払い戻します。
4. 子トランザクションがそれ以上ない場合は8に進みます。
5. 前に実行されたトランザクションの`Result`を計算します。
6. 次のトランザクションの最初のフレームで返り値オペコードを使用できるように`Result`を準備します。
7. 次のトランザクションを実行し、3に戻ります。
8. 次の子パッケージをロードし、7に進みます。

## 根拠

### 各`Child`が独自の署名を持つ
簡単のため、著者は各子パッケージに独自の署名を指定することにしました。これは、最大限の柔軟性を持ち、クライアントの変更を最小限に抑えるためです。この取引は、1つの追加の署名回復のコストで、単一のユーザーによっても使用できます。

### `ChildPackage`は`gas_price`ではなく`max_gas_price`を指定する
子パッケージに許容可能な一連のガス価格を指定することを可能にすることは、固定価格よりも明らかに柔軟性が高くなります。リレーヤーにトランザクションバンドルを構築する際の柔軟性を高め、トランザクション送信者に最適な価格を達成することができます。固定価格の場合、リレーヤーはユーザーに異なる価格の複数のトランザクションに署名させる必要があるかもしれません。これは、最大価格を指定し、トランザクションの緊急性(例えば、リレーヤーが最大価格でただちにパッケージ化するか、ガス価格を徐々に上げるか)について外部的に伝達することで回避できます。
単一の署名のみを必要とする将来のトランザクションタイプを指定することで、この最適化を行うことができます。

### `ChildPackage`にもタイプが付けられている
タイプ要素は、トランザクション署名者がガス価格とガス制限の制御を外部署名者に委任するかどうかを示すために、トランザクションタイプ内で控えめな役割を果たします。これは、信頼できるリレーヤーと対話する際のユーザビリティ改善に役立ちます。ユーザーがトランザクションを行うことを決めたら、リレーヤーはベストなガス価格と制限を選択することで、確実にオンチェーンに含めることができます。

### `flags`と`extra`フィールドは使用されていない
これらのフィールドは、将来のトランザクションタイプの変更をより良くサポートするために含まれています。これは、`flags`と`type`フィールドと組み合わせて使用される可能性があります。明示的に定義することの利点は、RLPの専用シリアル化を回避し、クライアントやダウンストリームインフラストラクチャを単純化できることです。トランザクションあたり2バイトのコストは、将来の機能の統合をスムーズにするために許容可能だと考えています。

## 下位互換性
`ORIGIN (0x32) == CALLER (0x33) && RETURNDATASIZE (0x3D) == 0x00`に依存するコントラクトは、最初に実行されるトランザクションを除いて、常に失敗するようになります。この確認を行うコントラクトがあるかどうかは不明です。

## テストケース
TBD

## 実装
TBD

## セキュリティ上の考慮事項
### メンプールでのパッケージの効率的な管理
新しいトランザクションタイプの導入には、メンプールに関する新しい懸念が生じます。適切に行わないと、クライアントに対するDDoS攻撃ベクトルになる可能性があります。このEIPは、検証の複雑さを可能な限り減らすように書かれています。

新しいトランザクションが維持することが望ましい既存のメンプールの不変条件の1つは、トランザクションを定数時間で検証できることです。パッケージ化されたトランザクションについても同様に可能です。RLPxフレームの既存の10Mb制限があるため、パッケージに含めることができるトランザクションの上限はそれになります。一方で、クライアントは独自の制限(例えば、パッケージは1Mb未満)を設定することもできます。その場合、上記の関数を使用して有効性を判断できます。

パッケージが検証されたら、そのパッケージ内のノンス無効化を継続的に監視する必要があります。これを効率的に行う1つの方法は、メンプールを基礎となるトランザクションへの thin pointerで動作するように変更することです。これにより、パッケージは多くの「単一」トランザクションを取り込むことができ、監視の機能を簡素化できます。パッケージの「部品」は、パッケージの部品へのポインタを持つ構造体へのポインタを維持できます。これにより、1つの部品が無効になると、親に対してパッケージの全部品を無効にするよう要求できます。

## 著作権
著作権およびそれに関連する権利は[CC0](../LICENSE.md)で放棄されています。