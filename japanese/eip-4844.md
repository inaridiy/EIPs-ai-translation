---
original: 2772bdb675d90d89ebb4bf74269e48c8ea46745e78161c8574ffa78328b31885
---

---
eip: 4844
title: シャードBlobトランザクション
description: シャードBlobトランザクションは、シンプルで前方互換性のある方法でEthereumのデータ可用性をスケーリングします。
author: Vitalik Buterin (@vbuterin)、Dankrad Feist (@dankrad)、Diederik Loerakker (@protolambda)、George Kadianakis (@asn-d6)、Matt Garnett (@lightclient)、Mofi Taiwo (@Inphi)、Ansgar Dietrichs (@adietrichs)
discussions-to: https://ethereum-magicians.org/t/eip-4844-shard-blob-transactions/8430
status: Final
type: Standards Track
category: Core
created: 2022-02-25
requires: 1559, 2718, 2930, 4895
---

## 概要

大量のデータを含む「Blob保持トランザクション」の新しいトランザクション形式を導入します。このデータはEVM実行からアクセスできませんが、コミットメントはアクセスできます。
この形式は、完全なシャーディングで使用される形式と完全に互換性があることを目的としています。

## 動機

ロールアップは短期的および中期的に、そして長期的にも可能性があるEthereumの唯一の無信頼スケーリングソリューションです。
L1のトランザクション手数料は数か月間非常に高く、ロールアップへのエコシステム全体の移行を支援するために必要なことを行うことに緊急性があります。
ロールアップは多くのEthereum利用者の手数料を大幅に削減しています: Optimism とArbitrumは、しばしばイーサリアムのベースレイヤーよりも3〜8倍低い手数料を提供し、
ZKロールアップは、データ圧縮が優れており署名を含まないため、ベースレイヤーよりも40〜100倍低い手数料になります。

しかし、これらの手数料でも多くのユーザーにとって高すぎます。ロールアップ単独では長期的に不十分であるという長期的な解決策は常にデータシャーディングであり、
ロールアップが使用できる専用のデータスペースを1ブロックあたり約16MBを追加するものでした。
しかし、データシャーディングの実装と展開にはまだかなりの時間がかかります。

このEIPは、その時点までの一時的な解決策を提供します。シャーディングのトランザクション形式を実装しますが、それらのトランザクションをシャーディングしません。
代わりに、このトランザクション形式のデータはビーコンチェーンの一部となり、コンセンサスノードがすべてダウンロードしますが、比較的短い遅延後に削除できます。
完全なデータシャーディングと比較して、このEIPはこれらのトランザクションを含めることができる数が制限されており、ターゲットは1ブロックあたり約0.375MBで、上限は0.75MBです。

## 仕様

### パラメータ

| 定数 | 値 |
| - | - |
| `BLOB_TX_TYPE` | `Bytes1(0x03)` |
| `BYTES_PER_FIELD_ELEMENT` | `32` |
| `FIELD_ELEMENTS_PER_BLOB` | `4096` |
| `BLS_MODULUS` | `52435875175126190479447740508185965837690552500527637822603658699938581184513` |
| `VERSIONED_HASH_VERSION_KZG` | `Bytes1(0x01)` |
| `POINT_EVALUATION_PRECOMPILE_ADDRESS` | `Bytes20(0x0A)` |
| `POINT_EVALUATION_PRECOMPILE_GAS` | `50000` |
| `MAX_BLOB_GAS_PER_BLOCK` | `786432` |
| `TARGET_BLOB_GAS_PER_BLOCK` | `393216` |
| `MIN_BASE_FEE_PER_BLOB_GAS` | `1` |
| `BLOB_BASE_FEE_UPDATE_FRACTION` | `3338477` |
| `GAS_PER_BLOB` | `2**17` |
| `HASH_OPCODE_BYTE` | `Bytes1(0x49)` |
| `HASH_OPCODE_GAS` | `3` |
| [`MIN_EPOCHS_FOR_BLOB_SIDECARS_REQUESTS`](https://github.com/ethereum/consensus-specs/blob/4de1d156c78b555421b72d6067c73b614ab55584/configs/mainnet.yaml#L148) | `4096` |

### 型エイリアス

| 型 | ベース型 | 追加のチェック |
| - | - | - |
| `Blob` | `ByteVector[BYTES_PER_FIELD_ELEMENT * FIELD_ELEMENTS_PER_BLOB]` | |
| `VersionedHash` | `Bytes32` | |
| `KZGCommitment` | `Bytes48` | IETF BLS署名の"KeyValidate"チェックを実行しますが、アイデンティティポイントを許可します |
| `KZGProof` | `Bytes48` | `KZGCommitment`と同じ |

### 暗号化ヘルパー

このプロポーザルでは、対応する[コンセンサス4844仕様](https://github.com/ethereum/consensus-specs/blob/86fb82b221474cc89387fa6436806507b3849d88/specs/deneb)で定義された暗号化メソッドとクラスを使用しています。

具体的には、[`polynomial-commitments.md`](https://github.com/ethereum/consensus-specs/blob/86fb82b221474cc89387fa6436806507b3849d88/specs/deneb/polynomial-commitments.md)から以下のメソッドを使用しています:

- [`verify_kzg_proof()`](https://github.com/ethereum/consensus-specs/blob/86fb82b221474cc89387fa6436806507b3849d88/specs/deneb/polynomial-commitments.md#verify_kzg_proof)
- [`verify_blob_kzg_proof_batch()`](https://github.com/ethereum/consensus-specs/blob/86fb82b221474cc89387fa6436806507b3849d88/specs/deneb/polynomial-commitments.md#verify_blob_kzg_proof_batch)

### ヘルパー

```python
def kzg_to_versioned_hash(commitment: KZGCommitment) -> VersionedHash:
    return VERSIONED_HASH_VERSION_KZG + sha256(commitment)[1:]
```

テイラー展開を使って `factor * e ** (numerator / denominator)` を近似します:

```python
def fake_exponential(factor: int, numerator: int, denominator: int) -> int:
    i = 1
    output = 0
    numerator_accum = factor * denominator
    while numerator_accum > 0:
        output += numerator_accum
        numerator_accum = (numerator_accum * numerator) // (denominator * i)
        i += 1
    return output // denominator
```

### Blobトランザクション

[EIP-2718](./eip-2718.md)トランザクションの新しいタイプ、「Blobトランザクション」を導入します。ここで `TransactionType` は `BLOB_TX_TYPE` で、`TransactionPayload` は以下の `TransactionPayloadBody` のRLP直列化です:

```
[chain_id, nonce, max_priority_fee_per_gas, max_fee_per_gas, gas_limit, to, value, data, access_list, max_fee_per_blob_gas, blob_versioned_hashes, y_parity, r, s]
```

フィールド `chain_id`、`nonce`、`max_priority_fee_per_gas`、`max_fee_per_gas`、`gas_limit`、`value`、`data`、`access_list`は[EIP-1559](./eip-1559.md)と同じセマンティクスに従います。

フィールド `to` は少し異なるセマンティクスを持ち、`nil`であってはならず、常に20バイトのアドレスを表す必要があります。つまり、Blobトランザクションはcreateトランザクションの形式を取ることはできません。

フィールド `max_fee_per_blob_gas` は `uint256` であり、フィールド `blob_versioned_hashes` は `kzg_to_versioned_hash` の出力のリストを表します。

[EIP-2718](./eip-2718.md) `ReceiptPayload` はこのトランザクションの場合 `rlp([status, cumulative_transaction_gas_used, logs_bloom, logs])` です。

#### 署名

署名値 `y_parity`、`r`、`s` は、以下のダイジェストに対するsecp256k1署名を構築することで計算されます:

`keccak256(BLOB_TX_TYPE || rlp([chain_id, nonce, max_priority_fee_per_gas, max_fee_per_gas, gas_limit, to, value, data, access_list, max_fee_per_blob_gas, blob_versioned_hashes]))`.

### ヘッダー拡張

現在のヘッダーエンコーディングに2つの新しい64ビット符号付き整数フィールドが追加されます:

- `blob_gas_used` はブロック内のトランザクションによって消費されたBlobガスの合計量です。
- `excess_blob_gas` はターゲットを超えて消費されたBlobガスの累積値です。ターゲットを上回るBlobガス消費のブロックはこの値を増加させ、ターゲットを下回るBlobガス消費のブロックはこの値を減少させます(0以下に制限されます)。

したがって、ヘッダーのRLPエンコーディングは次のようになります:

```
rlp([
    parent_hash,
    0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347, # ommers hash
    coinbase,
    state_root,
    txs_root,
    receipts_root,
    logs_bloom,
    0, # difficulty
    number,
    gas_limit,
    gas_used,
    timestamp,
    extradata,
    prev_randao,
    0x0000000000000000, # nonce
    base_fee_per_gas,
    withdrawals_root,
    blob_gas_used,
    excess_blob_gas,
])
```

`excess_blob_gas` の値は親ヘッダーから計算できます。

```python
def calc_excess_blob_gas(parent: Header) -> int:
    if parent.excess_blob_gas + parent.blob_gas_used < TARGET_BLOB_GAS_PER_BLOCK:
        return 0
    else:
        return parent.excess_blob_gas + parent.blob_gas_used - TARGET_BLOB_GAS_PER_BLOCK
```

最初のフォーク後のブロックでは、`parent.blob_gas_used` と `parent.excess_blob_gas` の両方が `0` として評価されます。

### ガスアカウンティング

Blobガスという新しいタイプのガスを導入します。通常のガスから独立しており、EIP-1559と同様のターゲティングルールに従います。
`excess_blob_gas` ヘッダーフィールドを使用して、Blobガスベースフィーの計算に必要な永続データを保存します。現時点では、Blobのみがblobガスで価格付けされます。

```python
def calc_blob_fee(header: Header, tx: Transaction) -> int:
    return get_total_blob_gas(tx) * get_base_fee_per_blob_gas(header)

def get_total_blob_gas(tx: Transaction) -> int:
    return GAS_PER_BLOB * len(tx.blob_versioned_hashes)

def get_base_fee_per_blob_gas(header: Header) -> int:
    return fake_exponential(
        MIN_BASE_FEE_PER_BLOB_GAS,
        header.excess_blob_gas,
        BLOB_BASE_FEE_UPDATE_FRACTION
    )
```

ブロックの有効性条件は、Blobガスチェックを含むように変更されます(「実行レイヤーの検証」セクションを参照)。

`calc_blob_fee` で計算された実際の `blob_fee` は、トランザクション実行前に送信者の残高から差し引かれ、焼却されます。トランザクションの失敗の場合は返金されません。

### Blobハッシュを取得するオペコード

`BLOBHASH` (オペコード `HASH_OPCODE_BYTE`) という命令を追加します。これはスタックの先頭から `index` を big-endian `uint256` として読み取り、
`tx.blob_versioned_hashes[index]` に置き換えます(ただし `index < len(tx.blob_versioned_hashes)` の場合)。それ以外の場合は、ゼロ埋めされた `bytes32` 値に置き換えます。
このオペコードのガスコストは `HASH_OPCODE_GAS` です。

### ポイント評価プリコンパイル

`POINT_EVALUATION_PRECOMPILE_ADDRESS` にプリコンパイルを追加し、Blob(コミットメントで表される)が指定されたポイントで指定された値に評価されることを主張するKZGプルーフを検証します。

プリコンパイルは `POINT_EVALUATION_PRECOMPILE_GAS` コストがかかり、以下のロジックを実行します:

```python
def point_evaluation_precompile(input: Bytes) -> Bytes:
    """
    コミットメントに対応する多項式 p(x) と KZG プルーフを使用して、p(z) = y を検証します。
    また、提供されたコミットメントが提供された versioned_hash と一致することも検証します。
    """
    # データは次のようにエンコードされ
ています: versioned_hash | z | y | commitment | proof | ただし、z と y は 32 バイトの big endian 値でパディングされています

    assert len(input) == 192
    versioned_hash = input[:32]
    z = input[32:64]
    y = input[64:96]
    commitment = input[96:144]
    proof = input[144:192]

    # コミットメントが versioned_hash と一致することを検証
    assert kzg_to_versioned_hash(commitment) == versioned_hash

    # z と y を big endian 形式で KZG プルーフを検証
    assert verify_kzg_proof(commitment, z, y, proof)

    # FIELD_ELEMENTS_PER_BLOB と BLS_MODULUS を 32 バイトの big endian 値でパディングして返す
    return Bytes(U256(FIELD_ELEMENTS_PER_BLOB).to_be_bytes32() + U256(BLS_MODULUS).to_be_bytes32())
```

プリコンパイルは、非正規のフィールド要素(つまり、提供されたフィールド要素は `BLS_MODULUS` より厳密に小さくなければならない)を拒否しなければなりません。

### コンセンサスレイヤーの検証

コンセンサスレイヤーでは、Blobはビーコンブロックボディに完全にエンコードされるのではなく、参照されます。
ボディに完全な内容を埋め込む代わりに、Blobは「サイドカー」として個別に伝播されます。

この「サイドカー」設計は、さらなるデータ増加のための前方互換性を提供します。完全なシャーディングでは、`is_data_available()` をデータ可用性サンプリング(DAS)に置き換えることができ、すべてのBlobがネットワーク上のすべてのビーコンノードによってダウンロードされる必要がなくなります。

コンセンサスレイヤーはデータ可用性のためにBlobを永続化する責任がありますが、実行レイヤーはそうではありません。

`ethereum/consensus-specs` リポジトリでは、このEIPに関連する以下のコンセンサスレイヤーの変更が定義されています:

- ビーコンチェーン: 更新されたビーコンブロックを処理し、Blobが利用可能であることを確認する。
- P2Pネットワーク: 更新されたビーコンブロックタイプと新しいBlobサイドカーをゴシップおよび同期する。
- 誠実なバリデーター: Blobを含むビーコンブロックを生成し、関連するBlobサイドカーに署名して公開する。

### 実行レイヤーの検証

実行レイヤーでは、ブロックの有効性条件が次のように拡張されます:

```python
def validate_block(block: Block) -> None:
    ...

    # 過剰なBlobガスが正しく更新されたことを確認
    assert block.header.excess_blob_gas == calc_excess_blob_gas(block.parent.header)

    blob_gas_used = 0

    for tx in block.transactions:
        ...

        # 十分な残高があることを確認する修正
        max_total_fee = tx.gas * tx.max_fee_per_gas
        if get_tx_type(tx) == BLOB_TX_TYPE:
            max_total_fee += get_total_blob_gas(tx) * tx.max_fee_per_blob_gas
        assert signer(tx).balance >= max_total_fee

        ...

        # Blobトランザクション固有の有効性ロジックを追加
        if get_tx_type(tx) == BLOB_TX_TYPE:
            # 少なくとも1つのBlobが必要
            assert len(tx.blob_versioned_hashes) > 0

            # すべてのバージョン付きBlobハッシュは VERSIONED_HASH_VERSION_KZG で始まる必要がある
            for h in tx.blob_versioned_hashes:
                assert h[0] == VERSIONED_HASH_VERSION_KZG

            # ユーザーが少なくとも現在のBlobベースフィーを支払う意思があることを確認
            assert tx.max_fee_per_blob_gas >= get_base_fee_per_blob_gas(block.header)

            # ブロック内の合計Blobガス消費を追跡
            blob_gas_used += get_total_blob_gas(tx)

    # 合計Blobガス消費が上限以下であることを確認
    assert blob_gas_used <= MAX_BLOB_GAS_PER_BLOCK

    # blob_gas_used がヘッダーと一致することを確認
    assert block.header.blob_gas_used == blob_gas_used
```

### ネットワーキング

Blobトランザクションには2つのネットワーク表現があります。トランザクションゴシップ応答(`PooledTransactions`)では、EIP-2718 `TransactionPayload` のBlobトランザクションがラップされて次のようになります:

```
rlp([tx_payload_body, blobs, commitments, proofs])
```

これらの要素は次のように定義されます:

- `tx_payload_body` - 標準的な EIP-2718 [Blobトランザクション](#blobトランザクション)の `TransactionPayloadBody` です
- `blobs` - `Blob` アイテムのリストです
- `commitments` - 対応する `blobs` の `KZGCommitment` のリストです
- `proofs` - 対応する `blobs` と `commitments` の `KZGProof` のリストです

ノードは `tx_payload_body` を検証し、ラップされたデータをそれに対して検証しなければなりません。そのために以下を確認する必要があります:

- `tx_payload_body.blob_versioned_hashes`、`blobs`、`commitments`、`proofs` の数が等しい
- KZG `commitments` がバージョン付きハッシュにハッシュされる、つまり `kzg_to_versioned_hash(commitments[i]) == tx_payload_body.blob_versioned_hashes[i]`
- KZG `commitments` が対応する `blobs` と `proofs` に一致する(注: これは `verify_blob_kzg_proof_batch` を使って最適化できる。コミットメントとBlob データからランダムな評価ポイントを導出し、各Blobに対するプルーフを使用)

ボディ取得応答(`BlockBodies`)では、標準的な EIP-2718 Blobトランザクション `TransactionPayload` が使用されます。

ノードは Blobトランザクションを自動的にピアにブロードキャストしてはいけません。
代わりに、それらのトランザクションは `NewPooledTransactionHashes` メッセージを使ってのみアナウンスされ、`GetPooledTransactions` を使って手動で要求できます。

## 根拠

### シャーディングへの道のり

このEIPは、最終的なシャーディング仕様で期待されるのと同じ形式でBlobトランザクションを導入します。
これにより、ロールアップに一時的ながらも重要なスケーリング支援を提供し、別個の手数料市場を使用することで、この制度の利用が限定的な間は非常に低い手数料を可能にします。

ロールアップスケーリングの一時的な解決策の主な目的は、ロールアップに追加の開発負担を課すことなく一時的なスケーリング支援を提供することです。
現在、ロールアップはコールデータを使用しています。将来的には、シャーディングデータ(「Blob」とも呼ばれる)を使用することが不可欠になるため、ロールアップはデータを処理する方法を大幅に変更せざるを得なくなります。
したがって、ロールアップは少なくとも1回は道のりの途中でこの大きなアップグレードを行う必要があります。
しかし、私たちができることは、ロールアップがたった1回しかアップグレードする必要がないようにすることです。
これは即座に、一時的な解決策には正確に2つの可能性があることを意味します: (i) 既存のコールデータのガスコストを削減する、(ii) シャーディングデータに使用される形式を前倒しで導入するが、実際にはシャーディングしない。
以前のEIPはすべて(i)のカテゴリの解決策でしたが、このEIPは(ii)のカテゴリの解決策です。

このEIPを設計する際の主な tradeoff は、今後の完全なシャーディングに向けてどの程度の作業を行うかです。
25%の作業を行うか、50%か、75%か?

このEIPですでに行われている作業には以下が含まれます:

- 「完全なシャーディング」で存在する必要があるのと同じ形式の新しいトランザクションタイプ
- 完全なシャーディングに必要な実行レイヤーのロジックのすべて
- 完全なシャーディングに必要な実行/コンセンサス間の相互検証ロジックのすべて
- `BeaconBlock` 検証とデータ可用性サンプリングBlob間のレイヤー分離
- 完全なシャーディングに必要な `BeaconBlock` ロジックのほとんど
- 自己調整可能な独立したBlobベースフィー

完全なシャーディングに到達するために残されている作業には以下が含まれます:

- コミットメントの低次元拡張を行い、2Dサンプリングを可能にする
- データ可用性サンプリング(DAS)の実際の実装
- 個々のバリデーターが1スロットで32MBのデータを処理する必要がないようにするPBS(提案者/ビルダー分離)
- 各バリデーターが各ブロックのシャーディングデータの特定の部分を検証することを要求するプルーフオブカストディや同様のものをプロトコル内に導入する

このEIPはまた、長期的なプロトコルのクリーンアップのための基盤も整えています。たとえば、その(よりきれいな)ガスベースフィー更新ルールを主要なベースフィー計算に適用できます。

### ロールアップの機能

ロールアップブロックデータをトランザクションコールデータに入れる代わりに、ロールアップはロールアップブロックの送信者にデータをBlobに入れることを期待するでしょう。
これにより、可用性が保証されます(ロールアップに必要なもの)が、コールデータよりもはるかに安価になります。
ロールアップには、データが一度利用可能になり、正直なアクターがロールアップの状態を構築できるだけの期間保持されることが必要です。

楽観的ロールアップは、フラウド証明が提出されるときにのみ実際のデータを提供する必要があります。
フラウド証明は、コールデータを介して最大でも数値を読み込みながら、より小さな手順でトランジションを検証できます。
各値について、KZGプルーフを提供し、バージョン付きハッシュに対して点評価プリコンパイルを使用して値を検証し、その後現在のように詐欺証明の検証を実行します。

ZKロールアップは、トランザクションまたは状態デルタデータに2つのコミットメントを提供します。
Blobコミットメント(プロトコルがデータ可用性を指すことを保証する)と、ロールアップ内部で使用されるプルーフシステムを使用したロールアップ独自のコミットメントです。
等価性プルーフプロトコルを使用し、点評価プリコンパイルを使って、2つのコミットメントが同じデータを参照することを証明します。

### バージョン付きハッシュとプリコンパイルの返り値

将来の変更に備えて前方互換性を確保するために、Blobの参照にコミットメントではなくバージョン付きハッシュを使用しています。
たとえば、量子安全性のためにMerkleツリー + STARKsに切り替える必要がある場合、新しいバージョンを追加できます。
これにより、ロールアップがEVMレベルでどのように動作するかを変更する必要がなくなります。
シーケンサーは単に適切な時期に新しいトランザクションタイプに切り替えるだけでよいのです。

ただし、点評価は有限体内で行われ、フィールドのモジュラスが既知の場合にのみ適切に定義されます。スマートコントラクトは、コミットメントのバージョンをモジュラスにマッピングするテーブルを含めることができますが、まだ知られていないモジュラスの将来のアップグレードを考慮することはできません。 EVMの内部でモジュラスにアクセスできるようにすることで、スマートコントラクトは将来のコミットメントとプルーフを使用できるように構築でき、アップグレードの必要がなくなります。

別のプリコンパイルを追加したくないという観点から、モジュラスと多項式の次数を点評価プリコンパイルから直接返します。呼び出し側がこれを使用できます。呼び出し側が返り値の一部を無視しても追加コストがかからないため、「無料」でもあります
- 将来的に予想される範囲でアップグレード可能なシステムは、当面この方法を使用する可能性が高いでしょう。

### Blobガスベースフィー更新ルール

Blobガスベースフィーの更新ルールは、`base_fee_per_blob_gas = MIN_BASE_FEE_PER_BLOB_GAS * e**(excess_blob_gas / BLOB_BASE_FEE_UPDATE_FRACTION)`という式を近似することを目的としています。
ここで `excess_blob_gas` は、「ターゲット」の数(`TARGET_BLOB_GAS_PER_BLOCK` per block)に対して「余分に」消費されたBlobガスの合計量です。
EIP-1559と同様に、自己修正式です。過剰が高くなるにつれ、`base_fee_per_blob_gas` が指数関数的に増加し、使用量を減らし、最終的に過剰を再び下げます。

ブロック単位の動作は大まかに次のようになります。
ブロック `N` が `X` Blobガスを消費した場合、ブロック `N+1` では `excess_blob_gas` が `X - TARGET_BLOB_GAS_PER_BLOCK` だけ増加し、
ブロック `N+1` の `base_fee_per_blob_gas` は `e**((X - TARGET_BLOB_GAS_PER_BLOCK) / BLOB_BASE_FEE_UPDATE_FRACTION)` の因子だけ増加します。
したがって、EIP-1559と同様の効果がありますが、同じ総使用量に対してより「安定」しています。

パラメータ `BLOB_BASE_FEE_UPDATE_FRACTION` は、Blobガスベースフィーの最大変化率を制御します。
`e**(TARGET_BLOB_GAS_PER_BLOCK / BLOB_BASE_FEE_UPDATE_FRACTION) ≈ 1.125` per blockの最大変化率を目標としています。

### スループット

`TARGET_BLOB_GAS_PER_BLOCK` と `MAX_BLOB_GAS_PER_BLOCK` の値は、ブロックあたり3つのBlob(0.375 MB)と最大6つのBlob(0.75 MB)に対応するように選択されています。
これらの小さな初期限界は、このEIPによってネットワークに課される負荷を最小限に抑えることを目的としており、より大きなブロックに対するネットワークの信頼性が実証されるにつれて、将来のアップグレードで増加すると予想されます。

## 下位互換性

### Blobの非アクセス性

このEIPは、メンプールバージョンと実行ペイロードバージョンが明確に異なるトランザクションタイプを導入します。
2つの表現の間には一方向の変換しかありません。Blobはネットワーク表現にあり、コンセンサス表現にはありません。
代わりに、それらはビーコンブロックに結合されています。つまり、web3 APIからアクセスできない部分がトランザクションに存在することになります。

### メンプールの問題

Blobトランザクションはメンプールレイヤーでデータサイズが大きいため、メンプールのDoS攻撃リスクがあります。
ただし、これは大量のコールデータを持つトランザクションにも適用される従来の問題ではありません。

Blobトランザクションのアナウンスのみをブロードキャストすることで、受信ノードはどのトランザクションを受け取るかを制御でき、スループットを許容可能なレベルに抑えることができます。
[EIP-5793](./eip-5793.md)により、`NewPooledTransactionHashes` アナウンスメッセージにトランザクションタイプとサイズを含めることで、ノードにさらに細かい制御が可能になります。

さらに、メンプールのトランザクション置換ルールに1.1倍のBlobガスベースフィー増加要件を含めることをお勧めします。

## テストケース

このEIPの実行レイヤーのテストケースは、`ethereum/execution-spec-tests` リポジトリの [`eip4844_blobs`](https://github.com/ethereum/execution-spec-tests/tree/1983444bbe1a471886ef7c0e82253ffe2a4053e1/tests/cancun/eip4844_blobs) にあります。コンセンサスレイヤーのテストケースは[こちら](https://github.com/ethereum/consensus-specs/tree/2297c09b7e457a13f7b2261a28cb45777be82f83/tests/core/pyspec/eth2spec/test/deneb)にあります。

## セキュリティ上の考慮事項

このEIPは、ビーコンブロックあたりの帯域幅要件を最大で約0.75 MBまで増加させます。
これは現在の理論上の最大ブロックサイズ(30M gas / 16 gas per calldata byte = 1.875M bytes)の40%大きいだけなので、最悪の場合の帯域幅をあまり増加させません。
マージ後は、ブロック時間が静的になるため、予測不可能なポアソン分布ではなく、大きなブロックの伝播に一定の時間が確保されます。

代替案(コールデータコストを削減するもの)と比較すると、このEIPの _持続的な_ 負荷ははるかに低くなります。
これは、これらのBlobを実行ペイロードの履歴と同じように長期間保持する必要がないためです。
具体的には、`MIN_EPOCHS_FOR_BLOB_SIDECARS_REQUESTS` エポック(約18日)の間保持する必要があるという方針を実装できます。
これは、まだ実装されていない1年間の履歴ローテーション時間と比べると大幅に短い遅延です。

## 著作権

著作権およびその関連権利は[CC0](../LICENSE.md)で放棄されています。