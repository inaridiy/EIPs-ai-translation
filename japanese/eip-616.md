---
original: ef0aed471dba36a4a8668c1ada083dcb651cc912ff41c8763574f23e4c94954b
---

---
eip: 616
title: EVMのSIMD演算
author: Greg Colvin <greg@colvin.org>
type: Standards Track
category: Core
status: Stagnant
created: 2017-04-25
---

## 概要

Ethereum Virtual Machine (EVM)に、256ビット幅のスタックアイテムを最大限活用し、ベクトルおよびスカラー演算の大幅なパフォーマンス向上を実現するシングルインストラクション・マルチデータ (SIMD) 型と演算を提供する提案。

## 動機

ほとんどすべての最新CPUにはSIMDハードウェアが搭載されており、レジスタ幅の並列データに対して単一の命令を適用することで、スカラー要素からなるベクトルに対して並列処理を行うことができます。このモデルはEVMの幅広いスタックアイテムに非常によく適合しており、スカラー要素に対する並列演算で大幅なパフォーマンス向上が期待できます。例えば、文献調査の結果、以下のようなSIMDによるスピードアップが確認されています:
* [SHA-512](http://keccak.noekeon.org/sw_performance.html)で最大7倍
* 楕円曲線スカラー乗算で4倍
* [BLAKE2b](https://github.com/minio/blake2b-simd)で3倍から4倍
* [OpenSSL](https://software.intel.com/en-us/articles/improving-openssl-performance)で最大3倍
* 楕円曲線剰余乗算で2倍から3倍
* [SHA-256](https://github.com/minio/sha256-simd)で1.7倍から1.9倍
* [RSA暗号化](https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.738.1218&rep=rep1&type=pdf)で1.3倍

## 仕様

### エンコーディング

SIMDオペレーションを簡単にエンコードするため、2バイトのオペコードを提案します。最初のバイトがオペコード、2番目のバイトがSIMDの型: スカラー型、レーン幅、要素数を表します。

 N ビット | フィールド
-|-
8 | オペコード
1 | スカラー型: 0 = 符号なし整数, 1 = IEEE浮動小数点
1 | 予約済: 0
2 | レーン幅: バイト数のlog2, MSBファースト整数
1 | 予約済: 0
3 | 要素数: レーン数のlog2, MSBファースト整数

これにより、8ビットから64ビットの符号なし整数レーンを持つ32から2要素のベクトルをサポートできます。一方、浮動小数点レーンは32ビットと64ビットのIEEE浮動小数点のみをサポートします。また、_0x7F_はEVM標準の256ビット整数を表します。

_要素数が1の場合、その操作はスカラーに対するものとなるため、この仕様ではネイティブサイズのスカラー演算も提供します。_

_浮動小数点演算は**初期リリースには含まれません**が、将来の拡張のためにコード領域を確保しておくことが重要と考えています。_

### セマンティクス

以下のEVMの算術、論理、比較演算の拡張バージョンを定義します。通常のバージョンと同様に、引数をスタックから取り、結果をスタックに置きますが、引数はスカラーではなくベクトルです。

lo\hi |	B             | C
-|-|-
0|                     | XLT
1| XADD           | XGT
2| XMUL          | XSLT
3| XSUB           | XSGT
4| XDIV            | XEQ
5| XSDIV          | XISZERO
6| XMOD          | XAND
7| XSMOD        | XOR
8|                      | XXOR
9|                       | XNOT
A|                       | XINDEX
B|                       | XSHL
C|                       | XSHR
D|                       | XSAR
E| XCAST           | XROL
F| XSHUFFLE      | XROR

XSHUFFLE、XCAST、XINDEXを除き、符号なし整数値に対するすべての拡張操作は、コード01から1Fに対応する操作と同じセマンティクスを持ちますが、モジュロは型によって異なり、操作はソース演算子の要素ごとに並列に適用されます。_ソース演算子は同じ要素型と要素数を持たなければなりません。_例えば:
```
PUSH uint8[1, 2, 3]
PUSH uint8[4, 5, 6]
XADD
```
は
```
uint8[5, 7, 9]
```
をスタックに残します。

XSHUFFLEは、スタックにあるシャッフルするベクトルと、シャッフルマスクの2つのベクトルを取ります。例えば:
```
PUSH uint64[4, 5, 6, 0]
PUSH uint8[2, 0, 1, 3]
SHUFFLE
```
は
```
uint64[6, 4, 5 , 0]
```
をスタックに残します。マスクは整数型で、ソースベクトルと同じ要素数を持たなければなりません。

XCASTのオペコードの2番目のバイトは、スタックにあるアイテムを指定された型の新しいベクトルに変換するために使用されます。要素は通常のC言語の変換規則に従って変換され、不足している要素はゼロに設定され、余分な要素は破棄されます。スタックアイテムがベクトルでない場合は、ビットを最下位ビットから最上位ビットの順に取り出し、各要素の対応するビットに格納することで、ベクトルに変換されます。ここでも、余分なデータは切り捨てられ、不足しているデータはゼロで埋められます。ベクトルは256ビットのEVM整数に逆変換されますが、浮動小数点のNANは全ビットオンに正規化されます。

_MLOADとMSTOREは256ビットのEVM整数にのみ有効です。SIMDベクトルの場合は、ロード後にXCASTが必要で、ストア前にXCASTが必要です。_

XINDEXは、BYTEと同じセマンティクスを持ちますが、ベクトルの個々の要素がインデックスされます。

浮動小数点値はIEEE 754のセマンティクスに従います。シフトや回転はIEEE 754では定義されていないため、ここでは何も効果がないものと定義されます。

XSHUFFLEとXCASTを除く拡張操作は、同じSIMD型のベクトルにのみ有効です。これは、コントラクト作成時に検証するか、実行時にチェックする必要があります。

### サブルーチン

[EIP-187](https://github.com/ethereum/EIPs/pull/187)が受け入れられた場合、ベクトル引数を取るサブルーチンを宣言するための型安全な構文が必要になります。

* `BEGINSUBX n_args, arg_types... n_results, result_types...`
はサブルーチンの**唯一**のエントリポイントを示します。`n_args`個のアイテムがスタックから取り出され、`n_results`個のアイテムがスタックに返されます。`n_args`と`n_results`は1バイトの即値で指定されます。`arg_types`と`result_types`は、SIMDオペコードの2番目のバイトと同じエンコーディングで指定され、スタックの値と一致する必要があります。サブルーチンのバイトコードは、次の`BEGINSUB`、`BEGINSUBX`または`BEGINDATA`命令、またはバイトコードの終端で終わります。

## 根拠

現在、SIMD ハードウェアの最小公倍数 (Intel SSE2、ARM Neon など) は16バイトレジスタで、1、2、4、8バイトの整数レーンと4、8バイトの浮動小数点レーンをサポートしています。より最近のSIMDハードウェア (Intel AVX など) は32バイトレジスタをサポートしており、EVM スタックアイテムも32バイト幅です。上記の制限は、利用可能なハードウェアの範囲内でEVMコードを維持するためのものであり、予約ビットは将来の拡張のために確保されています。

ほとんどの最新言語 (Rust、Python、Go、Java、C++など) のコンパイラは、並列化可能なループに対してSIMDコードを生成したり、SIMDハードウェアへの明示的なアクセスのためのイントリンシックやライブラリを提供したりすることができます。したがって、ポータブルなソフトウェア実装でも、ハードウェアを効果果的に活用できるはずです。また、利用可能な場合はイントリンシックやライブラリを使用することができます。したがって、要素サイズや要素数に関わらず、ほぼ同じ (または128ビットハードウェアで256ビットベクトルの場合は最大2倍) の実行時間が期待できます。

### ガス代

これらの演算を導入する1つの動機は、より小さなスカラーに対して低いガス代を設定することです。

64ビットレジスタを持つマシンでは、Knuthの[コンピュータプログラミングの技術](https://library.aceondo.net/ebooks/Computer_Science/algorithm-the_art_of_computer_programming-knuth.pdf)の標準アルゴリズムでは32ビットの桁を使用し、オーバーフロー用に上位ビットを使用します。したがって、256ビット値の場合はN=8桁、64ビット値の場合はN=2桁が必要です。これらのアルゴリズムのサイクル数は以下の通りです:

操作 | サイクル数 | N = 2 | N = 4 | N = 8
-|-|-|-|-
加算 | 10 _N_ + 6 | 26 | 46 | 86
減算 | 12 _N_ + 3 |27 | 51 | 99
乗算 | 28 _N_**2 + 11 _N_ + 3 | 137 | 495 |1883
除算 | 15 _N_**2 + 119 _N_ + 111 | 409 | 827 | 2023

その他の操作は加算・減算と同程度の複雑さ、あるいはそれ以下です。JUMPDEST は no-op で、ガス代が1に設定されているため、これをインタプリタのオーバーヘッドとみなすことができます。算術演算のすべてが同じガス代の5に設定されているため、残りのランタイムは4となります。インタプリタループ自体は6～8個のC命令で構成されるため、ADDとSUBは妥当な価格付けですが、MULは ADDやSUBの5～21倍遅く、DIVは15～23倍遅いため、明らかに過小評価されています。

一方、ほとんどの[Intel](https://software.intel.com/sites/landingpage/IntrinsicsGuide)および[ARM](https://developer.arm.com/docs/100166/latest/programmers-model/instruction-set-summary/table-of-processor-instructions) SIMDユニットでは、レジスタ幅に関係なく、およそ以下のサイクル数で命令が実行されます。

操作 | Intel サイクル数 | ARM サイクル数 | ガス代
-|-|-|-
加算 | .5 | 1 | 1
減算 | .5 | 1 | 1
乗算 | 2 | 1 | 1
除算 | 10 | 12 | 2

除算を除くすべての操作がインタプリタのオーバーヘッドよりも少ないサイクル数で実行されるため、最小コストの1に設定されます。除算はやや多くのサイクルを要するため、コストを2に設定しています。