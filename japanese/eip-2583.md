---
original: bc8ef9e625da4d81fc9c0f4f0d503981e20486931e296412a1afcb57c28bb70f
---

---
eip: 2583
title: アカウントトライ欠落に対するペナルティ
author: Martin Holst Swende (@holiman)
discussions-to: https://ethereum-magicians.org/t/eip-2583-penalties-for-trie-misses/4190
status: 停滞
type: Standards Track
category: Core
created: 2020-02-21
---


## 簡単な要約

このEIPは、アカウントトライに存在しないアドレスにアクセスするオペコードにガスペナルティを導入します。

## 概要

このEIPは、アカウントトライにアクセスする際に、アドレスが存在しない場合にガスペナルティを追加します。存在しないアカウントは、キャッシュメカニズムを回避するため、「通常」の実行モードと「最悪の場合」の実行モードの間に大きな差異を生み出すことができ、DoS攻撃に使用できます。

## 動機

イーサリアムのトライがより飽和状態になるにつれ、ノードが状態にアクセスするために行う必要のあるディスクルックアップの数も増加しています。これは、たとえば`ブロック5`のアカウントの`EXTCODEHASH`をチェックするのが、`8.5M`のときよりも本質的に安価な操作であることを意味します。

実装の観点から、ノードはこの問題に対処するためにさまざまなキャッシングメカニズムを使用できますが、キャッシュにはある固有の問題があります。キャッシュが「ヒット」したときは素晴らしいですが、「ミス」したときは役に立ちません。

これは攻撃可能です。ノードに存在しないキーを探索させることで、ディスクルックアップの数を最大化できます。
脇注: 「非存在」がキャッシュされていても、次回は別の存在しないキーを使用すれば、同じ存在しないキーに再度ヒットすることはありません。したがって、「非存在」のキャッシングは危険かもしれません。キャッシュに「良い」エントリが追い払われる可能性があるためです。

これまでこの問題に対処するための試みは、ガスコストの引き上げでした。例えば[EIP-150](./eip-150.md)、[EIP-1884](./eip-1884.md)などです。

ただし、ガスコストを決定する際、「幸せなパス」と「悪名高いパス」の間の大きな差異により、別の問題が生じます。

- 「幸せなパス」、つまりすべてのアイテムがキャッシュされていると仮定した場合?
  - そうすると、すべてのトライアクセスが過小評価されてしまい、DoS攻撃の対象となる可能性があります。
- 実際の使用状況に基づく「通常」の使用量?
  - これが現在の方法ですが、意図的に悪名高い実行が過小評価されてしまい、DoS脆弱性となります。
- 「極端な」ケース: キャッシングが存在しないと仮定してすべてを価格付けする?
  - これにより、ほとんどすべてのコントラクトに深刻な影響を与えるガスコストの増加が生じます。また、同じ計算量を許可するためにガス制限が引き上げられた場合、悪名高いケースがまたDoS攻撃に使用される可能性があります。

エンジニアリングの観点から、ノードの実装者には以下のようなオプションしかありません。

- ブルームフィルターを使用して存在を確認する。これは難しい問題で、特に再編成の問題や、ブルームフィルターの変更を元に戻すのが難しいという問題があります。
- フラット化されたアカウントデータベースを実装する。これも難しい問題で、再編成の問題と、コンセンサスのために`trie`が必要であるという問題があります。つまり、約`15G`の追加のデータ構造を管理する必要があります。現在、Gethチームがこの方法を追求しています。

このEIPは、この状況を緩和するメカニズムを提案します。

## 仕様

定数`penalty`を`TBD`(提案`2000`ガス)と定義します。

アカウントトライにアクセスするオペコードの場合、`address`がトライに存在しない場合、`penalty`ガスが利用可能な`gas`から差し引かれます。

### 詳細仕様

これらのオペコードは、メインのアカウントトライへのルックアップをトリガーします。

| オペコード | 影響あり | コメント |
| -----  | ---------| ----------|
| BALANCE| はい      | `balance(nonexistent_addr)`は`penalty`を発生させる |
| EXTCODEHASH| はい      | `extcodehash(nonexistent_addr)`は`penalty`を発生させる |
| EXTCODECOPY| はい      | `extcodecopy(nonexistent_addr)`は`penalty`を発生させる |
| EXTCODESIZE| はい      | `extcodesize(nonexistent_addr)`は`penalty`を発生させる |
| CALL | はい| コールバリアントの詳細については以下を参照 |
| CALLCODE | はい| コールバリアントの詳細については以下を参照 |
| DELEGATECALL | はい| コールバリアントの詳細については以下を参照 |
| STATICCALL | はい| コールバリアントの詳細については以下を参照 |
| SELFDESTRUCT | いいえ| 以下の詳細を参照 |
| CREATE   | いいえ | 作成先は明示的に設定できず、既に存在しないと想定される |
| CREATE2  | いいえ | 作成先は明示的に設定できず、既に存在しないと想定される |

### コール派生の注意点

`CALL`は`CALL`の宛先アドレスのルックアップをトリガーします。`CALL`の基本コストは`700`ガスです。その他の特性によって、コールの実際のガスコストが決まります。

1. `CALL`(または`CALLCODE`)が値を転送する場合、追加の`9K`ガスが追加されます。
    1.1 `CALL`の宛先が以前から存在しなかった場合、さらに`25K`ガスが追加されます。

このEIPは以下のように2番目のルールを追加します。

2. 値の転送がなく、かつ呼び出し先が存在しない場合、`penalty`ガスが追加されます。

以下の表で、
- `value`は非ゼロの値転送を意味し、
- `!value`はゼロ値転送を意味し、
- `dest`は宛先が既に存在するか`precompile`であることを意味し、
- `!dest`は宛先が存在せず`precompile`でもないことを意味します。

| Op | value,dest| value, !dest |!value, dest| !value, !dest|  
| -- | ---------  | -- | --| -- |
|CALL |  変更なし | 変更なし| 変更なし| `penalty`|
|CALLCODE |  変更なし | 変更なし| 変更なし| `penalty`|
|DELEGATECALL | N/A | N/A| 変更なし| `penalty` |
|STATICCALL | N/A | N/A| 変更なし| `penalty` |

このEIPのルールが、`transactions`内の通常のイーサ送金にも適用されるかどうかはTBDです。これについては「後方互換性」のセクションでさらに議論します。

### `SELFDESTRUCT`に関する注意

`SELFDESTRUCT`オペコードも`受益者`のアカウントトライルックアップをトリガーしますが、以下の理由から`penalty`は適用されません。`SELFDESTRUCT`は既に`5K`ガストを消費するためです。

### 明確化:

- オペコードの`base`コストは、このEIPによって変更されません。
- `SELFBALANCE`オペコードは、`self`アドレスが存在するかどうかに関係なく、このEIPの対象外です。

## 根拠

このスキームにより、これらの操作を「通常」の使用に基づいて価格付けを続けつつ、ディスクルックアップ/キャッシュミスを最大化しようとする攻撃から保護できます。
このEIPはストレージトライアクセスに関する変更は行いませんが、将来のEIPで関連する可能性があります。ただし、いくつかの重要な違いがあります。

1. ストレージトライは通常小さく、アカウントトライと同程度の密度でストレージトライを埋めるのは高コストです。
2. 攻撃者が既存の大きなストレージトライ、たとえば人気のあるトークンを使用したい場合、通常は`CALL`を行ってそのトークンのルックアップを引き起こす必要があります。`token.balanceOf(<nonexistent-address>)`のようなものです。
   これには追加のガス障壁がかなりあり、`CALL`ごとに`700`ガスが加算され、さらに引数のガスも必要になります。

### `penalty`の決定

`10M`ガスのトランザクションは現在、約`14K`のトライルックアップを引き起こすことができます。

- `penalty`が`1000`の場合、数を約`5800`に減らすことができ、元の`41%`になります。
- `penalty`が`2000`の場合、数を約`3700`に減らすことができ、元の`26%`になります。
- `penalty`が`3000`の場合、数を約`2700`に減らすことができ、元の`20%`になります。
- `penalty`が`4000`の場合、数を約`2100`に減らすことができ、元の`15%`になります。

`penalty`には上限があります。`penalty`は`gas`から差し引かれるため、悪意のあるコントラクトは常に悪意のあるリレーを呼び出してトライルックアップを行うことができます。これを「シールドされたリレー」攻撃と呼びます。

このようなシナリオでは、`malicious`は各`relay`呼び出しに`~750`ガスを費やし、トライアクセスを行うために`relay`に少なくとも`700`ガスを提供する必要があります。

したがって、実効的なコストは`1500`程度になります。`penalty`が`~800`を超えても、トライミス攻撃に対する保護は改善されないと論じることができます。

## 後方互換性

このEIPにはハードフォークが必要です。

### イーサ転送

EOAからEOAへの通常の`transaction`(値あり)は影響を受けません。

値が`0`の`transaction`で、宛先が存在しない場合は影響を受けます。このシナリオは非常に起こりにくいと考えられます。なぜなら、そのような`transaction`は無意味であり、成功しても`gas`を少し消費するだけだからです。このEIPでは、さらに`penalty`ガスを消費する可能性があります。

### レイヤー2

レイヤー2の後方互換性については、オペコードの`base`コストを変更するEIPよりもはるかに影響が小さいと考えられます。状態アクセスの場合、

1. コントラクトが別のコントラクト`b`の`BALANCE`/`EXTCODEHASH`/`EXTCODECOPY`/`EXTCODESIZE`をチェックし、
2. そのような`b`が存在しない場合でも実行を続ける

といった正当なシナリオはほとんどありません。

#### Solidityリモートコール
Solidityでリモートコールを行う例:
```
    recipient.invokeMethod(1)
```

- Solidityは`recipient`の`EXTCODESIZE`の事前チェックを行います。
- 事前チェックが`0`を返す場合、`revert(0,0)`が実行され、実行が停止します。
- 事前チェックが0以外を返す場合、実行が続き`CALL`が行われます。

このEIPが適用された場合、「幸せなパス」は以前と同様に機能し、`recipient`が存在しない「悪名高いパス」では`penalty`ガスが追加で消費されますが、実行フローは変わりません。

#### ERC223

[ERC223 Token Standard](https://github.com/ethereum/EIPs/issues/223)は、執筆時点では「Draft」とマークされていますが、メインネットで展開されており使用されています。

ERC223では、トークンの`transfer(_to,...)` メソッドが呼び出されると:

> この関数は、トークンを転送し、`_to`がコントラクトの場合は`tokenFallback (address, uint256, bytes)`関数を呼び出す必要があります。
> ...
> 注: `_to`がコントラクトかアドレスかを確認する推奨方法は、`_to`のコードをアセンブルすることです。`_to`にコードがない場合は外部所有アドレスであり、そうでない場合はコントラクトです。

[Dexaran](https://github.com/Dexaran/ERC223-token-standard/tree/development/token/ERC223)と[Open
Zeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/1bc923b6a222e79a90f20305a459b0ee779eb918/contracts/token/ERC721/ERC721.sol#L499)の参照実装の両方が、`isContract`チェックに`EXTCODESIZE`呼び出しを使用しています。

この場合は_影響を受ける可能性がありますが、実際には影響を受けないはずです。可能性を考えてみましょう。

1. `_to`がコントラクトの場合: ERC223では`tokenFallback(...)`関数が呼び出されるように指定されています。
    - その呼び出しのガス消費は最小でも`700`ガスです。
    - コールを実行できるようにするには、最良の実践として呼び出し先に`2300`ガスを一緒に渡す必要があります。
   - 要約すると: このパスには少なくとも`3000`の余分なガスが必要です(これは`penalty`によるものではありません)
2. `_to`は存在しますが、コントラクトではありません。ここで処理が終了し、このEIPの影響を受けません。
2. `_to`は存在しません: `penalty`が差し引かれます。

要約すると、`penalty`が約`3000`ガスを超えない限り、ERC223は影響を受けないと考えられます。

### その他

[`Dentacoin`](https://etherscan.io/address/0x08d32b0da63e2c3bcf8019c9c5d849d7a9d791e6#code)コントラクトが影響を受けます。

```
    function transfer(address _to, uint256 _value) returns (bool success) {
    ... // 省略
        if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {               // 送信者が十分な残高を持っており、オーバーフローがないことを確認
            balances[msg.sender] = safeSub(balances[msg.sender], _value);   // 送信者からDCNを減らす

            if (msg.sender.balance >= minBalanceForAccounts && _to.balance >= minBalanceForAccounts) {    // 送信者がガスを支払え、受信者も最小残高を持っていることを確認
                balances[_to] = safeAdd(balances[_to], _value);             // 受信者にDCNを追加
                Transfer(msg.sender, _to, _value);                          // この転送が行われたことを通知
                return true;
            } else {
                balances[this] = safeAdd(balances[this], DCNForGas);        // コントラクトにDCNForGasを支払う
                balances[_to] = safeAdd(balances[_to], safeSub(_value, DCNForGas));  // 受信者の残高からDCNForGasを引く
                Transfer(msg.sender, _to, safeSub(_value, DCNForGas));      // この転送が行われたことを通知

                if(msg.sender.balance < minBalanceForAccounts) {
                    if(!msg.sender.send(gasForDCN)) throw;                  // 送信者にイーサを送る
                  }
                if(_to.balance < minBalanceForAccounts) {
                    if(!_to.send(gasForDCN)) throw;                         // 受信者にイーサを送る
                }
            }
        } else { throw; }
    }
```    

このコントラクトは`_to.balance >= minBalanceForAccounts`をチェックし、残高が低すぎる場合は`DCN`をイーサに変換して送信します。これは新しいユーザーが`DCN`を受け取ったらすぐにトランザクションを作成できるようにするためのメカニズムです。

このEIP適用前:

- 存在しないアドレスに`DCN`を送信する場合、追加のガス消費は以下のようになります:
  - イーサ転送に`9000`
  - 新しいアカウント作成に`25000`
  - (`2300`は後に呼び出し元に返金される)
  - 合計ランタイムガスコストは`34K`ガスが必要でした。

このEIP適用後:

- `34K`に加えて`penalty`が追加されます。
    - 実装では残高チェックが2回行われるため、2つの`penalty`が適用される可能性があります。
- 合計ランタイムガスコストは`34K+penalty`(または`34K + 2 * penalty`)が必要になります。

この`2-3K`ガスの追加ペナルティは、他の`34K`ガスと比べれば限定的であると考えられます。

## テストケース

以下のケースを考慮し、テストする必要があります。

- 新しいコントラクトの作成時、コンストラクタ内で自アドレスに関する呼び出しには`penalty`が適用されないこと。
- TBD: 同一呼び出しコンテキスト、同一トランザクション、同一ブロック内で`selfdestruct`された場合の`penalty`の適用方法
  - a) 同一呼び出しコンテキスト内
  - b) 同一トランザクション内
  - c) 同一ブロック内
  `EXTCODEHASH(destructed)`、`CALL(destructed)`、`CALLCODE(destructed)`などの場合

- 値が`0`の`transaction`が存在しないアカウントに送信された場合の影響

## セキュリティ上の考慮事項

「後方互換性」のセクションを参照してください。

## 実装

まだ利用できません。

## 代替案

### 代替案1: インスタント払い戻し

すべてのトライアクセスに`penalty`を追加します。`EXTCODEHASH`は`700`ではなく`2700`になります。
- トライアクセスが既存のアイテムにヒットした場合、即座に`penalty`(`2K`)を払い戻す

メリット:

- 「シールドされたリレー」攻撃を排除できる

デメリット:

- 多くのオペレーション(CALL/EXTCODEHASH/EXTCODESIZE/STATICCALL/EXTCODESIZE等)の事前コストが増加する
  - 多くのコントラクトが破損する可能性がある

### 代替案2: 親コンテキストへの引き継ぎ

`penalty`を説明したとおりに使用しますが、子コンテキストが`penalty`でOOGになった場合、残りを親コンテキストから引き継ぐ(再帰的に)

メリット:

- 「シールドされたリレー」攻撃を排除できる

デメリット:

- 子コンテキストに割り当てられた`gas`によって制限されるという現在の不変条件が破られる
  - ただし、新しい不変条件は`gas + penalty`によって制限されるということになる
- これは「雑然とした」と見なされる可能性がある - 一部のOOG(ペナルティ)のみが呼び出し元に渡されるが、メモリの過剰割り当てなどの他のOOGは渡されない。ただし、以下の違いはある:
  - まだ消費されていないリソースに起因するガスコストは親に渡されない。例えば: ガスが不足している場合、巨大な割り当ては実際に行われない
  - 既に消費されたリソースに起因するガスコストは親に渡される。この場合、トライの反復に対するペナルティが事後的に支払われる

## 著作権
著作権およびそれに関連する権利は[CC0](../LICENSE.md)によって放棄されています。