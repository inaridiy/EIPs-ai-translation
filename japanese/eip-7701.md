---
original: 3be145e3970c3dc0126c9da60b5848d382152f17aab473f4252a653e415afcca
---

---
eip: 7701
title: EOF を利用したネイティブアカウントアブストラクション
description: RIP-7560 トランザクションの変種で、EOF スマートコントラクトアカウントに依存しています
author: Vitalik Buterin (@vbuterin), Yoav Weiss (@yoavw), Alex Forshtat (@forshtat), Dror Tirosh (@drortirosh), Shahaf Nacson (@shahafn)
discussions-to: https://ethereum-magicians.org/t/eip-7701-native-account-abstraction-with-eof/19893
status: Draft
type: Standards Track
category: Core
created: 2024-05-01
requires: 3540
---

## 概要

このプロポーザルは、RIP-7560 で完全に説明されているネイティブアカウントアブストラクションデザインの少しの変種を説明しています。
この版の違いは、検証コードセクションと実行コードセクションを区別するために "EVM オブジェクトフォーマット" の機能に依存していることです。

## 動機

ネイティブアカウントアブストラクションについて話すと、どんな解決策も対処しなければならない根本的な考えは、スマートコントラクトアカウントが検証コードセクションと実行コードセクションを分離するためのメカニズムです。

RIP-7560 は現在のイーサリアムコントラクト構造に基づいているため、より高レベルの抽象化を使用せざるを得ません。

現在の形式では、RIP-7560 トランザクションはこの分離を達成するためにソリディティメソッドセレクタを使用しています。

しかし、これは理想的ではありません。なぜなら、このアプローチは広く使用されている EVM 向けのプログラミング言語の概念をイーサリアムプロトコルの中核設計に "漏らして" しまうからです。

純粋な技術的理由でこれを禁止することはできず、ソリディティコードがすでにイーサリアムプロトコルに "刻み込まれている" 例もありますが、このようなアブストラクションレベルの違反は多くの場合、不必要な技術的負債につながるため、可能であれば避けるべきです。

さらに、メソッドセレクタは、ネイティブアカウントアブストラクショントランザクションフローに参加するコントラクト開発者の決定を示す非常に弱い指標を提供します。
偶然に4バイトのメソッド識別子を持つ関数を公開し、ネイティブアカウントアブストラクションを承認する有効な4バイトのマジックを返す可能性は低いですが、悪意のある開発者がそのような関数を無害な名前で隠すことは簡単で、ネイティブアカウントアブストラクションエンティティを見つけるのが難しくなります。

この問題は、ある程度 [ERC-4337](./eip-4337.md) にも存在します。

代替案として、ネイティブアカウントアブストラクションが [EIP-3540](./eip-3540) と連携して実装される場合、それが導入する "コードセクション" の概念に依存するのは優れたアプローチです。

## 仕様

### システムレベルのコードエントリポイント

EOF コンテナフォーマットを次のセクションで構成するように変更します:

```
container := header, body
header :=
    magic, version,
    kind_types, types_size,
    kind_entrypoints, entrypoints_size,
    kind_code, num_code_sections, code_size+,
    [kind_container, num_container_sections, container_size+,]
    kind_data, data_size,
    terminator
body := types_section, entrypoints_section, code_section+, container_section*, data_section
types_section := (inputs, outputs, max_stack_height)+
entrypoints_section := (entrypoints_role, target_section_index, target_section_pc_offset)+
```

コントラクトへの通常の呼び出しの場合、実行は常にコードセクション0の最初のバイトから始まり、pcは0に設定されます。

ここで `entrypoints_section` は、システムコールの実行に対して別のコードセクションインデックスを定義します。
これは `entrypoints_role` の範囲内の特別な役割の実行に予約されています。

注意: `EntryPoint` コントラクト (ERC-4337 で定義) とコード実行 `entrypoint` を混同しないでください。

### 検証とPostTransactionコードエントリポイント

アカウントアブストラクショントランザクションの参加者として機能する可能性のあるコントラクトには、次のいずれかの `entrypoints_role` マーカーを持つセクションが含まれている必要があります:

```
role_sender_execution = 0x0000
role_sender_deployment = 0x0001
role_sender_validation = 0x0002
role_paymaster_validation = 0x0003
role_paymaster_posttx = 0x0004
```

このセクションはコードセクションと同等です。

そのコードは通常のトランザクション実行中に実行できますが、特別な効果はありません。
最初のコードセクションである場合は、通常のトランザクション実行中のエントリポイントとして機能できます。

1つのロールあたり1つのセクションしか許可されません。
この規則は、コントラクト作成時に検証されます。

### アカウントアブストラクショントランザクションタイプ参加エンティティ (Sender、Paymaster、Deployer) の実行エントリポイント

通常のコントラクトコード実行中、その動作は EIP-3540 によって次のように定義されます:

```
実行は常にコードセクション0の最初のバイトから始まり、pcは0に設定されます
```

ただし、コントラクトが `AA_TX_TYPE` トランザクションでSender、Paymaster、またはDeployerとして参照される場合、実行は現在のステップに対応する `entrypoints_role` マーカーを持つコードセクションの最初のバイトから始まり、`pc`は対応する `target_section_pc_offset` に設定されます。

指定されたコントラクトにそのようなセクションがない場合、またはEOFコントラクトでない場合、そのトランザクションは無効とみなされます。

### 異なる実行フレームへの入力のエンコーディング

#### Sender Deployment

`deployer` コントラクトへの入力はプロトコルによって定義されておらず、`deployerData` パラメータによって制御されます。

Sender展開フレームは、`sender` アドレスがコントラクトコードで初期化されることを必ず結果としなければなりません。

このステップは `role_sender_validation` コードセクションで実行されます。

#### Sender Validation

`Sender` 検証セクションへの入力は、プロトコルによって `chainId` と `accessList` フィールドを除いたトランザクションデータのSSZエンコーディングと、追加の `txHash` フィールドとして定義されています:

```
ssz([
  subtype,
  sender, nonce, builderFee,
  callData,
  paymaster, paymasterData,
  deployer, deployerData,
  maxPriorityFeePerGas, maxFeePerGas,
  validationGasLimit, paymasterValidationGasLimit,
  callGasLimit, paymasterPostOpGasLimit
  signature, txHash
]
```

このステップは `role_sender_deployment` コードセクションで実行されます。

トランザクションが有効と見なされるためには、
Sender検証フレームが次の2つの64ビット値を返す必要があります:

```
ssz(bool success, uint64 validUntil, uint64 validAfter)
```

#### Paymaster Validation

`Paymaster` 検証セクションへの入力は、[Sender Validation](#sender-validation) ステップと同じです。

このステップは `role_paymaster_validation` コードセクションで実行されます。

トランザクションが有効と見なされるためには、
Paymaster検証フレームが次の値を返す必要があります:

```
ssz(uint64 validUntil, uint64 validAfter, bytes context)
```

#### Sender Execution

このステップは `role_sender_execution` コードセクションで実行されます。

`Sender` コントラクトへの入力はプロトコルによって定義されておらず、`callData` パラメータによって制御されます。

#### Paymaster post-transaction フレーム

Paymaster post-transactionへの入力は、次のデータのSSZエンコーディングとして定義されています:

```
ssz([uint256 actualGasCost, bool success, bytes context])
```

このステップは `role_paymaster_posttx` コードセクションで実行されます。

## 根拠

### システムフレームの入出力データのSSZエンコーディング

SSZエンコーディング形式をプロトコル自体によって提供されるデータに使用することは、アブストラクションレベルの違反を表していますが、これは比較的安全であり、代替案にはいくつかのトレードオフが伴います。

スマートコントラクトアカウントコードの検証セクションは、トランザクションを受け入れるか拒否するかについて十分な情報に基づいた決定を下すために、ほとんどのトランザクション詳細にフル アクセスする必要があります。

この情報の一部は既存のオペコードで利用可能ですが、すべてのトランザクションパラメータに対してオペコードを作成するのは現実的ではありません。

ウォレットが独自のエンコーディングを指定することも現実的ではありません。なぜなら、スマートコントラクトアカウントは受信データの意味に関する曖昧さを避ける必要があるためです。

## 下位互換性

`kind_entrypoints` セクションを持つEOFコントラクトは、EIP-3540に従って有効ではなく、このプロポーザルが実装される前にはオンチェーンに存在できません。

`kind_entrypoints` の導入により、コントラクトコードに単一の実行開始ポイントしかないという前提が破られる可能性があり、この前提に依存するいくつかの開発者ツールが混乱する可能性があります。

## セキュリティ上の考慮事項

`kind_entrypoints` セクションを持つコントラクトは、ネイティブアカウントアブストラクションエンティティとしての役割を明示的に示しています。
これは、エンティティが明示的にマークされていない ERC-4337 や RIP-7560 に比べて大幅な改善です。

`kind_entrypoints` コードセクションは、コントラクトに代わってあらゆるアクションを承認する一般的な方法を表しているため、このコードの正しくて安全な実装が非常に重要です。
EVM をターゲットとするコンパイラが、スマートコントラクトアカウントのセキュリティを可能にし、確保するのに大きな役割を果たすことが期待されます。

## 著作権

著作権およびそれに関連する権利は [CC0](../LICENSE.md) で放棄されています。