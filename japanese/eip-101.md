---
original: 992af43df86e9f58d0ef3c690c5f27ffaa72351569223be36e402f3fd6c669a6
---

---
eip: 101
title: Serenity通貨とクリプト抽象化
author: Vitalik Buterin (@vbuterin)
status: 停滞
type: Standards Track
category: Core
created: 2015-11-15
---

### 仕様

1. アカウントのRLP(Recursive Length Prefix)エンコーディングには、**code**と**storage**の2つのフィールドしかなくなりました。
2. Etherはもはやアカウントオブジェクトに直接格納されません。代わりに、アドレス`0`にすべてのEther保有高を含むコントラクトがプリマインされます。web3の`eth.getBalance`コマンドは適切に再マッピングされます。
3. `msg.value`というオペコードは存在しなくなりました。
4. トランザクションには、**to**、**startgas**、**data**、**code**の4つのフィールドしかありません。
5. RLPの有効性チェックと、**to**フィールドが20バイトであること、**startgas**が整数であること、**code**が空か**to**アドレスのハッシュであることを確認する以外は、有効性の制約はありません。ただし、ブロックガスリミットは残るため、ジャンクを含むトランザクションをマイナーが含めるインセンティブはありません。
6. **code**のバイトに対してもデータと同じレートでガスが課金されます。
7. トランザクションが送信されると、受信アカウントがまだ存在しない場合は、アカウントが作成され、そのコードはトランザクションで提供されたコードに設定されます。それ以外の場合は、コードは無視されます。
8. `tx.gas`オペコードが`0x5c`のインデックスで`msg.gas`に追加されました。このオペコードにより、トランザクションはトランザクションに割り当てられた元のガス量にアクセスできるようになります。

`ECRECOVER`、シーケンス番号/ノンス増分、Etherは、この下位レベルの仕様には含まれていないことに注意してください(注:Etherは、Casper PoSで特権的な役割を果たし続けます)。新しいモデルの下で既存の機能を複製するには、以下のようにします。

シンプルなユーザーアカウントには、次のようなデフォルトの標準化されたコードを持つことができます:

```python
# データが次のスキーマに従うと仮定します:
# バイト0-31: v (ECDSAシグネチャ)
# バイト32-63: r (ECDSAシグネチャ)
# バイト64-95: s (ECDSAシグネチャ)
# バイト96-127: シーケンス番号(以前は"ノンス"と呼ばれていた)
# バイト128-159: ガス価格
# バイト172-191: to
# バイト192+: data

# トランザクション署名のハッシュを取得
~mstore(0, msg.gas)
~calldatacopy(32, 96, ~calldatasize() - 96)
h = sha3(96, ~calldatasize() - 96)
# ECRECOVERコントラクトを呼び出して送信者を取得
~call(5000, 3, [h, ~calldataload(0), ~calldataload(32), ~calldataload(64)], 128, ref(addr), 32)
# 送信者の正しさをチェック
assert addr == 0x82a978b3f5962a5b0957d9ee9eef472ee55b42f1
# シーケンス番号の正しさをチェック
assert ~calldataload(96) == self.storage[-1]
# シーケンス番号をインクリメント
self.storage[-1] += 1
# サブコールを行い、出力を破棄
~call(msg.gas - 50000, ~calldataload(160), 192, ~calldatasize() - 192, 0, 0)
# ガス代を支払う
~call(40000, 0, [SEND, block.coinbase, ~calldataload(128) * (tx.gas - msg.gas + 50000)], 96, 0, 0)
```

これは、署名とノンスのチェックを実装しており、両方のチェックが通過した場合は、残りのガスから50000を引いた分を使って実際の呼び出しを行い、最後にガス代を支払います。

マイナーは、トランザクションを受け取ったときに次のアルゴリズムに従うことができます:

1. 最大50000ガスでコードを実行し、その制限を超えそうなオペレーションやコールを見つけたら停止する
2. その操作を見つけたら、少なくとも50000ガスが残るようにする(静的なガス消費が十分に小さいことを確認するか、`msg.gas - 50000`をガスリミットパラメータとするコールであることを確認する)
3. 最後のガス支払いコードが上記のコードと*まったく同じ*であることをパターンマッチする

このプロセスにより、トランザクションを含めるかどうかを知る前に最大50000ガスを無駄にするだけで済み、新しい暗号アルゴリズム(ed25519、Lamportなど)、リングシグネチャ、準ネイティブマルチシグなどを実験するのにも非常に一般的に使えます。理論的には、有効なシグネチャの種類がレシートのMerkleブランチであるアカウントを作成することで、準ネイティブアラームクロックを作成することもできます。

ゼロ以外の値を持つトランザクションを送信したい場合は、現在の`msg.sender`アプローチの代わりに、3段階のプロセスでコンパイルします:

1. 呼び出しの直前の外部スコープで、希望の金額のチェックを作成するためにEtherコントラクトを呼び出す
2. 内部スコープで、呼び出される関数内で`msg.value`オペコードが使用されている場合は、関数呼び出しの開始時にチェックをキャッシュアウトし、キャッシュアウトした金額を標準化されたアドレスにメモリに格納する
3. 呼び出しの直後の外部スコープで、チェックがまだキャッシュアウトされていない場合は、Etherコントラクトにメッセージを送信してチェックを無効化する

### 根拠

これにより、特に次の分野での一般性の大幅な向上が可能になります:

1. アカウントのセキュリティに使用される暗号アルゴリズム(Etherはクアンタムセーフであると合理的に言えるようになり、Lamportシグネチャでアカウントをセキュアにすることができる)。ノンス増分アプローチも、アカウント保有者による改訂が可能になり、k並列可能なノンス手法、UTXOスキーム等の実験が可能になります。
2. Etherを抽象化レベルの上に移動することで、Etherとサブトークンを同様に扱えるようになる
3. カスタムポリシーアカウント(マルチシグなど)に必要な間接レベルを削減

また、基礎となるEthereum プロトコルを大幅に単純化・純化し、最小限のコンセンサス実装の複雑さを減らすことができます。

### 実装

近日公開予定。