---
original: 491e6afa5695e0f9a5df1e0a2009cc928a5bd938aab8b39e6187b8127c7810d2
---

---
eip: 4788
title: EVMにおけるビーコンブロックルート
description: EVMにビーコンチェーンルートを公開する
author: Alex Stokes (@ralexstokes), Ansgar Dietrichs (@adietrichs), Danny Ryan (@djrtwo), Martin Holst Swende (@holiman), lightclient (@lightclient)
discussions-to: https://ethereum-magicians.org/t/eip-4788-beacon-root-in-evm/8281
status: Final
type: Standards Track
category: Core
created: 2022-02-10
requires: 1559
---

## 概要

各ビーコンチェーンブロックのハッシュツリールートをそれぞれの実行ペイロードヘッダーにコミットする。

これらのルートをスマートコントラクトに格納する。

## 動機

ビーコンチェーンブロックのルートは、任意のコンセンサス状態の証明を可能にする暗号学的アキュムレータです。
これらのルートをEVM内で公開することで、コンセンサス層へのトラストレス(信頼最小)アクセスが可能になります。
この機能は、ステーキングプール、再ステーキング構造、スマートコントラクトブリッジ、MEV緩和策などの幅広いユースケースをサポートします。

## 仕様

| 定数                         | 値                                          |
|---                           |---                                           |
| `FORK_TIMESTAMP`             | `1710338135`                                          |
| `HISTORY_BUFFER_LENGTH`      | `8191`                                       |
| `SYSTEM_ADDRESS`             | `0xfffffffffffffffffffffffffffffffffffffffe` |
| `BEACON_ROOTS_ADDRESS`       | `0x000F3df6D732807Ef1319fB7B8bB8522d0Beac02` |

### 背景

基本的な考え方は、各実行ブロックにその親ビーコンブロックのルートが含まれているということです。スロットが欠落した場合でも、前のブロックのルートは変更されないため、このような"オラクル"を各実行ブロックで表現するのに、常に一定量のスペースしか必要ありません。このオラクルの使いやすさを向上させるため、ブロックルートの小さな履歴がコントラクトに格納されます。

このコンストラクションが消費するストレージ量を制限するため、コンセンサス層のブロックルートアキュムレータを反映するリングバッファが使用されます。

### ブロック構造と有効性

`FORK_TIMESTAMP`以降の実行タイムスタンプから始まり、実行クライアントは**必ず**ヘッダースキーマに追加のフィールド`parent_beacon_block_root`を含めなければなりません。
このルートは32バイトを消費し、対応する実行ブロックの親ビーコンブロックの[ハッシュツリールート](https://github.com/ethereum/consensus-specs/blob/fa09d896484bbe240334fa21ffaa454bafe5842e/ssz/simple-serialize.md#merkleization)と完全に一致します。

その結果、ヘッダーのRLP(Recursive Length Prefix)エンコーディングは以下のようになります:

```python
rlp([
    parent_hash,
    0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347, # ommers hash
    coinbase,
    state_root,
    txs_root,
    receipts_root,
    logs_bloom,
    0, # difficulty
    number,
    gas_limit,
    gas_used,
    timestamp,
    extradata,
    prev_randao,
    0x0000000000000000, # nonce
    base_fee_per_gas,
    withdrawals_root,
    blob_gas_used,
    excess_blob_gas,
    parent_beacon_block_root,
])
```

親ビーコンブロックルートの有効性は、引き出しの処理と同様に、コンセンサス層から保証されます。

ブロックを検証する際、実行クライアントは**必ず**ブロックヘッダーのルート値がコンセンサスクライアントから提供されたものと一致することを確認しなければなりません。

ジェネシスブロックには親ビーコンブロックルートが存在しないため、32バイトのゼロが使用されます。

#### ビーコンルートコントラクト

ビーコンルートコントラクトには2つの操作があります: `get`と`set`。入力自体は、どの関数を実行するかを決定するために使用されません。その代わり、`caller`の結果が使用されます。`caller`が`SYSTEM_ADDRESS`と等しい場合は`set`操作を実行します。それ以外の場合は`get`を実行します。

##### `get`

* 呼び出し側は、32バイトの大エンディアンフォーマットでエンコードされた`timestamp`を提供します。
* 入力が32バイトではない場合、コントラクトはリバートしなければなりません。
* 入力が0と等しい場合、コントラクトはリバートしなければなりません。
* 与えられた`timestamp`から、`timestamp % HISTORY_BUFFER_LENGTH`を計算してストレージインデックスを求め、その値を読み取ります。
* `timestamp`が一致しない場合、コントラクトはリバートしなければなりません。
* 最後に、ユーザーにタイムスタンプに関連付けられたビーコンルートを返します。これは`timestamp % HISTORY_BUFFER_LENGTH + HISTORY_BUFFER_LENGTH`に格納されています。

##### `set`

* 呼び出し側は、親ビーコンブロックルートをコントラクトのコールデータとして提供します。
* `header.timestamp % HISTORY_BUFFER_LENGTH`のストレージ値を`header.timestamp`に設定します。
* `header.timestamp % HISTORY_BUFFER_LENGTH + HISTORY_BUFFER_LENGTH`のストレージ値を`calldata[0:32]`に設定します。

##### 擬似コード

```python
if evm.caller == SYSTEM_ADDRESS:
    set()
else:
    get()

def get():
    if len(evm.calldata) != 32:
        evm.revert()

    if to_uint256_be(evm.calldata) == 0:
        evm.revert()

    timestamp_idx = to_uint256_be(evm.calldata) % HISTORY_BUFFER_LENGTH
    timestamp = storage.get(timestamp_idx)

    if timestamp != evm.calldata:
        evm.revert()

    root_idx = timestamp_idx + HISTORY_BUFFER_LENGTH
    root = storage.get(root_idx)

    evm.return(root)

def set():
    timestamp_idx = to_uint256_be(evm.timestamp) % HISTORY_BUFFER_LENGTH
    root_idx = timestamp_idx + HISTORY_BUFFER_LENGTH

    storage.set(timestamp_idx, evm.timestamp)
    storage.set(root_idx, evm.calldata)
```

##### バイトコード

コントラクトのバイトコードを以下に示します。

```asm
caller
push20 0xfffffffffffffffffffffffffffffffffffffffe
eq
push1 0x4d
jumpi

push1 0x20
calldatasize
eq
push1 0x24
jumpi

push0
push0
revert

jumpdest
push0
calldataload
dup1
iszero
push1 0x49
jumpi

push3 0x001fff
dup2
mod
swap1
dup2
sload
eq
push1 0x3c
jumpi

push0
push0
revert

jumpdest
push3 0x001fff
add
sload
push0
mstore
push1 0x20
push0
return

jumpdest
push0
push0
revert

jumpdest
push3 0x001fff
timestamp
mod
timestamp
dup2
sstore
push0
calldataload
swap1
push3 0x001fff
add
sstore
stop
```

#### デプロイ

ビーコンルートコントラクトは、他のスマートコントラクトと同様にデプロイされます。目的のデプロイトランザクションから逆算して、特殊な合成アドレスが生成されます:

```json
{
  "type": "0x0",
  "nonce": "0x0",
  "to": null,
  "gas": "0x3d090",
  "gasPrice": "0xe8d4a51000",
  "maxPriorityFeePerGas": null,
  "maxFeePerGas": null,
  "value": "0x0",
  "input": "0x60618060095f395ff33373fffffffffffffffffffffffffffffffffffffffe14604d57602036146024575f5ffd5b5f35801560495762001fff810690815414603c575f5ffd5b62001fff01545f5260205ff35b5f5ffd5b62001fff42064281555f359062001fff015500",
  "v": "0x1b",
  "r": "0x539",
  "s": "0x1b9b6eb1f0",
  "hash": "0xdf52c2d3bbe38820fff7b5eaab3db1b91f8e1412b56497d88388fb5d4ea1fde0"
}
```

注意: トランザクションの入力には、目的のランタイムコードに前置するシンプルなコンストラクタがあります。

トランザクションの送信者は`0x0B799C86a49DEeb90402691F1041aa3AF2d3C875`と計算できます。最初のコントラクトがこのアカウントからデプロイされるアドレスは`rlp([sender, 0])`で、これは`0x000F3df6D732807Ef1319fB7B8bB8522d0Beac02`に等しくなります。これが`BEACON_ROOTS_ADDRESS`を決定する方法です。このようなコントラクト作成スタイルは、create2のようにイニシャルコードに固有のものではありませんが、合成アドレスはトランザクションの入力データ(例えばイニシャルコード)に暗号学的に結び付けられています。

### ブロック処理

`block.timestamp >= FORK_TIMESTAMP`の実行ブロックを処理する際、最初に`BEACON_ROOTS_ADDRESS`を`SYSTEM_ADDRESS`として呼び出し、32バイトの入力`header.parent_beacon_block_root`、ガス制限`30_000_000`、値`0`を渡します。これにより、ビーコンルートコントラクトの`set()`ルーチンがトリガーされます。これはシステム操作なので:

* 呼び出しは完了しなければならない
* 呼び出しはブロックのガス制限に含まれない
* 呼び出しは[EIP-1559](./eip-1559.md)の燃焼セマンティクスに従わない - 呼び出しの一部として値は転送されるべきではない
* `BEACON_ROOTS_ADDRESS`にコードが存在しない場合、呼び出しは静かに失敗しなければならない

クライアントは、明示的なEVM呼び出しを省略し、ストレージ値を直接設定することを選択できます。注意: これはイーサリアムメインネットでは有効な最適化ですが、別のコントラクトが使用される非メインネットの状況では問題になる可能性があります。

このEIPがジェネシスブロックで有効な場合、ジェネシスヘッダーの`parent_beacon_block_root`は`0x0`でなければならず、システムトランザクションは発生しません。

## 根拠

### なぜ`BLOCKHASH`を流用しないのか?

`BLOCKHASH`オペコードをビーコンルートの提供に再利用することができます。
コードの変更を最小限に抑え、スマートコントラクトへの破壊的変更を避け、メインネットへの展開を簡素化するため、このEIPでは`BLOCKHASH`を変更せず、目的のセマンティクスを持つ新しい機能を追加することを提案しています。

### ステートルートではなくビーコンブロックルート

各新しい実行ブロックで一定量の作業しか必要ないため、ブロックルートがステートルートよりも好ましいです。そうでなければ、スキップされたスロットでは、各新しいペイロードで線形量の作業が必要になります。メインネットでスキップされたスロットはかなり稀ですが、すでに好ましくない条件下で追加の負荷を加えないことが最善です。

ステートルートではなくブロックルートを使用することで、証明にいくつかの追加ノードが必要になりますが、この費用は無視できます(また、すべての消費者で償却できる可能性があります。例えば、スロットごとにプルーフをキャッシュするシングルトンステートルートコントラクトなど)。

### なぜ2つのリングバッファなのか?

最初のリングバッファは`HISTORY_BUFFER_LENGTH`分のルートのみを追跡するため、可能なすべてのタイムスタンプ値に対して一定量のストレージを消費します。
ただし、この設計では、リングバッファの長さで剰余が同じスキップされたスロットが攻撃者によって利用され、最新のルート値ではなく古いルート値が返される可能性があります。

この攻撃を無効化しつつ、固定のメモリフットプリントを維持するため、このEIPでは`(parent_beacon_block_root, timestamp)`のペアをリングバッファの各インデックスに保持し、読み取り時にタイムスタンプが元の書き込み時と一致することを確認し
ます。ストレージスロットのサイズが固定されている(32バイトのみ)ため、2つのリングバッファを保持する必要があります。

### リングバッファのサイズ

リングバッファのデータ構造は、コンセンサス層から8191個のルートを保持するように設計されています。素数をリングバッファのサイズとすることで、リングバッファ全体が飽和するまでは任意の値が上書きされず、その後は各値が1回更新されることが保証されます。これにより、スロット時間が変更された場合でも、最大8191個のストレージスロットしか使用しないことが確実になります。

現在のメインネットの値を考えると、8191個のルートは約1日分のカバレッジを提供します。これにより、ユーザーは特定のルートに対する検証を行い、トランザクションをオンチェーンに含めるのに十分な時間を確保できます。

## 後方互換性

問題はありません。

## テストケース

N/A

## 参考実装

N/A

## セキュリティ上の考慮事項

N/A

## 著作権

著作権およびその関連権利は[CC0](../LICENSE.md)で放棄されています。