---
original: 3011db8793c578e9fac9c8abcf23cb4fce7460ee847ec9a41e6aa6b5b065c421
---

---
eip: 5
title: `RETURN`と`CALL*`のガス使用量
author: Christian Reitwiessner <c@ethdev.com>
status: 最終版
type: 標準トラック
category: コア
created: 2015-11-22
---

### 概要

このEIPにより、文字列や他の動的サイズの配列を返す関数を呼び出すことができるようになります。
現在、Ethereum仮想マシンの内部から別のコントラクト/関数を呼び出す場合、出力のサイズを事前に指定する必要があります。
もちろん、より大きなサイズを指定することはできますが、書き込まれていないメモリに対してもガスを支払う必要があるため、動的サイズのデータを返すことは非常に高価で柔軟性に欠けており、実際にはほとんど使えません。

このEIPで提案されているソリューションは、`CALL`が返される時に実際に書き込まれたメモリに対してのみガスを請求するというものです。

### 仕様

`CALL`、`CALLCODE`、`DELEGATECALL`(後に`CALL*`と呼ばれる)のガスとメモリのセマンティクスは以下のように変更されます(`CREATE`はメモリに書き込まないため影響を受けません):

`CALL*`の引数が`gas, address, value, input_start, input_size, output_start, output_size`であると仮定すると、オペコードの開始時に、メモリの成長に対するガスは`input_start + input_size`にのみ課金され、`output_start + output_size`には課金されません。

呼び出されたコントラクトが`n`サイズのデータを返す場合、呼び出し元のコントラクトのメモリは`output_start + min(output_size, n)`まで拡張され(呼び出し元はそのためのガスを支払う)、出力は`[output_start, output_start + min(n, output_size))`の範囲に書き込まれます。

呼び出し元のコントラクトは、オペコードの開始時と終了時の両方でガス不足になる可能性があります。

呼び出し後、`MSIZE`オペコードは実際に拡張されたメモリサイズを返すべきです。

### 動機

一般的に、呼び出しの出力用にメモリ領域を予約しておくことは良い習慣です。なぜなら、サブルーチンに任意のメモリ領域に書き込ませるのは危険かもしれないからです。一方で、呼び出しを行う前に出力サイズを知ることは often 難しい: データは通常アクセスできない別のコントラクトのストレージにあり、そのサイズを知るには別の呼び出しが必要になるからです。

さらに、実際に書き込まれていないメモリ領域に対してガスを請求するのは無駄です。

この提案は両方の問題を解決しようとしています: 呼び出し元は自分のメモリ領域の最後に巨大な領域を用意することができます。被呼び出し側はそこに"書き込む"ことで返答し、呼び出し元は実際に書き込まれた領域に対してのみガスを支払うことになります。

これにより、文字列や動的サイズの配列などの動的データを非常に柔軟に返すことができるようになります。返されたデータのサイズを判断することも可能です: 呼び出し元が`output_start = MSIZE`と`output_size = 2**256-1`を使う場合、実際に書き込まれた領域は`(output_start, MSIZE)`(ここで`MSIZE`は呼び出し後に評価される)になります。これは重要です。なぜなら、呼び出し側のインターフェースを知らずに他のコントラクトを呼び出し、その出力を単に返すような"プロキシ"コントラクトを実現できるからです。そのためには、(1)出力サイズを事前に知る必要がなく、(2)呼び出し後に出力サイズを判断できることが重要です。

### 根拠

この問題に取り組む方法は、Ethereum仮想マシンに最小限の変更を加えるものです。同様の目的を達成するための他の手段では、オペコード自体や引数の数を変更する必要がありました。また、`output_size`が`2**256-1`と等しい場合にのみガスの仕組みを変更するという提案もありましたが、メモリを`CALL`の周りの2つの時点で拡張する必要があるという主要な実装上の難しさを解決するものではありませんでした。

以前の段階では、返されたデータのサイズをスタックに追加することも提案されていましたが、上述の`MSIZE`メカニズムで十分であり、後方互換性も高いと考えられます。

https://github.com/ethereum/EIPs/issues/8にいくつかのコメントがあります。

### 後方互換性

この提案はコントラクトのセマンティクスを変更するため、ガスカウンターとメモリサイズにアクセスするコントラクトに影響を与える可能性があります。

ただし、以下の理由から、既存のコントラクトがこの変更の影響を受けることはまれだと考えられます:

ガス:

VMはこれまでよりも多くのガスを請求することはありません。通常、コントラクトはガスが少なくなっても動作が変わらないように書かれています。もしガスが増えた場合、サブコールに対するガス見積もりが厳しいコントラクトが out-of-gas になる可能性がありますが、その場合はより多くのガスを呼び出し元に返すだけになります。

メモリサイズ:

`MSIZE`オペコードは通常、以前使われていないメモリ領域を割り当てるために使われます。
このセマンティクスの変更は既存のコントラクトに2つの影響を与えます:

1. メモリ割り当ての重複: `CALL`を使うことで、コントラクトは呼び出された側が実際に書き込まない領域も割り当てようとしていた可能性があります。この変更により、その割り当て領域が以前より小さくなるため、後続の`MSIZE`を使ったメモリ割り当てが重複する可能性があります。しかし、そのようなコントラクトが存在する可能性は低いと考えられます。

2. メモリアドレスの変化: 一般的に、`MSIZE`を使ってメモリを割り当てる場合、変更後はメモリ内のオブジェクトのアドレスが異なることになります。ただし、コントラクトはメモリ内のオブジェクトが"再配置可能"、つまりメモリ上の絶対位置や他のオブジェクトとの相対位置に依存しないように書かれるべきです。もちろん、配列の場合はこれが当てはまりませんが、配列は単一の割り当てで行われ、中間の`CALL`は行われません。

### 実装

VMの実装者は、呼び出しの終了時と、まだ十分なガスが残っているかどうかのチェック後にのみメモリを拡張するよう気をつける必要があります。このEIPの典型的な使用例は、出力用に`2**256-1`バイトのメモリを"予約"することです。

Pythonの実装:

  旧: http://vitalik.ca/files/old.py
  新: http://vitalik.ca/files/new.py