---
original: ab171bc6d0a9e8dd906626802b9fbf2b06efbd0af0f99cc5bb8cd77815fac9ae
---

---
eip: 7706
title: コールデータ用の別のガスタイプの作成
description: コールデータ用の別のベースフィーとガスリミットの作成
author: Vitalik Buterin (@vbuterin)
discussions-to: https://ethereum-magicians.org/t/eip-7706-create-a-separate-basefee-and-gaslimit-for-calldata/19998
status: Draft
type: Standards Track
category: Core
created: 2024-05-13
requires: 1559, 4844
---

## 概要

トランザクションのコールデータ用に新しいガスタイプを追加する。`max_basefee`と`priority_fee`をベクトルとして提供する新しいトランザクションタイプを追加する。ベースフィーの調整を、3つのガスタイプすべてに対して同じメカニズムを使用するように変更する。

## 動機

Ethereumのガスリミットを引き上げたり、コールデータを安価にしたり、[EIP-4844](./eip-4844.md)のblob数を増やしたりすることに反対する主な論点は、Ethereumブロックの理論上の最大サイズがすでに大きすぎ、これ以上増やすことはできないということです。しかし、ここには非効率性があります。現在のブロックの平均サイズ(blobs除く)は約100kBで、理論上の最大は`30,000,000 / 16 = 1,875,000`バイトです(ゼロバイトを多用すれば、さらに大きなブロックを作ることができますが、実際にはsnappyの圧縮により1.87百万バイト未満になります)。理想的には、平均的にコールデータがより安価になるような方法で、最大サイズを制限することができるはずです。

このEIPは、EIP-4844で適用された同じテクニックを採用することで、まさにこれを実現します。コールデータ用に別個のフィー市場を導入し、別個のベースフィーと別個のブロックあたりのガスリミットを設けます。ブロックのコールデータの理論上の最大サイズが大幅に減少しますが、基本的な経済分析によると、平均的にはコールデータがかなり安価になると考えられます。

このEIPはまた、3種類のmax-basefeeとpriority feeをベクトルとして含む新しいトランザクションタイプを導入し、3種類のガスすべてを同じコードパスで処理できるようにします。また、現在EIP-1559で実行ガス用に、EIP-4844でblob用に別々のメカニズムを使っているベースフィーの調整を、3種類のガスすべてに同じアプローチを使うように変更します。これにより、ベースフィーの調整ルールが単純化され、EIP-4844のより強力な数学的性質が3種類のガスすべてをカバーするようになります。

## 仕様

このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、「OPTIONAL」は、RFC 2119に記載されているように解釈されるものとします。

### パラメータ

* `FORK_BLKNUM` = `TBD`
* `NEW_TX_TYPE` = `TBD`
* `CALLDATA_GAS_PER_TOKEN` = `4`
* `TOKENS_PER_NONZERO_BYTE` = `4`
* `CALLDATA_GAS_LIMIT_RATIO` = `4`
* `LIMIT_TARGET_RATIOS = [2, 2, 4]`
* `MIN_BASE_FEE_PER_GAS = 1` # EIP-4844 MIN_BASE_FEE_PER_BLOB_GAS の名称変更
* `BASE_FEE_UPDATE_FRACTION = 8` # EIP-4844のパラメータとほぼ一致

### 新しいトランザクションタイプ

`FORK_BLOCK_NUMBER`以降、新しい[EIP-2718](./eip-2718.md)トランザクションが導入され、`TransactionType` = `TX_TYPE(NEW_TX_TYPE)`となります。

この[EIP-2718](./eip-2718.md) `TransactionPayload`は以下のようになります:

```
[chain_id, nonce, gas_limit, to, value, data, access_list, blob_versioned_hashes, max_fees_per_gas, priority_fees_per_gas, y_parity, r, s]
```

`max_fees_per_gas`と`priority_fees_per_gas`は長さ3のベクトルであり、それぞれの要素は`0`から`2**64-1`の整数である必要があります。

新しいトランザクションの固有コストは、EIP-4844から継承されますが、コールデータガスコスト(ゼロバイトあたり4、ゼロ以外のバイトあたり16)は除去されます。

### ブロック処理とトランザクション手数料

`get_max_fees`と`get_priority_fees`の関数を追加し、以前のトランザクションタイプでこれらの長さ3のベクトルを計算します:

```
def get_max_fees(tx: Transaction) -> [int, int, int]:
    if tx.type == NEW_TX_TYPE:
        return tx.max_fees_per_gas
    elif tx.type == BLOB_TX_TYPE:
        return [tx.max_fee_per_gas, tx.max_fee_per_blob_gas, tx.max_fee_per_gas]
    elif is_eip_1559(tx.type):
        return [tx.max_fee_per_gas, 0, tx.max_fee_per_gas]
    else:
        return [tx.gasprice, 0, tx.gasprice]
```

```
def get_priority_fees(tx: Transaction) -> [int, int, int]:
    if tx.type == NEW_TX_TYPE:
        return tx.priority_fees_per_gas
    elif tx.type == BLOB_TX_TYPE:
        return [tx.max_priority_fee_per_gas, 0, tx.max_priority_fee_per_gas]
    elif is_eip_1559(tx.type):
        return [tx.max_priority_fee_per_gas, 0, tx.max_priority_fee_per_gas]
    else:
        return [tx.gasprice, 0, tx.gasprice]
```

ヘルパー関数も追加します:

```
def all_less_or_equal(v1: [int, int, int], v2: [int, int, int]) -> bool:
    return all(x <= y for x, y in zip(v1, v2))

def vector_add(v1: [int, int, int], v2: [int, int, int]) -> [int, int, int]:
    return [x+y for x, y in zip(v1, v2)]

def vector_subtract(v1: [int, int, int], v2: [int, int, int]) -> [int, int, int]:
    return [x-y for x, y in zip(v1, v2)]

def vector_subtract_clamp_at_zero(v1: [int, int, int], v2: [int, int, int]) -> [uint, uint, uint]:
    return [x-y if x >= y else 0 for x, y in zip(v1, v2)]

def vector_mul(v1: [int, int, int], v2: [int, int, int]) -> [int, int, int]:
    return [x*y for x, y in zip(v1, v2)]
```

```
# 現在のコールデータ価格付けのルールと同じですが、言い換えたもの(EIP-7623と似た言語)
def get_calldata_gas(calldata: bytes) -> int:
    tokens = calldata.count(0) + (len(calldata) - calldata.count(0)) * TOKENS_PER_NONZERO_BYTE
    return tokens * CALLDATA_GAS_PER_TOKEN
```

```
def get_gaslimits(tx: Transaction) -> [int, int, int]:
    if tx.type == NEW_TX_TYPE:
        return [tx.gaslimit, len(tx.blob_versioned_hashes) * GAS_PER_BLOB, get_calldata_gas(tx.data)]
    elif tx.type == BLOB_TX_TYPE:
        return [tx.gaslimit, len(tx.blob_versioned_hashes) * GAS_PER_BLOB, get_calldata_gas(tx.data)]
    elif is_eip_1559(tx.type):
        return [tx.gaslimit, 0, get_calldata_gas(tx.data)]
    else:
        return [tx.gaslimit, 0, get_calldata_gas(tx.data)]
```

```
def get_fees_per_gas(tx: Transaction, block_basefees: [int, int, int]) -> [int, int, int]:
    max_fees = get_max_fees(tx)
    priority_fees = get_priority_fees(tx)
    output = []
    # EIP-1559およびEIP-4844と同様のフィー十分性チェック
    require(all_less_or_equal(block_basefees, max_fees))
    # EIP-1559およびEIP-4844と同様のロジック
    return [
        min(basefee + priority_fee, max_fee)
        for block_basefee, max_fee, priority_fee in zip(block_basefees, max_fees, priority_fees)
    ]
```

```
get_block_gaslimits(block: Block) -> [int, int, int]:
    return [block.gaslimit, MAX_BLOB_GAS_PER_BLOCK, block.gaslimit // CALLDATA_GAS_LIMIT_RATIO]
```

**ブロック処理の開始時**:

* `gas_used_so_far`ベクトルを`[0, 0, 0]`で初期化する

**トランザクション処理の開始時**:

* `fees_per_gas = get_fees_per_gas(tx, get_block_basefees(block))`と`tx_gaslimits = get_gaslimits(tx)`を計算する
* `all_less_or_equal(vector_add(gas_used_so_far, tx_gaslimits), block.gas_limits)`が成立することを確認する
* `tx.origin`アカウントから`sum(vector_mul(fees_per_gas, tx_gaslimits))`ウェイを差し引く

`get_block_basefees(block)`はまだ定義されていません。下記のセクションで定義します。`block.gas_limits`フィールドも下記のセクションで定義します。

**トランザクション処理の終了時**:

* `tx_gas_consumed`を3要素のベクトルとして計算する。最初の要素はトランザクション実行で実際に消費されたガス量、2番目と3番目は`get_gaslimits(tx)`の値と一致する
* `sum(vector_mul(fees_per_gas, vector_sub(tx_gaslimits, tx_gas_consumed)))`をtx.originアカウントに返金する(実際には、最初の項目のみが非ゼロになる)
* `gas_used_so_far = vector_add(gas_used_so_far, tx_gas_consumed)`を設定する

**ブロック処理の終了時**:

* `block.gas_used = gas_used_so_far`であることを要求する

`block.gas_used`フィールドは下記のセクションで定義します。

### ブロック構造:

`BlockHeader`フィールドを更新し、`blob_gas_used`、`gas_used`、`base_fee_per_gas`、`gas_limit`、`excess_blob_gas`フィールドを削除し、新しいフィールド`gas_limits`、`gas_used`、`excess_gas`を追加します。その結果のRLP エンコーディングは以下のようになります:

```
rlp([
    parent_hash,
    0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347, # ommers hash
    coinbase,
    state_root,
    txs_root,
    receipts_root,
    logs_bloom,
    0, # difficulty
    number,
    timestamp,
    extradata,
    prev_randao,
    0x0000000000000000, # nonce
    withdrawals_root,
    gas_limits,
    gas_used,
    excess_gas
])
```

以下のように定義します:

```
get_block_gas_targets(parent: Header) -> [int, int, int]:
    return [limit // target_ratio for limit, target_ratio in zip(parent.gas_limits, LIMIT_TARGET_RATIOS)]
```

`excess_gas`値は以下のように計算します:

```
def calc_excess_gas(parent: Header) -> [int, int, int]:
    return vector_subtract_clamp_at_zero(vector_add(parent_excess, parent_used), get_block_gas_targets(parent))
```

`gas_limits`は以下のように計算します:

* `gas_limits[0]`は既存の調整式に従う必要がある
* `gas_limits[1]`は`MAX_BLOB_GAS_PER_BLOCK`に等しくなる
* `gas_limits[2]`は`gas_limits[0] // CALLDATA_GAS_LIMIT_RATIO`に等しくなる

次に、`get_block_basefees`を定義します:

```
def get_block_basefees(parent: Header) -> [int, int, int]:
    return [
        fake_exponential(
            MIN_BASE_FEE_PER_GAS,
            excess_gas,
            target * BASE_FEE_UPDATE_FRACTION
        )
        for (excess_gas, target) in zip(parent.excess_gas, get_block_gas_targets(parent))
    ]
```
        
## 根拠

### ガス関連のメカニクス全てをベクトル化すること

これにより、ガスを処理するのと同じロジックを、3種類のガスすべてに適用できるようになります。その結果、ガスタイプの総数が2から3に増えたにもかかわらず、プロトコルのガス処理ロジックは全体としてシンプルになったと言えます。


### ターゲット比

実行ガスとblobsのターゲット比は2に設定されています。コールデータのターゲット比は4に設定されています。これにより、コールデータが実際にリミットに達するシナリオが大幅に減少し、EIPの経済的影響を和らげます。なぜなら、「リミット以下」の条件下でのEIP-1559スタイルのフィー市場の分析は、「リミットに達した」条件下よりもはるかに単純だからです。さらに、大量のコールデータを必要とするアプリケーションが完全に機能しなくなるリスクも低減されます。

現在のパラメータでは、ブロックあたりのコールデータターゲットを187,500バイトに設定しています。これは現在の平均の約2倍です。基本的な供給-需要の論理から考えると、このEIPの結果、コールデータがかなり安価になると考えられます。

## 下位互換性

以前のトランザクションタイプでは、コールデータのベースフィーとプライオリティフィーが等しくなるように設定されていました。コールデータガスコストは現在と同一に意図的に設定されており、ガスターゲットも現在の使用状況に似ているため、2つのフィーを等しくするのは合理的な近似と考えられます。実際には、新しいトランザクションタイプの方が優れているため、ユーザーはそちらに移行していくと期待されます。しかし、古いスタイルのトランザクションを使うユーザーが被る損失は大きくはありません。なぜなら、プライオリティフィーはベースフィーに比べて一般的に小さく、ユーザーが支払う金額はベースフィーに比例するためです。

## セキュリティ上の考慮事項

このEIPにより、ブロックビルディングの最適な動作が複雑になります。特に、ブロックが一方または両方のガスタイプで満杯になる境界条件下では顕著です。しかし、実際には90%以上のブロックが満杯未満であり、単純な「貪欲アルゴリズム」でも十分に最適に近い結果が得られると主張します。したがって、例えばMEV抽出などの既存のリスクに比べ、独自のブロックビルディングアルゴリズムの中央集権化リスクはそれほど大きくないと考えられます。

## 著作権

著作権およびそれに関連する権利は[CC0](../LICENSE.md)により放棄されています。