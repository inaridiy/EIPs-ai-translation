---
original: 4460ad966a22d8501e12d75165c2c784c61748d8128229f115ebac1bfccac59f
---

---
eip: 1559
title: ETH 1.0 チェーンのための手数料市場の変更
author: Vitalik Buterin (@vbuterin)、Eric Conner (@econoar)、Rick Dudley (@AFDudley)、Matthew Slipper (@mslipper)、Ian Norden (@i-norden)、Abdelhamid Bakhta (@abdelhamidbakhta)
discussions-to: https://ethereum-magicians.org/t/eip-1559-fee-market-change-for-eth-1-0-chain/2783
status: 最終
type: 標準トラック
category: コア
created: 2019-04-13
requires: 2718, 2930
---

## 簡単な要約
一定のブロックあたりのネットワーク手数料を焼却し、一時的な混雑に対処するためにブロックサイズを動的に拡大/縮小する取引価格付けメカニズム。

## 概要
[EIP-2718](./eip-2718.md)の新しい取引タイプを導入します。フォーマットは `0x02 || rlp([chain_id, nonce, max_priority_fee_per_gas, max_fee_per_gas, gas_limit, destination, amount, data, access_list, signature_y_parity, signature_r, signature_s])` です。

プロトコル内に1ガスあたりの基本手数料があり、親ブロックのガス使用量と親ブロックのガスターゲット(ブロックガスリミットをエラスティシティ乗数で割ったもの)に基づいて、ブロックごとに上下に移動します。
このアルゴリズムにより、ブロックがガスターゲットを上回ると基本手数料が上がり、下回ると下がります。
基本手数料は焼却されます。
取引では、トランザクションをマイナーに含めてもらうためのインセンティブとして、最大優先手数料を指定します(優先手数料)。
取引では、合計で支払う最大手数料も指定します(最大手数料)。これには、基本手数料と優先手数料の両方が含まれます。
送信者は常に、自分の取引が含まれたブロックの基本手数料を支払い、取引に指定した優先手数料も支払います。ただし、両者の合計が取引の最大手数料を超えない場合に限ります。

## 動機
Ethereumは従来、単純な入札メカニズムを使ってトランザクション手数料を価格付けしていました。ユーザーがトランザクションに入札(「ガス価格」)を送信し、マイナーが最高入札のトランザクションを選択するというものです。これには以下のような大きな非効率性がありました:

* **取引手数料水準の変動と取引の社会的コストのミスマッチ**: 成熟したパブリックブロックチェーンでは、トランザクションを含めるための入札が極端に変動します。1ナノETHあたりのコストが10倍になったからといって、ブロックに1つ多くのトランザクションを受け入れるネットワークの負荷が10倍になるわけではありません。両方の場合、差は800万ガスと802万ガスの違いにすぎません。
* **ユーザーの不要な遅延**: ブロックあたりのガスリミットと取引量の自然な変動により、トランザクションがいくつかのブロックを待たされることがありますが、これは社会的に生産的ではありません。ある1ブロックが大きく、次のブロックが小さくなることで需要の変動に対応できるようなスラック機構がないのは問題です。
* **第一価格入札の非効率性**: 現在のアプローチでは、取引送信者が最大手数料を入札し、マイナーが最高入札のトランザクションを選択し、すべてが入札した額を支払います。これは機構設計の文献で非常に非効率であると知られており、複雑な手数料推定アルゴリズムが必要になります。しかし、これらのアルゴリズムでも十分に機能せず、頻繁な手数料の過剰支払いが発生します。
* **報酬がない場合のブロックチェーンの不安定性**: 長期的には、発行がない(ビットコインやZcashなど)ブロックチェーンは、トランザクション手数料のみでマイナーに報酬を与えることを意図しています。しかし、これには多くの問題があり、「姉妹ブロック」を採掘してトランザクション手数料を盗もうとする攻撃ベクトルが強くなるなど、かなりの不安定性を招くと考えられます。現時点では、これを緩和する良い方法はありません。

このEIPの提案は、プロトコルによって上下に調整される基本手数料額から始めるものです。ネットワークがターゲットのガス使用量を超えると、基本手数料がわずかに上がり、容量が下回ると下がります。これらの基本手数料の変化は制限されているため、ブロックごとの最大差が予測可能になります。これにより、ウォレットが非常に確実にユーザーのガス料金を自動設定できるようになります。ほとんどのユーザーは、高いネットワーク活動期間でも手動でガス料金を調整する必要がなくなるはずです。ほとんどのユーザーにとって、基本手数料はウォレットによって推定され、マイナーのオーファンリスクを補償する小さな優先手数料(例えば1ナノETH)が自動的に設定されます。ユーザーは、総コストを制限するために、取引の最大手数料を手動で設定することもできます。

この手数料システムの重要な側面は、マイナーが優先手数料のみを受け取れることです。基本手数料は常に焼却されます(つまり、プロトコルによって破壊されます)。これにより、Ethereumプラットフォーム上のトランザクションにはETHしか使用できなくなり、ETHの経済的価値が強化されるとともに、マイナー抽出可能価値(MEV)に関連するリスクが減少します。さらに、ブロックのマイナーが基本手数料を受け取らないことで、ユーザーからより多くの手数料を抽出するためにマイナーが手数料を操作するインセンティブがなくなります。

## 仕様
ブロックの有効性は以下のリファレンス実装で定義されます。
`GASPRICE` (`0x3a`) オペコードは、以下のリファレンス実装で定義された `effective_gas_price` を返さなければなりません。

`FORK_BLOCK_NUMBER` 以降、[EIP-2718](./eip-2718.md)の新しい取引タイプ2が導入されます。

新しい取引の固有コストは[EIP-2930](./eip-2930.md)から継承され、具体的には `21000 + 16 * 非ゼロコールデータバイト数 + 4 * ゼロコールデータバイト数 + 1900 * アクセスリストストレージキー数 + 2400 * アクセスリストアドレス数` です。

[EIP-2718](./eip-2718.md) `TransactionPayload` は `rlp([chain_id, nonce, max_priority_fee_per_gas, max_fee_per_gas, gas_limit, destination, amount, data, access_list, signature_y_parity, signature_r, signature_s])` です。

この取引の `signature_y_parity, signature_r, signature_s` 要素は、`keccak256(0x02 || rlp([chain_id, nonce, max_priority_fee_per_gas, max_fee_per_gas, gas_limit, destination, amount, data, access_list]))` 上のsecp256k1署名を表します。

[EIP-2718](./eip-2718.md) `ReceiptPayload` は `rlp([status, cumulative_transaction_gas_used, logs_bloom, logs])` です。

*注: `//` は整数除算、切り捨て*
```python
from typing import Union, Dict, Sequence, List, Tuple, Literal
from dataclasses import dataclass, field
from abc import ABC, abstractmethod

@dataclass
class TransactionLegacy:
	signer_nonce: int = 0
	gas_price: int = 0
	gas_limit: int = 0
	destination: int = 0
	amount: int = 0
	payload: bytes = bytes()
	v: int = 0
	r: int = 0
	s: int = 0

@dataclass
class Transaction2930Payload:
	chain_id: int = 0
	signer_nonce: int = 0
	gas_price: int = 0
	gas_limit: int = 0
	destination: int = 0
	amount: int = 0
	payload: bytes = bytes()
	access_list: List[Tuple[int, List[int]]] = field(default_factory=list)
	signature_y_parity: bool = False
	signature_r: int = 0
	signature_s: int = 0

@dataclass
class Transaction2930Envelope:
	type: Literal[1] = 1
	payload: Transaction2930Payload = Transaction2930Payload()

@dataclass
class Transaction1559Payload:
	chain_id: int = 0
	signer_nonce: int = 0
	max_priority_fee_per_gas: int = 0
	max_fee_per_gas: int = 0
	gas_limit: int = 0
	destination: int = 0
	amount: int = 0
	payload: bytes = bytes()
	access_list: List[Tuple[int, List[int]]] = field(default_factory=list)
	signature_y_parity: bool = False
	signature_r: int = 0
	signature_s: int = 0

@dataclass
class Transaction1559Envelope:
	type: Literal[2] = 2
	payload: Transaction1559Payload = Transaction1559Payload()

Transaction2718 = Union[Transaction1559Envelope, Transaction2930Envelope]

Transaction = Union[TransactionLegacy, Transaction2718]

@dataclass
class NormalizedTransaction:
	signer_address: int = 0
	signer_nonce: int = 0
	max_priority_fee_per_gas: int = 0
	max_fee_per_gas: int = 0
	gas_limit: int = 0
	destination: int = 0
	amount: int = 0
	payload: bytes = bytes()
	access_list: List[Tuple[int, List[int]]] = field(default_factory=list)

@dataclass
class Block:
	parent_hash: int = 0
	uncle_hashes: Sequence[int] = field(default_factory=list)
	author: int = 0
	state_root: int = 0
	transaction_root: int = 0
	transaction_receipt_root: int = 0
	logs_bloom: int = 0
	difficulty: int = 0
	number: int = 0
	gas_limit: int = 0 # note the gas_limit is the gas_target * ELASTICITY_MULTIPLIER
	gas_used: int = 0
	timestamp: int = 0
	extra_data: bytes = bytes()
	proof_of_work: int = 0
	nonce: int = 0
	base_fee_per_gas: int = 0

@dataclass
class Account:
	address: int = 0
	nonce: int = 0
	balance: int = 0
	storage_root: int = 0
	code_hash: int = 0

INITIAL_BASE_FEE = 1000000000
INITIAL_FORK_BLOCK_NUMBER = 10 # TBD
BASE_FEE_MAX_CHANGE_DENOMINATOR = 8
ELASTICITY_MULTIPLIER = 2

class World(ABC):
	def validate_block(self, block: Block) -> None:
		parent_gas_target = self.parent(block).gas_limit // ELASTICITY_MULTIPLIER
		parent_gas_limit = self.parent(block).gas_limit

		# フォークブロックでは、ELASTICITY_MULTIPLIERを考慮しないことで、
		# ガスターゲットが不当に半減するのを避ける。
		if INITIAL_FORK_BLOCK_NUMBER == block.number:
			parent_gas_target = self.parent(block).gas_limit
			parent_gas_limit = self.parent(block).gas_limit * ELASTICITY_MULTIPLIER 

		parent_base_fee_per_gas = self.parent(block).base_fee_per_gas
		parent_gas_used = self.parent(block).gas_used
		transactions = self.transactions(block)

		# ブロックが使用したガスが多すぎないかチェック
		assert block.gas_used <= block.gas_limit, '無効なブロック: ガス使用量が多すぎる'

		# ブロックのガスリミットが大幅に変更されていないかチェック
		assert block.gas_limit < parent_gas_limit + parent_gas_limit // 1024, '無効なブロック: ガスリミットが大幅に増加した'
		assert block.gas_limit > parent_gas_limit - parent_gas_limit // 1024, '無効なブロック: ガスリミットが大幅に減少した'

		# ガスリミットが最小ガスリミット以上であることをチェック
		assert block.gas_limit >= 5000

		# 基本手数料が正しいかチェック
		if INITIAL_FORK_BLOCK_NUMBER == block.number:
			expected_base_fee_per_gas = INITIAL_BASE_FEE
		elif parent_gas_used == parent_gas_target:
			expected_base_fee_per_gas = parent_base_fee_per_gas
		elif parent_gas_used > parent_gas_target:
			gas_used_delta = parent_gas_used - parent_gas_target
			base_fee_per_gas_delta = max(parent_base_fee_per_gas * gas_used_delta // parent_gas_target // BASE_F
EE_MAX_CHANGE_DENOMINATOR, 1)
			expected_base_fee_per_gas = parent_base_fee_per_gas + base_fee_per_gas_delta
		else:
			gas_used_delta = parent_gas_target - parent_gas_used
			base_fee_per_gas_delta = parent_base_fee_per_gas * gas_used_delta // parent_gas_target // BASE_FEE_MAX_CHANGE_DENOMINATOR
			expected_base_fee_per_gas = parent_base_fee_per_gas - base_fee_per_gas_delta
		assert expected_base_fee_per_gas == block.base_fee_per_gas, '無効なブロック: 基本手数料が正しくない'

		# トランザクションを実行し、ガス会計を行う
		cumulative_transaction_gas_used = 0
		for unnormalized_transaction in transactions:
			# 注: これは取引の署名とチェーンIDの検証を行うものであり、以下の正規化の前に行う必要がある
			signer_address = self.validate_and_recover_signer_address(unnormalized_transaction)
			transaction = self.normalize_transaction(unnormalized_transaction, signer_address)

			signer = self.account(signer_address)

			signer.balance -= transaction.amount
			assert signer.balance >= 0, '無効な取引: 署名者にETHが不足している'
			# 署名者は取引の費用を支払えなければならない
			assert signer.balance >= transaction.gas_limit * transaction.max_fee_per_gas

			# ユーザーが少なくとも基本手数料を支払う意思があることを確認する
			assert transaction.max_fee_per_gas >= block.base_fee_per_gas

			# 非常に大きな数値を防ぐ
			assert transaction.max_fee_per_gas < 2**256
			# 非常に大きな数値を防ぐ
			assert transaction.max_priority_fee_per_gas < 2**256
			# 合計は2つのうち大きい方でなければならない
			assert transaction.max_fee_per_gas >= transaction.max_priority_fee_per_gas

			# 優先手数料は、基本手数料が先に満たされるため制限される
			priority_fee_per_gas = min(transaction.max_priority_fee_per_gas, transaction.max_fee_per_gas - block.base_fee_per_gas)
			# 署名者は優先手数料と基本手数料の両方を支払う
			effective_gas_price = priority_fee_per_gas + block.base_fee_per_gas
			signer.balance -= transaction.gas_limit * effective_gas_price
			assert signer.balance >= 0, '無効な取引: 署名者にガス代を支払うETHが不足している'
			gas_used = self.execute_transaction(transaction, effective_gas_price)
			gas_refund = transaction.gas_limit - gas_used
			cumulative_transaction_gas_used += gas_used
			# 署名者は未使用ガスの払い戻しを受ける
			signer.balance += gas_refund * effective_gas_price
			# マイナーは優先手数料のみを受け取る。基本手数料は誰にも与えられず、焼却される
			self.account(block.author).balance += gas_used * priority_fee_per_gas

		# ブロックがトランザクションに使用したガスが多すぎないかチェック
		assert cumulative_transaction_gas_used == block.gas_used, '無効なブロック: gas_usedがすべてのトランザクションの合計ガス使用量と一致しない'

		# TODO: ブロックのアカウントバランスがブロックのステートルートと一致することを検証する
		# TODO: ブロックの残りの部分を検証する

	def normalize_transaction(self, transaction: Transaction, signer_address: int) -> NormalizedTransaction:
		# レガシートランザクション
		if isinstance(transaction, TransactionLegacy):
			return NormalizedTransaction(
				signer_address = signer_address,
				signer_nonce = transaction.signer_nonce,
				gas_limit = transaction.gas_limit,
				max_priority_fee_per_gas = transaction.gas_price,
				max_fee_per_gas = transaction.gas_price,
				destination = transaction.destination,
				amount = transaction.amount,
				payload = transaction.payload,
				access_list = [],
			)
		# 2930トランザクション
		elif isinstance(transaction, Transaction2930Envelope):
			return NormalizedTransaction(
				signer_address = signer_address,
				signer_nonce = transaction.payload.signer_nonce,
				gas_limit = transaction.payload.gas_limit,
				max_priority_fee_per_gas = transaction.payload.gas_price,
				max_fee_per_gas = transaction.payload.gas_price,
				destination = transaction.payload.destination,
				amount = transaction.payload.amount,
				payload = transaction.payload.payload,
				access_list = transaction.payload.access_list,
			)
		# 1559トランザクション
		elif isinstance(transaction, Transaction1559Envelope):
			return NormalizedTransaction(
				signer_address = signer_address,
				signer_nonce = transaction.payload.signer_nonce,
				gas_limit = transaction.payload.gas_limit,
				max_priority_fee_per_gas = transaction.payload.max_priority_fee_per_gas,
				max_fee_per_gas = transaction.payload.max_fee_per_gas,
				destination = transaction.payload.destination,
				amount = transaction.payload.amount,
				payload = transaction.payload.payload,
				access_list = transaction.payload.access_list,
			)
		else:
			raise Exception('無効な取引: 予期しないアイテム数')

	@abstractmethod
	def parent(self, block: Block) -> Block: pass

	@abstractmethod
	def block_hash(self, block: Block) -> int: pass

	@abstractmethod
	def transactions(self, block: Block) -> Sequence[Transaction]: pass

	# effective_gas_priceは、GASPRICE (0x3a) オペコードが返す値
	@abstractmethod
	def execute_transaction(self, transaction: NormalizedTransaction, effective_gas_price: int) -> int: pass

	@abstractmethod
	def validate_and_recover_signer_address(self, transaction: Transaction) -> int: pass

	@abstractmethod
	def account(self, address: int) -> Account: pass

## 下位互換性
レガシーEthereumトランザクションは引き続き機能し、ブロックに含まれますが、新しい価格付けシステムの恩恵を直接受けることはできません。これは、レガシートランザクションからの新しいトランザクションへのアップグレードにより、レガシートランザクションの `gas_price` が完全に `base_fee_per_gas` と `priority_fee_per_gas` によって消費されるためです。

### ブロックハッシュの変更
ブロックハッシュを計算するためにkeccak256に渡されるデータ構造が変更されるため、ブロックの有効性を検証したり、ブロックの内容を検証するためにブロックハッシュを使用しているすべてのアプリケーションを、新しいデータ構造(1つの追加項目)をサポートするように適応させる必要があります。ブロックヘッダーのバイトのみを取り、それらをハッシュすれば、依然として正しいハッシュを取得できますが、ブロックヘッダーの構成要素から構築する場合は、最後に新しい要素を追加する必要があります。

### GASPRICE
この変更以前は、`GASPRICE`は取引の署名者が1ガスあたりに支払うETHと、マイナーが1ガスあたりに受け取るETHの両方を表していました。この変更により、`GASPRICE`は署名者が1ガスあたりに支払うETHのみを表すようになり、マイナーが取引に対して受け取った金額はEVMから直接アクセスできなくなりました。

## セキュリティ上の考慮事項
### 最大ブロックサイズ/複雑性の増加
このEIPにより、最大ブロックサイズが増加するため、マイナーがブロックを十分に処理できない場合、空のブロックを採掘せざるを得なくなる可能性があります。長期的には、このEIPなしの場合とほぼ同じ平均ブロックサイズになるはずですが、短期的な大きなサイズ変動が問題となる可能性があります。クライアントの1つ以上が、最大サイズのブロックを適切に処理できない(メモリ不足など)可能性があるため、クライアント実装では、最大サイズのブロックを適切に処理できるようにする必要があります。

### トランザクションの順序
ほとんどのユーザーが優先手数料ではなく基本手数料を使ってブロックに含まれるようにするため、トランザクションの順序は、メモリ内のトランザクションの保存方法など、個々のクライアントの内部実装の詳細に依存するようになります。同じ優先手数料のトランザクションは、スパム攻撃から保護するために、受信した時間順に並べることが推奨されます。マイナーは依然として、より高いガス料金のトランザクションを、より低いガス料金のものよりも優先的に選択するべきです(自己採掘の観点から)。

### マイナーによる空ブロックの採掘
マイナーが基本手数料が非常に低くなるまで空ブロックを採掘し、その後半分のブロックを採掘して優先手数料によるソートに戻る可能性があります。この攻撃は可能ですが、マイニングが分散化されている限り、それほど安定した均衡状態にはなりません。この戦略から逸脱するマイナーは、攻撃が続く限り、より収益性が高くなります(基本手数料が0になった後も同様)。匿名で逸脱できるため、カルテルを実行するのは実現可能ではありません。攻撃者が50%以上のハッシュパワーを持っている場合にのみ、この攻撃を実行できます。攻撃者が正確に50%のハッシュパワーを持っている場合、優先手数料からは何も得られませんが、逸脱者は優先手数料の2倍を得られます。攻撃者が利益を上げるには、50%を超えるハッシュパワーが必要で、その場合、二重支払い攻撃を実行したり、他のマイナーを無視するなど、はるかに収益性の高い戦略があります。

このような攻撃が行われた場合、エラスティシティ乗数(現在は2倍)を単に増やせば、攻撃者がより多くのハッシュパワーを持っている必要があるため、理論的に収益性の高い攻撃を行うことができなくなります。

### ETHの焼却により固定供給が不可能に
基本手数料を焼却することで、ETHの供給量を固定することができなくなります。これにより、ETHの長期的な供給量が時間とともに一定ではなくなるため、経済的な不安定性が生じる可能性があります。妥当な懸念ではありますが、その影響の程度を定量化するのは難しいです。マイニング報酬より多くが基本手数料として焼却された場合、ETHは deflationaryになり、マイニング報酬より少なかった場合はinflationary になります。ユーザーのブロックスペースに対する需要を制御できないため、ETHが最終的にinflationary になるのかdeflationary になるのかを断言することはできません。このため、ETHの長期的な量に対するコアデベロッパーの管理能力が失われます。

## 著作権
著作権およびその関連権利は[CC0](../LICENSE.md)で放棄されています。