---
original: 691f06ecd80a1f5ec71f169553b808c837f68e06860ffac68dd44649e93b804b
---

---
eip: 2930
title: オプションのアクセスリスト
author: Vitalik Buterin (@vbuterin), Martin Swende (@holiman)
discussions-to: https://ethereum-magicians.org/t/eip-2930-optional-access-lists/4561
status: 最終
type: 標準トラック
category: コア
created: 2020-08-29
requires: 2718, 2929
---

## 簡単な要約

トランザクションタイプにアクセスリスト(トランザクションがアクセスする予定のアドレスとストレージキーのリスト)を含めることで、リスト外のアクセスが可能になるが、より高価になります。

## 概要

[EIP-2718](./eip-2718.md)の新しいトランザクションタイプを導入します。フォーマットは `0x01 || rlp([chainId, nonce, gasPrice, gasLimit, to, value, data, accessList, signatureYParity, signatureR, signatureS])` です。

`accessList`には、アドレスとストレージキーのリストが指定されます。これらのアドレスとストレージキーは、[EIP-2929](./eip-2929.md)で導入された `accessed_addresses` と `accessed_storage_keys` のグローバルセットに追加されます。ディスカウントされた gas コストが課金されます。

## 動機

このEIPには2つの目的があります:

1. [EIP-2929](./eip-2929.md)によって引き起こされるコントラクトの破損リスクを軽減すること。トランザクションがアクセスする予定のアカウントとストレージスロットを事前に指定し、事前に支払うことで、実際の実行時にSLOADやEXT*オペコードのコストが100 gasと十分に低くなり、EIP 1884によって「立ち往生」したコントラクトも復活できるようになります。
2. アクセスリストのフォーマットと、そのフォーマットを扱うロジックを導入すること。このロジックは後に、ブロック単位のwitness、ReGenesisでの利用、静的ステートアクセスへの移行など、さまざまな目的に再利用できます。

## 仕様

### 定義

**`TransactionType`** `1`.  [EIP-2718](./eip-2718.md)を参照

**`ChainId`** このチェーンIDのネットワークでのみ有効なトランザクション

**`YParity`** secp256k1署名のy値の偶奇性(0は偶数、1は奇数)

### パラメータ

| 定数 | 値 |
| - | - |
| `FORK_BLOCK` | 12244000 |
| `ACCESS_LIST_STORAGE_KEY_COST` | 1900 |
| `ACCESS_LIST_ADDRESS_COST` | 2400 |

`FORK_BLOCK_NUMBER`以降、[EIP-2718](./eip-2718.md)の新しいトランザクションタイプ `1` が導入されます。

[EIP-2718](./eip-2718.md) `TransactionPayload`は `rlp([chainId, nonce, gasPrice, gasLimit, to, value, data, accessList, signatureYParity, signatureR, signatureS])` です。

`signatureYParity, signatureR, signatureS`は、 `keccak256(0x01 || rlp([chainId, nonce, gasPrice, gasLimit, to, value, data, accessList]))` に対するsecp256k1署名を表します。

[EIP-2718](./eip-2718.md) `ReceiptPayload`は `rlp([status, cumulativeGasUsed, logsBloom, logs])` です。

トランザクションの有効性には、`accessList`が `[[{20 bytes}, [{32 bytes}...]]...]` 形式であることが必要です。例えば、以下は有効なアクセスリストです(実際には16進数文字列がバイト表現になります):

```
[
    [
        "0xde0b295669a9fd93d5f28d9ec85e40f4cb697bae",
        [
            "0x0000000000000000000000000000000000000000000000000000000000000003",
            "0x0000000000000000000000000000000000000000000000000000000000000007"
        ]
    ],
    [
        "0xbb9bc244d798123fde783fcc1c72d3bb8c189413",
        []
    ]
]
```

実行開始時(つまり[EIP-2028](./eip-2028.md)のルールに従って`21000 + 4 * 0 + 16 * 非0`のスタートガスが課金される時と同時に)、アクセスリストに対して追加のガスが課金されます: アドレスごとに `ACCESS_LIST_ADDRESS_COST`、ストレージキーごとに `ACCESS_LIST_STORAGE_KEY_COST` です。上記の例では、`ACCESS_LIST_ADDRESS_COST * 2 + ACCESS_LIST_STORAGE_KEY_COST * 2` のガスが課金されます。

重複したアドレスやストレージキーは許可されますが、複数回課金されます。ガスコストが高くなるだけで、実行フローや結果に違いはありません。

アドレスとストレージキーは直ちに `accessed_addresses` と `accessed_storage_keys` のグローバルセットに追加されます。以下のロジックで行います(RLP復号化されたアクセスリストの検証仕様にもなっています):

```python
def process_access_list(access_list) -> Tuple[List[Set[Address], Set[Pair[Address, Bytes32]]], int]:
    accessed_addresses = set()
    accessed_storage_keys = set()
    gas_cost = 0
    assert isinstance(access_list, list)
    for item in access_list:
        assert isinstance(item, list) and len(item) == 2
        # アドレスの検証と追加
        address = item[0]
        assert isinstance(address, bytes) and len(address) == 20
        accessed_addresses.add(address)
        gas_cost += ACCESS_LIST_ADDRESS_COST
        # ストレージキーの検証と追加
        assert isinstance(item[1], list)
        for key in item[1]:
            assert isinstance(key, bytes) and len(key) == 32
            accessed_storage_keys.add((address, key))
            gas_cost += ACCESS_LIST_STORAGE_KEY_COST
    return (
        accessed_addresses,
        accessed_storage_keys,
        gas_cost
    )
```

アクセスリストにはトランザクションデータのようなバイト単位の料金は課金されません。上記の項目単位のコストは、アクセスリストのデータ帯域幅コストと、そのアカウントやストレージキーへのアクセスコストを合わせたものです。

## 根拠

### アクセスリスト内のアクセスに対して割引を行う

これは、トランザクションがアクセスリストを最大限活用するよう奨励するためです。また、ストレージの読み取りが予測可能なトランザクションの処理が容易になるためです(クライアントがトランザクション受信時にデータベースからデータをプリロードしたり、証拠を要求したり、ブロック受信時に並列でデータをロードしたりできるようになります)。

### 重複を許可する

これは、単純性を最大化するためです。重複を防ぐ対象(アクセスリスト内、送信者/受信者/新規作成コントラクトとの間など)を決める必要がなくなります。ガスは項目ごとに課金されるため、アクセスリストに同じ値を複数含めても利点はなく、ただコストがかかるだけです。実際にはチェーンの肥大化にはつながらないはずです。

### 署名にトランザクションタイプも含める

これは、トランザクションが別のタイプとして「再解釈」されるのを防ぐためです。

## 下位互換性

このEIPにより、「予期せぬ」SLOADやアカウントアクセスのガスコストが高くなります。ただし、ガスは事前に支払われるため、固定ガスのローカルコールには影響しません。したがって、ストレージアクセスに大きく依存するアプリケーションが経済的に成り立たなくなるだけで、コントラクトを破壊するようなことはありません。

## セキュリティ上の考慮事項

### アクセスリストの生成

多くの状況でアクセスリストを実時間で構築するのは難しく、特にトランザクション生成とサインの間に大きな時間遅延がある環境や、トランザクション生成の簡単さが重視される環境(ハードウェアウォレットなど)ではさらに難しくなります。

しかし、このEIPでは初期の割引率は10%程度なので、アクセスリストの生成を面倒がらずに単純なトランザクションを行うコストはほとんどありません。アクセスリストの生成が成熟してきたら、ステートへのアクセスコストを段階的に引き上げていく予定です。

### トランザクションサイズの肥大化

アクセスリストの使用により、平均ブロックサイズは増加します。ただし、アクセスリストのバイト単位コストは `1900 / 32 = 59.375` (ストレージキー) と `2400 / 20 = 120` (アドレス) と、callデータよりはるかに高いため、最悪ケースのブロックサイズは増加しません。また、トランザクション受信時にストレージをプリフェッチしたり、ブロック受信時に並列でストレージをロードしたりすることで、平均ブロックサイズの増加は部分的に相殺されます。

## 著作権
[CC0](../LICENSE.md)によりすべての著作権およびそれに関連する権利が放棄されています。