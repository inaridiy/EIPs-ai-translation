---
original: 433194a2839209ccffe0c602d3fecc362b64946f7066913db8a1a938dca87c36
---

---
eip: 7658
title: ライトクライアントデータのバックフィル
description: ビーコンノードがライトクライアントデータの履歴を同期するためのメカニズム
author: Etan Kissling (@etan-status)
discussions-to: https://ethereum-magicians.org/t/eip-7658-light-client-data-backfill/19290
status: Review
type: Standards Track
category: Core
created: 2024-03-21
---

## 概要

このEIPは、ビーコンノード間でライトクライアントデータ([light client data](https://github.com/ethereum/consensus-specs/blob/4afe39822c9ad9747e0f5635cca117c18441ec1b/specs/altair/light-client/full-node.md))を同期するためのメカニズムを定義します。

## 動機

ビーコンノードは[ライトクライアント](https://github.com/ethereum/consensus-specs/blob/4afe39822c9ad9747e0f5635cca117c18441ec1b/specs/altair/light-client/light-client.md)がネットワークと同期できるよう、[ライトクライアントデータ](https://github.com/ethereum/consensus-specs/blob/4afe39822c9ad9747e0f5635cca117c18441ec1b/specs/altair/light-client/full-node.md)を収集します。[同期プロトコル](https://github.com/ethereum/consensus-specs/blob/4afe39822c9ad9747e0f5635cca117c18441ec1b/specs/altair/light-client/sync-protocol.md)は時間を前に進めて同期する仕組みを定義していますが、過去にさかのぼって同期することはできません。

ライトクライアントデータの収集は難しい課題です。ビーコンノードは対応する[`BeaconState`](https://github.com/ethereum/consensus-specs/blob/4afe39822c9ad9747e0f5635cca117c18441ec1b/specs/phase0/beacon-chain.md#beaconstate)と[`SignedBeaconBlock`](https://github.com/ethereum/consensus-specs/blob/4afe39822c9ad9747e0f5635cca117c18441ec1b/specs/phase0/beacon-chain.md#signedbeaconblock)にアクセスする必要があるためです。`BeaconState`は最初にシンクした checkpoint状態より前は利用できず、`SignedBeaconBlock`はlibp2pで保持される期間が限られています。

さらに、各[sync committee期間](https://github.com/ethereum/consensus-specs/blob/4afe39822c9ad9747e0f5635cca117c18441ec1b/specs/altair/beacon-chain.md#get_next_sync_committee)は`EPOCHS_PER_SYNC_COMMITTEE_PERIOD * SLOTS_PER_EPOCH`スロットで構成されます。バックエンドに依存せずに一貫した表示を提供するアーカイブサービス(Portal networkなど)をサポートするには、その期間の代表的なライトクライアントデータを導出するための単一のカノニカルなスロットを選択する必要があります。そのようなデータは分散型で独立した方法で検証可能で最適である必要があります。

ライトクライアントデータのバックフィルをサポートするため、このEIPでは`BeaconState`にカノニカルで最適な[`SyncAggregate`](https://github.com/ethereum/consensus-specs/blob/4afe39822c9ad9747e0f5635cca117c18441ec1b/specs/altair/beacon-chain.md#syncaggregate)を追跡することを提案します。この最小限の追加により、導出された[`LightClientUpdate`](https://github.com/ethereum/consensus-specs/blob/4afe39822c9ad9747e0f5635cca117c18441ec1b/specs/altair/light-client/sync-protocol.md#lightclientupdate)と[`LightClientBootstrap`](https://github.com/ethereum/consensus-specs/blob/4afe39822c9ad9747e0f5635cca117c18441ec1b/specs/altair/light-client/sync-protocol.md#lightclientbootstrap)がカノニカルで最適であることを証明できます。

## 仕様

このドキュメントの「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、「OPTIONAL」というキーワードは、RFC 2119およびRFC 8174に記載されているように解釈されるものとします。

### コンテナ

#### 新しいコンテナ

##### `SyncData`

```python
class SyncData(Container):
    # Sync committee aggregate signature
    sync_aggregate: SyncAggregate
    # Aggregate signature が作成されたスロット
    signature_slot: Slot
```

#### 拡張されたコンテナ

##### `BeaconState`

アクティブ化されたフォークから、現在および前のsync committee期間の最良のsync dataを追跡するために、`BeaconState`の末尾に新しいフィールドが追加されます。

```python
class BeaconState(Container):
    ...
    # Sync history
    previous_best_sync_data: SyncData
    current_best_sync_data: SyncData
    parent_block_has_sync_committee_finality: bool
```

### ヘルパー関数

#### `default_sync_data`

```python
def default_sync_data() -> SyncData:
    return SyncData(
        sync_aggregate=SyncAggregate(
            sync_committee_bits=Bitvector[SYNC_COMMITTEE_SIZE]()
            sync_committee_signature=G2_POINT_AT_INFINITY,
        ),
        signature_slot=GENESIS_SLOT,
    )
```

### ビーコンチェーンの状態遷移関数

#### エポック処理

##### 変更された `process_sync_committee_updates`

sync committee境界では、現在の期間のデータが前の期間に移動します。これにより、前の期間のライトクライアントデータがカノニカルであることを証明できます。

```python
def process_sync_committee_updates(state: BeaconState) -> None:
    next_epoch = get_current_epoch(state) + Epoch(1)
    if next_epoch % EPOCHS_PER_SYNC_COMMITTEE_PERIOD == 0:
        ...
        state.previous_best_sync_data = state.current_best_sync_data
        state.current_best_sync_data = default_sync_data()
        state.parent_block_has_sync_committee_finality = False
```

#### ブロック処理

ブロック処理は、現在の期間の最適なライトクライアントデータを追跡するように拡張されています。空のスロットの可能性があるため、ブロックヘッダーが上書きされる前に追跡する必要があります。これにより、`next_sync_committee`が確定された正確なブロックを追跡できます。

```python
def process_block(state: BeaconState, block: BeaconBlock) -> None:
    process_best_sync_data(state, block)
    process_block_header(state, block)
    ...
```

##### 新しい `process_best_sync_data`

```python
def process_best_sync_data(state: BeaconState, block: BeaconBlock) -> None:
    signature_period = compute_sync_committee_period_at_slot(block.slot)
    attested_period = compute_sync_committee_period_at_slot(state.latest_block_header.slot)

    # Sync committee finality を追跡
    old_has_sync_committee_finality = state.parent_block_has_sync_committee_finality
    if state.parent_block_has_sync_committee_finality:
        new_has_sync_committee_finality = True
    elif state.finalized_checkpoint.epoch < ALTAIR_FORK_EPOCH:
        new_has_sync_committee_finality = False
    else:
        finalized_period = compute_sync_committee_period(state.finalized_checkpoint.epoch)
        new_has_sync_committee_finality = (finalized_period == attested_period)
    state.parent_block_has_sync_committee_finality = new_has_sync_committee_finality

    # 最良のsync dataを追跡
    if attested_period == signature_period:
        max_active_participants = len(block.body.sync_aggregate.sync_committee_bits)
        new_num_active_participants = sum(block.body.sync_aggregate.sync_committee_bits)
        old_num_active_participants = sum(state.current_best_sync_data.sync_aggregate.sync_committee_bits)
        new_has_supermajority = new_num_active_participants * 3 >= max_active_participants * 2
        old_has_supermajority = old_num_active_participants * 3 >= max_active_participants * 2
        if new_has_supermajority != old_has_supermajority:
            is_better_sync_data = new_has_supermajority
        elif not new_has_supermajority and new_num_active_participants != old_num_active_participants:
            is_better_sync_data = new_num_active_participants > old_num_active_participants
        elif new_has_sync_committee_finality != old_has_sync_committee_finality:
            is_better_sync_data = new_has_sync_committee_finality
        else:
            is_better_sync_data = new_num_active_participants > old_num_active_participants
        if is_better_sync_data:
            state.current_best_sync_data = SyncData(
                sync_aggregate=block.body.sync_aggregate,
                signature_slot=block.slot,
            )
```

## 根拠

### `SyncAggregate`をどのように順位付けするか?

このEIPは既存の仕様から[`is_better_update`](https://github.com/ethereum/consensus-specs/blob/4afe39822c9ad9747e0f5635cca117c18441ec1b/specs/altair/light-client/sync-protocol.md#is_better_update)関数を再利用しています。

### バックフィルプロトコルはこれをどのように使えるか?

データが`BeaconState`で利用可能になったら、過去の期間に対してライトクライアントデータのバックフィルプロトコルを定義できます:

1. 要求された`period` + 1の`LightClientUpdate`を提供し、`period`全体が確定されていることを証明する。
2. (1)の`attested_header.beacon.state_root`で、`BeaconState.historical_summaries[period].block_summary_root`とMerkleプルーフを提供する。
3. 要求された`period`内の各エポックのスロット0ブロックについて、対応する`LightClientHeader`と(2)の`block_summary_root`への Merkle multi-proofを提供する。
4. (3)の中から`beacon.slot`が`period`内のものについて、`current_sync_committee_branch`と`LightClientBootstrap`の構築に必要なMerkleプルーフを提供する。
5. (4)が空でない場合は、要求された`period`の`current_sync_committee`を提供する。
6. 存在する場合は、`period`の最良の`LightClientUpdate`と、その`sync_aggregate`と`signature_slot`が(1)の`attested_header.beacon.state_root`で選択されたカノニカルな最良のものであることを証明するMerkleプルーフを提供する。

(6)のプルーフのみが`BeaconState`でのベストライトクライアントデータの追跡に依存します。この変更により、`is_better_update`のサブセットのロジックが成文化されますが、`BeaconState`に`LightClientXyz`データ構造を追加する必要はありません。

## 下位互換性

このEIPはハードフォークを必要とし、新しいコンセンサス検証ルールを導入します。

ハードフォーク後のライトクライアントデータのみがカノニカルで最適であることを証明できます。ただし、フォーク遷移ブロックの確定後は、それ以前のライトクライアントデータは変更できなくなり、ハッシュを使ってロックインできます。

## セキュリティ上の考慮事項

なし

## 著作権

著作権およびその関連権利は[CC0](../LICENSE.md)で放棄されています。