---
original: 5b4404ce4cf6267a50202d695db22a0e63ed215fd0555c8f6ab26a7cbb2db2e3
---

---
eip: 1930
title: 厳密なガスセマンティクスを持つCALL。ガスが不足している場合は巻き戻す。
author: Ronan Sandford (@wighawag)
type: Standards Track
discussions-to: https://github.com/ethereum/EIPs/issues/1930
category: Core
status: Stagnant
created: 2019-04-10
---

## 簡単な要約

スマートコントラクトに特定量のガスで呼び出しを実行する機能を追加する。これが不可能な場合は実行を巻き戻す。

## 概要

現在のCALL、DELEGATE_CALL、STATIC_CALLオペコードはガスの送信を強制しておらず、ガス値を単なる最大値として扱っている。これは、呼び出しを正確な量のガスで実行する必要がある用途に深刻な問題を引き起こす。

例えば、メタトランザクションの場合、コントラクトは署名ユーザーが意図したとおりに呼び出しが実行されることを保証する必要がある。

また、[EIP-165](./eip-165.md)などを使ってスマートコントラクトが特定のインターフェースをサポートしているかを「オンチェーン」で確認するような一般的な用途でも同様の問題が生じる。

ここで提案するソリューションは、指定されたガス量を強制する新しい呼び出しセマンティクスを追加することです。呼び出しは指定されたガス量で実行されるか、実行されず現在の呼び出しが巻き戻される。

### 仕様

2つの可能性がある

a) オペコードの変種を追加し、より厳密なガスセマンティクスを持たせる

b) これまで使われていない特定のガス値範囲を厳密なガスセマンティクスとして扱い、他の値は従来通りとする

詳細は以下の通り

#### オプションa)

- 指定されたガスが確保できない場合に現在の呼び出しを巻き戻すCALLオペコードの新しい変種を追加する
- 指定されたガスが確保できない場合に現在の呼び出しを巻き戻すDELEGATE_CALLオペコードの新しい変種を追加する
- 指定されたガスが確保できない場合に現在の呼び出しを巻き戻すSTATIC_CALLオペコードの新しい変種を追加する

##### a)のメリット
この解決策は、古いコントラクトに影響を与える可能性を排除できる。一方で、3つの新しいオペコードを導入する必要がある。EIP-1702を使えば、古いオペコードを廃止することができる。

#### オプションb)

ガスを他のコントラクトに渡すすべてのオペコードについて以下を行う:
- 最上位ビットが1の場合、31ビット下位を受信コントラクトに渡すガス量として厳密に扱う。つまり、a)と同様に、呼び出し時点のガスが不足している場合は現在の呼び出しを巻き戻す。
- 2番目の最上位ビットが0の場合、従来通り最大値として扱う。ガスが不足していても、可能な限りガスを渡す。

##### b)のメリット
この解決策は、0x8000000000000000000000000000000000000000000000000000000000000000以上の値を使うコントラクトがないという事実に依存している。

ソリディティでは、0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFのような値は、gasleftを渡すよりも高コストなため使用されていない。

主なメリットは、追加のオペコードを必要としないことである。

#### 厳密なガスセマンティクス

正確には、[EIP-150](./eip-150.md)に基づき、現在の呼び出しは、G >= I x 64/63の場合を除いて巻き戻される。ここでGは呼び出し時点のガス残量(呼び出し自体のコストを差し引いたもの)、Iは指定されたガス量である。

つまり、以下のように変更される:
```
availableGas = availableGas - base
gas := availableGas - availableGas/64
if !callCost.IsUint64() || gas < callCost.Uint64() {
    return 0, errNotEnoughGas
}
```

### 根拠

現在、これらのオペコードで指定されるガスは単なる最大値である。[EIP-150](./eip-150.md)の動作により、外部呼び出しに意図したよりも少ないガスが渡される可能性がある。EIP-150では、外部呼び出しには最大で ```G - Math.floor(G/64)``` のガスが渡され、残りの ```Math.floor(G/64)``` がトランザクションの残りの部分に使われる。たとえば、G = 6,400,000の場合、トランザクションの残りには100,000ガスが渡され、多くの場合それで十分に成功する。

これは、外部呼び出しが十分なガスがあった場合にのみ失敗するようにする必要がある契約にとって問題となる。このような要件は、署名者と実行者が異なるスマートコントラクトウォレットやメタトランザクションに存在する。なぜなら、契約は署名ユーザーが意図したとおりに呼び出しが実行されることを保証する必要があるからである。

しかし、EIP-165に従ってインターフェースの実装を確認するような単純な用途でも同様の問題が生じる。EIP-165では、```supporstInterface```メソッドは30,000ガスに制限されているため、ガス不足が原因でスローされたかどうかを理論的に確認できる。しかし、CALLオペコードの動作により、契約はガス値を単純に信頼することができない。ガスの十分さを他の手段で確認する必要がある。

呼び出し側が30,000ガス以上を提供しない場合、被呼び出し側はガス不足のためにスローされ(インターフェースをサポートしていないためではない)、呼び出し側には最大476ガスが渡される。これにより、呼び出し側が被呼び出し側がインターフェースを実装していないと誤って解釈してしまう。

このような要件は、EIP-150に従ってガス残量を確認し、呼び出し前に正確なガス量を確認する([このバグレポート](https://web.solidified.io/contract/5b4769b1e6c0d80014f3ea4e/bug/5c83d86ac2dd6600116381f9)のソリューションを参照)か、呼び出し後に確認する([ネイティブのメタトランザクション実装](https://github.com/pixowl/thesandbox-contracts/blob/623f4d4ca10644dcee145bcbd9296579a1543d3d/src/Sand/erc20/ERC20MetaTxExtension.sol#L176)を参照)ことで強制できる。しかし、EVMが呼び出しに渡すガス量を厳密に指定できるようになれば、契約実装がEIP-150の動作や現在のガス価格設定に密接に依存する必要がなくなる。

このような厳密なガス動作は、スマートコントラクトウォレットやメタトランザクションに不可欠である。
実際、この問題は野生の中にも存在し、Gnosis Safeがこの問題を考慮していなかったため、所有者が資金を失うのを避けるために署名メッセージに不要な余分なガスを追加する必要があった。 https://github.com/gnosis/safe-contracts/issues/100

EIP-165の場合、EIPに示された例実装にすでに問題がある。詳細は[ここ](https://github.com/ethereum/EIPs/pull/881#issuecomment-491677748)を参照。

OpenZeppelinの実装にも同じ問題があり、多くのプロジェクトで使用されている。30,000ガスで```supportsInterface```を呼び出す前にガスチェックを行っていないため、上述の問題に晒されている。 https://github.com/OpenZeppelin/openzeppelin-solidity/blob/fa004a7f5de572b3dbcde1a8a81f9a87e353e799/contracts/introspection/ERC165Checker.sol#L37

このような問題は現在、EIP-150を考慮してガスをチェックすることで防ぐことができる。しかし、オペコードレベルでの解決策の方が優れている。

現在、正しい量のガスが送信されることを強制する方法は以下の2つである:

1) 呼び出し前にチェックする

```
uint256 gasAvailable = gasleft() - E;
require(gasAvailable - gasAvailable / 64  >= `txGas`, "not enough gas provided")
to.call.gas(txGas)(data); // CALL
```
ここでEは、```gasleft()```の呼び出しと実際の呼び出しの間の操作に必要なガスに、呼び出し自体のガスコストを加えたものである。
単に```E```を過剰に見積もることで、十分なガスが提供されない場合の呼び出しを防ぐことができるが、EVMが正確な作業を行うことが望ましい。ガス価格が継続的に変化するため、特定のガス価格設定に依存せずに特定量のガスを呼び出しに渡す仕組みが重要である。

2) 呼び出し後にチェックする:

```
to.call.gas(txGas)(data); // CALL
require(gasleft() > txGas / 63, "not enough gas left");
```
この解決策は```E```の計算を必要としないため、ガス価格設定(EIP-150の動作を除く)に依存しない。呼び出しに十分なガスが渡されず失敗した場合、上記の条件は常に失敗する。
しかし、渡されたガスが不足していても、呼び出しが早期に巻き戻されたり成功したりした場合、この確認は通過してしまう。
メタトランザクション内のメタトランザクションのように、ガス供給に対する確認によって巻き戻されるコードが実行される場合、これが問題となる。

前の解決策と同様に、EVMメカニズムの方が優れている。

## 下位互換性

仕様a)の場合: 新しいオペコードを導入するため、下位互換性がある。

仕様b)の場合: 既存のコントラクトで使用されていない値範囲を使用するため、下位互換性がある(要検証)。

## テストケース

## 実装

まだ完全に実装されていないが、仕様の例としてgethを参照。

## 参考文献

1. EIP-150, ./eip-150.md

## 著作権

著作権およびその関連権利は[CC0](../LICENSE.md)で放棄されています。