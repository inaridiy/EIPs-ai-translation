---
original: db72fa0b5d2f3f86f4bf5cfa335a2ab457b4874cc62745b9c0357293e0ad606a
---

---
eip: 7702
title: EOAアカウントコードの設定
description: 実行中にEOAのコードを設定する新しいトランザクションタイプを追加する
author: Vitalik Buterin (@vbuterin), Sam Wilson (@SamWilsn), Ansgar Dietrichs (@adietrichs), Matt Garnett (@lightclient)
discussions-to: https://ethereum-magicians.org/t/eip-set-eoa-account-code-for-one-transaction/19923
status: レビュー中
type: Standards Track
category: Core
created: 2024-05-07
requires: 2718, 2929, 2930, 3541, 3607
---

## 概要

`[chain_id、address、nonce、y_parity、r、s]`の認証タプルのリストを追加する新しいトランザクションタイプを追加します。各タプルについて、署名アカウントのコードに `(0xef0100 ++ address)` の委任指定子を書き込みます。すべてのコード読み取り操作は、指定子によって指されるコードを読み込む必要があります。

## 動機

EOAに短期的な機能改善を追加することに大きな関心があり、アプリケーションの使いやすさを高め、場合によってはセキュリティの向上を可能にしています。特に3つの用途があります:

* **バッチ処理**: 同じユーザーからの複数の操作を1つの原子的なトランザクションで許可する。一般的な例は、[ERC-20](./eip-20.md)の承認に続いてその承認を使用することで、DEXで現在2つのトランザクションが必要な一般的なワークフローです。バッチ処理の高度な使用例には時折依存関係が含まれます: 最初の操作の出力が2番目の操作の入力の一部になります。
* **スポンサー**: アカウントXがアカウントYのトランザクションの代金を支払う。アカウントXは別のERC-20で報酬を受け取ることができるか、ユーザーのトランザクションを無料で含めるアプリケーションオペレーターである可能性があります。
* **特権の低下**: ユーザーはサブキーに署名でき、グローバルアクセスよりはるかに弱い特定の権限を与えることができます。たとえば、ERC-20トークンを使用するが ETHは使用できない、1日あたりの総残高の1%まで使用できる、特定のアプリケーションとのみ対話できるなどの権限を想像できます。

## 仕様

### パラメーター

|     パラメーター            | 値     |
| ------------------------ | ------- |
| `SET_CODE_TX_TYPE`       | `0x04`  |
| `MAGIC`                  | `0x05`  |
| `PER_AUTH_BASE_COST`     | `2500`  |
| `PER_EMPTY_ACCOUNT_COST` | `25000` |

### コード設定トランザクション

新しい[EIP-2718](./eip-2718.md)トランザクション「コード設定トランザクション」を導入します。`TransactionType`は`SET_CODE_TX_TYPE`で、`TransactionPayload`は次のRLP直列化です:

```
rlp([chain_id, nonce, max_priority_fee_per_gas, max_fee_per_gas, gas_limit, destination, value, data, access_list, authorization_list, signature_y_parity, signature_r, signature_s])

authorization_list = [[chain_id, address, nonce, y_parity, r, s], ...]
```

外部トランザクションの`chain_id`、`nonce`、`max_priority_fee_per_gas`、`max_fee_per_gas`、`gas_limit`、`destination`、`value`、`data`、および`access_list`フィールドは、[EIP-4844](./eip-4844.md)と同じ意味を持ちます。*null宛先は有効ではないことに注意してください。*

`authorization_list`は、署名者が自分のEOAの文脈で実行したいコードのアドレスを格納するタプルのリストです。`authorization_list`の長さが0の場合、トランザクションは無効と見なされます。

この取引の[EIP-2718](./eip-2718.md) `ReceiptPayload`は`rlp([status, cumulative_transaction_gas_used, logs_bloom, logs])`です。

#### 動作

トランザクションの実行を開始する際、各`[chain_id、address、nonce、y_parity、r、s]`タプルについて:

1. `authority = ecrecover(keccak(MAGIC || rlp([chain_id, address, nonce])), y_parity, r, s]`
2. チェーンIDが0または現在のチェーンIDのいずれかであることを確認します。
3. `authority`のコードが空または既に委任されていることを確認します。
4. `authority`のnonceが`nonce`と等しいことを確認します。
5. `authority`がトライに存在する場合、送信者に`PER_EMPTY_ACCOUNT_COST - PER_AUTH_BASE_COST`ガスを払い戻します。
6. `authority`のコードを`0xef0100 || address`に設定します。これは委任指定子です。
7. `authority`のnonceを1つ増やします。
8. `authority`を`accessed_addresses`(EIP-2929で定義)に追加します。

上記のいずれかのステップが失敗した場合、その時点でそのタプルの処理を停止し、リストの次のタプルに進みます。同じ権限に対して複数のタプルがある場合は、最後に出現したアドレスを使用してコードを設定します。

認証タプルの署名者は`tx.origin`と異なる可能性があることに注意してください。

##### 委任指定子

委任指定子は、[EIP-3541](./eip-3541.md)から禁止されたオペコード`0xef`を使用して、コードが特別な目的を持つことを示します。この指定子により、すべてのコード取得操作がアドレスポインタに従ってアカウントの観察可能なコードを読み込む必要があります。以下の命令が影響を受けます: `EXTCODESIZE`、`EXTCODECOPY`、`EXTCODEHASH`、`CALL`、`CALLCODE`、`STATICCALL`、`DELEGATECALL`。

たとえば、`EXTCODESIZE`は委任指定子を表す`24`ではなく、`address`によって指されるコードのサイズを返します。同様に、`CALL`は`address`から読み取ったコードを`authority`のコンテキストで実行します。

委任指定子が別の指定子を指す可能性のあるチェーンやループが存在する場合、クライアントは最初のコードのみを取得し、指定子チェーンの追跡を停止する必要があります。

#### ガスコスト

新しいトランザクションの固有コストは[EIP-2930](./eip-2930.md)から継承され、具体的には`21000 + 16 * 非ゼロコールデータバイト + 4 * ゼロコールデータバイト + 1900 * アクセスリストストレージキー数 + 2400 * アクセスリストアドレス数`です。さらに、`PER_EMPTY_ACCOUNT_COST * 認証リスト長`のコストを追加します。

トランザクション送信者は、有効性や重複に関係なく、すべての認証タプルの代金を支払います。

コード読み取り命令が委任コードの解決中に冷たいアカウントにアクセスする場合、通常のコストに追加で[EIP-2929](eip-2929.md)の`COLD_ACCOUNT_READ_COST`コスト`2600`ガスを課金します。それ以外の場合は、`WARM_STORAGE_READ_COST`コスト`100`ガスを課金します。

#### トランザクション発信元

[EIP-3607](./eip-3607.md)で導入された制限を変更して、コードが有効な委任指定子、つまり`0xef0100 || address`である EOAがトランザクションを発信し続けられるようにします。その他のコード値を持つアカウントはトランザクションを発信できません。

## 根拠

### initcodeなし

initcodeを実行することは望ましくありません。主な懸念は、それが自然ではないということです。initcodeは、コントラクトを初期化およびデプロイすることを目的としています。このEIPでは、EOAにコードをデプロイするかどうかを決定する新しい役割を担います。ユーザーがトランザクションのコールデータに操作をバンドルした場合にのみ、アカウントにコードをデプロイしたい場合を考えてみましょう。これにより、EOAにはアカウントで実行されるコードを制御する独自の力が与えられます。[EIP-7702](./eip-7702.md)には依然としてこの機能がありますが、決定の可編集性がないため、ウォレットは多くの認証タプルに署名するのではなく、設定可能なプロキシを指すタプルにのみ署名することに焦点を当てざるを得なくなります。これにより、EOAはスマートコントラクトウォレットと同様の体験を得ることができます。

さらに、トランザクション内のinitcodeは伝播される傾向があります。つまり、認証タプルに含める必要があり、署名する必要があります。最小のinitcodeは約15バイトで、外部アドレスからコントラクトコードをコピーするだけです。合計コストは`16 * 15 = 240`のコールデータコスト、[EIP-3860](./eip-3860.md)コストの`2 * 15 = 30`、およびランタイムコストの約`150`になります。つまり、アカウントを準備するだけで約`500`ガスが追加で必要になり、外部アカウントからコピーしない場合はさらに1200ガス以上かかる可能性があります。

### テンプレートによる作成

initcodeの有無にかかわらず、ユーザーがアカウントで実行したいコードを指定する方法については疑問があります。主なオプションは、トランザクションで直接バイトコードを指定するか、コードへのポインタを指定するかです。ポインタの最も単純なものは、コードがデプロイされているオンチェーンのアドレスです。

コストの分析により答えが明確になります。最小のプロキシは約50バイトで、アドレスは20バイトです。30バイトの違いは追加の有用な機能を提供せず、非効率に何十億回も複製されることになります。

さらに、コードを直接指定すると、EOAが新しい独自の機能を持つことができ、トランザクションコールデータで任意のコードを実行できるようになります。

### 命令の禁止なし

一貫性は、実装の観点からもユーザーの理解の観点からも、EVMにとって重要な特性です。EOAのコンテキストでいくつかの命令ファミリーの禁止を検討したにもかかわらず、著者らはそうする説得力のある理由はないと感じています。これにより、スマートコントラクトウォレットとEOAスマートコントラクトウォレットが別々の契約開発の道を進むことを余儀なくされます。

禁止が検討された主な命令ファミリーは、ストレージ関連と契約作成関連でした。ストレージ命令を禁止しないことを決めたのは、主にスマートコントラクトウォレットにとっての重要性によるものです。外部ストレージコントラクトにアクセスするスマートコントラクトウォレットを持つことは可能ですが、非効率的です。将来的には、新しい状態スキームにより、特定のストレージスロットへのアクセスが大幅に安くなる可能性があります。これは、ストレージコントラクトでは対応できないことで、スマートコントラクトウォレットが非常に活用したいことです。

作成命令については、他の同様のEIPでの禁止が検討されましたが、このEIPではEOAが取引内で価値を費やすことができるため、取引の実行が始まった後にnonceを増やすことによる保留中の取引の無効化の懸念は重要ではありません。この副産物として、EIP-7702とCREATE2を組み合わせることで、特定のバイトコードをアドレスにデプロイすることをコミットできますが、手数料市場パラメーターにはコミットしないことができます。これにより、長年の課題であるクロスチェーンコントラクトデプロイの問題が解決されます。

### 署名構造

このEIPの署名スキームは柔軟な設計パターンをサポートし、`address`への完全な委任と`address`への保護された委任の両方を可能にします。

#### コードポインタ

コードポインターに署名する際の考慮事項の1つは、そのアドレスが別のチェーンで指すコードです。一部のユースケースでは、デプロイが決定論的であることを確認する労力を費やしたくない場合があります。そのような状況では、チェーンIDを設定してauthoriz
ation の範囲を狭めることができます。一方で、ウォレットプロキシなどの汎用デプロイが望ましい状況では、チェーンIDを0に設定して全てのEIP-7702チェーンで有効にすることができます。ウォレットメンテナーは、クロスチェーンコードの改ざんの心配をする必要がなくなるよう、単一のEIP-7702認証メッセージをウォレットにハードコーディングできます。

チェーンIDを追加する代わりに、アドレスが指すコードに署名することも考えられます。これにより、auth タプルのオンチェーンサイズを最小限に抑えつつ、実際に実行されるコードの特定性を維持できるというメリットがあります。ただし、この形式の問題点は、各auth タプルの署名者を特定するためにデータベースルックアップが必要になることです。このオーバーヘッド自体が、トランザクションの伝播に十分な複雑さを生み出すと判断されたため、アドレスに直接署名することにしました。

#### プロトコル内の取り消し

このEIPおよび類似のEIPの以前のバージョンとは異なり、委任指定子は、アカウントの現在のnonceでEIP-7702認証を新しいターゲットに送信することで、いつでも取り消すことができます。そのような措置がない限り、委任は永続的に有効のままです。

### 自己スポンサリング: `tx.origin`がコードを設定できるようにする

`tx.origin`がコードを設定できるようにすることで、送信者が外部トランザクションの署名アカウントであるシンプルなトランザクションバッチングが可能になります。現在2つの別々のトランザクションが必要なERC-20の承認-送金パターンを、単一のトランザクションで完了できるようになります。

EOAにコードが存在する場合、EOAのコードがコールを発行するたびに、`msg.sender == tx.origin`になる可能性があります。EIP-7702がなければ、この状況は常にトランザクションの最上位の実行レイヤーでのみ発生する可能性があります。したがって、このEIPはその不変条件を破るため、`require(msg.sender == tx.origin)`チェックを含むスマートコントラクトに影響を与えます。このチェックは少なくとも3つの目的で使用されています:

 1. `msg.sender`がEOAであることを保証すること(`tx.origin`がEOAでなければならないため)。この不変条件は実行レイヤーの深さに依存せず、したがって影響を受けません。
 2. フラッシュローンなどの原子的サンドイッチ攻撃から保護すること。これは、同じ原子的トランザクション内で、ターゲットコントラクトの前後の状態を変更する能力に依存しています。この保護はこのEIPによって破られます。ただし、この方法で`tx.origin`に依存することは良い慣行とは考えられておらず、マイナーが条件付きでトランザクションをブロックに含めることで既に回避できます。
 3.再入力を防ぐこと。

(1)と(2)の例は、イーサリアムメインネットにデプロイされたコントラクトにあり、(1)の方が一般的です(このプロポーザルの影響を受けません)。一方、(3)の使用例はこのプロポーザルにより深刻な影響を受けますが、著者らは、この形式の再入力保護の例を見つけることができませんでした(ただし、網羅的な検索ではありません)。

この出現分布 - (1)が多数、(2)がいくつか、(3)がゼロ - は、著者らが期待するものです。なぜなら:

 * `msg.sender`がEOAであるかどうかを`tx.origin`なしで判断するのは難しい(不可能かもしれない)。
 * 原子的サンドイッチ攻撃から安全なのは最上位のコンテキストだけであり、`tx.origin == msg.sender`がそれを検出する唯一の方法です。
 * これに対し、再入力を防ぐ直接的で柔軟な方法がたくさんあります。`msg.sender == tx.origin`は最上位のコンテキストでのみ真になるため、再入力を防ぐための隠れた道具になるのではなく、より一般的なアプローチを使うべきです。

この制限を軽減する他のアプローチがあります:

 * EOAのコンテキストで`CALL*`命令を使用する際に、`tx.origin`を定数`ENTRY_POINT`アドレスに設定する。
 * `tx.origin`を送信者または署名者のアドレスから派生した特別なアドレスに設定する。
 * `tx.origin`がコードを設定することを禁止する。これにより、シンプルなバッチングユースケースが不可能になりますが、将来的に緩和される可能性があります。

### 将来のアカウントアブストラクションとの互換性

このEIPは、[ERC-4337](./eip-4337.md)やRIP-7560の細かい詳細を過度に制度化することなく、エンドゲームのアカウントアブストラクションとの互換性が非常に高くなるように設計されています。

具体的には:

* ユーザーが署名する必要があるコードは、実際の既存のERC-4337ウォレットコードそのものになる可能性があります。
* 使用されるコードパスウェイの多くは(すべてではありませんが)、純粋なスマートコントラクトウォレットの世界でも「意味を持ち続ける」可能性があります。
* したがって、「別個のコードエコシステムを作成する」問題を回避できます。なぜなら、ある程度まで同じエコシステムになるためです。「エンドゲームAA」の下でより「ネイティブ」な方法で行うべきワークフローがいくつかあるが、これは比較的小さな部分集合です。
* 無用になる新しいオペコードを追加する必要がありません。
* ERC-4337バンドルに含めるために、EOAをコントラクトとしてマスクアップすることを可能にします。これは既存の`EntryPoint`と互換性があります。
* これが実装されたら、EOAを永続的に移行することを可能にするのは「たった1行のコード」です: 最後にコードを空に設定しないフラグを追加するだけです。

## 下位互換性

このEIPは、そのアカウントからのトランザクションの結果としてのみアカウントの残高が減少できるという不変条件を破ります。また、トランザクションの実行が開始された後にEOAのnonceが増加しないという不変条件も破ります。これらの破壊には、メモリプールの設計や包含リストなどの他のEIPに影響があります。ただし、外部トランザクションに静的にリストされているアカウントであるため、トランザクションの伝播ルールを変更して競合するトランザクションを転送しないようにすることができます。

## セキュリティ上の考慮事項

### 安全な委任

以下は、委任コントラクトが警戒し、アカウントの権限から署名を要求すべき(非網羅的な)チェック/落とし穴/条件の一覧です:

 * リプレイ保護 - (nonceなど)は委任者によって実装され、署名されるべきです。そうでないと、悪意のあるアクターが署名を再利用し、その効果を繰り返すことができます。
 * `value` - これがないと、悪意のあるスポンサーが被後援者に予期せぬ影響を与える可能性があります。
 * `gas` - これがないと、悪意のあるスポンサーが被後援者をガス切れさせ、失敗させる可能性があります。
 * `target` / `calldata` - これらがないと、悪意のあるアクターが任意のコントラクトの任意の関数を呼び出す可能性があります。

実装が不適切な委任者は、署名者のEOAに対する完全な支配を可能にする*可能性があります*。

### `tx.origin`としてコードを設定する

EIP-7702の送信者にコードの設定を許可することで、

 * `tx.origin`に依存する原子的サンドイッチ保護を破る可能性があります。
 * `require(tx.origin == msg.sender)`スタイルの再入力ガードを破る可能性があります。

このEIPの著者は、この許可のリスクが、根拠の章で説明した理由により許容可能であると考えています。

### スポンサー付きトランザクションリレーヤー

`authorized`アカウントが、承認を無効にする(つまり、アカウントのnonceを増やす)または関連する資産をアカウントから掃き出すことで、スポンサー付きトランザクションリレーヤーにガスを使わせる可能性があります。リレーヤーは、ボンドの預託や評判システムの実装など、これらのケースを念頭に置いて設計する必要があります。

## 著作権

著作権およびそれに関連する権利は[CC0](../LICENSE.md)によって放棄されています。