---
original: 1626b5b24a206f1e85242af43c150dc24ce822190a796755a0bb89a332c3ce5c
---

---
eip: 7702
title: EOAアカウントコードの設定
description: 実行中にEOAのコードを設定する新しいトランザクションタイプの追加
author: Vitalik Buterin (@vbuterin), Sam Wilson (@SamWilsn), Ansgar Dietrichs (@adietrichs), Matt Garnett (@lightclient)
discussions-to: https://ethereum-magicians.org/t/eip-set-eoa-account-code-for-one-transaction/19923
status: レビュー
type: 標準トラック
category: コア
created: 2024-05-07
requires: 2, 2718, 2929, 2930, 3541, 3607
---

## 要約

`[chain_id, address, nonce, y_parity, r, s]`の認証タプルのリストを含む新しいトランザクションタイプを追加します。各タプルに対して、署名アカウントのコードに委任指定子`(0xef0100 ++ address)`を書き込みます。すべてのコード読み取り操作は、指定子が指すコードを読み込む必要があります。

## 動機

EOAに短期的な機能改善を追加し、アプリケーションの使いやすさを向上させ、場合によってはセキュリティを改善することに大きな関心があります。特に3つの応用例があります：

* **バッチ処理**：同じユーザーからの複数の操作を1つのアトミックなトランザクションで行うことができます。一般的な例として、[ERC-20](./eip-20.md)の承認とその承認の使用があり、これは現在DEXで2つのトランザクションを必要とする一般的なワークフローです。バッチ処理の高度なユースケースでは、依存関係が含まれることがあります：最初の操作の出力が2番目の操作の入力の一部となります。
* **スポンサーシップ**：アカウントXがアカウントYの代わりにトランザクションの費用を支払います。アカウントXはこのサービスに対して他のERC-20で支払われる可能性があります。または、アプリケーション運営者がユーザーのトランザクションを無料で含めることもあります。
* **特権の縮小**：ユーザーはサブキーに署名し、アカウントへのグローバルアクセスよりもはるかに弱い特定の権限を与えることができます。例えば、ETHではなくERC-20トークンのみを使用する権限や、1日あたり総残高の1%までしか使用できない権限、特定のアプリケーションとのみ対話する権限などが考えられます。

## 仕様

### パラメータ

|     パラメータ            | 値      |
| ------------------------ | ------- |
| `SET_CODE_TX_TYPE`       | `0x04`  |
| `MAGIC`                  | `0x05`  |
| `PER_AUTH_BASE_COST`     | `2500`  |
| `PER_EMPTY_ACCOUNT_COST` | `25000` |

### コード設定トランザクション

[EIP-2718](./eip-2718.md)の新しいトランザクションタイプ「コード設定トランザクション」を導入します。`TransactionType`は`SET_CODE_TX_TYPE`で、`TransactionPayload`は以下のRLPシリアル化です：

```
rlp([chain_id, nonce, max_priority_fee_per_gas, max_fee_per_gas, gas_limit, destination, value, data, access_list, authorization_list, signature_y_parity, signature_r, signature_s])

authorization_list = [[chain_id, address, nonce, y_parity, r, s], ...]
```

認証リストの項目が以下のようにデコードできない場合、トランザクションは無効とみなされます：

* `chain_id`：符号なし256ビット整数。
* `nonce`：符号なし64ビット整数。
* `address`：20バイトの配列。
* `y_parity`：値0または1。
* `r`：符号なし256ビット整数。
* `s`：符号なし256ビット整数で、[EIP-2](./eip-2.md)で指定された`secp256k1n/2`以下の値。

外部トランザクションの`chain_id`、`nonce`、`max_priority_fee_per_gas`、`max_fee_per_gas`、`gas_limit`、`destination`、`value`、`data`、`access_list`フィールドは、[EIP-4844](./eip-4844.md)と同じセマンティクスに従います。*注意：これは、nullの宛先が無効であることを意味します。*

`authorization_list`は、署名者がEOAのコンテキストで実行したいコードのアドレスを格納するタプルのリストです。`authorization_list`の長さがゼロの場合、トランザクションは無効とみなされます。

このトランザクションの[EIP-2718](./eip-2718.md) `ReceiptPayload`は`rlp([status, cumulative_transaction_gas_used, logs_bloom, logs])`です。

#### 動作

トランザクションの実行開始時、送信者のnonceをインクリメントした後、各`[chain_id, address, nonce, y_parity, r, s]`タプルに対して以下を実行します：

1. `authority = ecrecover(keccak(MAGIC || rlp([chain_id, address, nonce])), y_parity, r, s]`
2. chain idが0またはチェーンの現在のIDであることを確認します。
3. `authority`を`accessed_addresses`（[EIP-2929](./eip-2929.md)で定義）に追加します。
4. `authority`のコードが空であるか、すでに委任されていることを確認します。
5. `authority`のnonceが`nonce`と等しいことを確認します。
6. `authority`がトライに存在する場合、グローバルリファンドカウンターに`PER_EMPTY_ACCOUNT_COST - PER_AUTH_BASE_COST`のガスを追加します。
7. `authority`のコードを`0xef0100 || address`に設定します。これは委任指定子です。
8. `authority`のnonceを1増やします。

上記のステップのいずれかが失敗した場合、直ちにそのタプルの処理を停止し、リスト内の次のタプルに進みます。同じauthorityに対して複数のタプルがある場合、リスト内の最後の出現のアドレスを使用してコードを設定します。

認証タプルの署名者は、トランザクションの`tx.origin`とは異なる場合があることに注意してください。

##### 委任指定子

委任指定子は、[EIP-3541](./eip-3541.md)で禁止されたオペコード`0xef`を使用して、コードが特別な目的を持つことを示します。この指定子は、すべてのコード取得操作がアカウントの観察可能なコードを埋めるためにアドレスポインタに従うことを要求します。以下の命令が影響を受けます：`EXTCODESIZE`、`EXTCODECOPY`、`EXTCODEHASH`、`CALL`、`CALLCODE`、`STATICCALL`、`DELEGATECALL`。

例えば、`EXTCODESIZE`は委任指定子を表す`23`ではなく、`address`が指すコードのサイズを返します。同様に、`CALL`は`address`からコードを読み込み、`authority`のコンテキストで実行します。

委任指定子が別の指定子を指し、潜在的な指定子のチェーンやループを作成する場合、クライアントは最初のコードのみを取得し、指定子チェーンの追跡を停止する必要があります。

#### ガスコスト

新しいトランザクションの固有コストは[EIP-2930](./eip-2930.md)から継承され、具体的には`21000 + 16 * 非ゼロコールデータバイト + 4 * ゼロコールデータバイト + 1900 * アクセスリストストレージキー数 + 2400 * アクセスリストアドレス数`です。さらに、`PER_EMPTY_ACCOUNT_COST * 認証リストの長さ`のコストを追加します。

トランザクション送信者は、有効性や重複に関係なく、すべての認証タプルの費用を支払います。

委任されたコードの解決中にコード読み取り命令が冷たいアカウントにアクセスする場合、通常のコストに加えて[EIP-2929](eip-2929.md)の`COLD_ACCOUNT_READ_COST`である`2600`ガスの追加コストを加え、アカウントを`accessed_addresses`に追加します。それ以外の場合は、`WARM_STORAGE_READ_COST`である`100`のコストを評価します。

#### トランザクションの発生

[EIP-3607](./eip-3607.md)で設定された制限を変更し、コードが有効な委任指定子（つまり`0xef0100 || address`）であるEOAがトランザクションを発生させ続けることを許可します。他のコード値を持つアカウントはトランザクションを発生させることはできません。

## 根拠

### イニットコードなし

イニットコードの実行は多くの理由で望ましくありません。主な懸念は、それが不自然だということです。イニットコードはコントラクトの初期化とデプロイを目的としています。このEIPでは、EOAにコードをデプロイするのが適切かどうかを決定する新しい役割を担うことになります。ユーザーが一般的なトランザクションのコールデータとバンドルされた操作も持っている場合にのみ、アカウントにコードをデプロイしたいと想定してみましょう。これにより、EOAはアカウントで実行されるコードをいつどのように制御するかについて独自の力を持つことになります。[EIP-7702](./eip-7702.md)は書かれた通りまだある程度これを許可していますが、決定におけるプログラム可能性の欠如により、ウォレットは多くの認証タプルに署名せず、代わりに設定可能なプロキシを指す1つのタプルにのみ署名することに焦点を当てることを強制されます。これにより、EOAはスマートコントラクトウォレットと同様の経験を得ることができます。

さらに、トランザクション内のイニットコードは通常トランザクション内で伝播されます。つまり、認証タプルに含まれ、署名される必要があります。最小のイニットコードは約15バイトで、単に外部アドレスからコントラクトコードをコピーするだけです。総コストは`16 * 15 = 240`のコールデータコスト、[EIP-3860](./eip-3860.md)のコスト`2 * 15 = 30`、約`150`のランタイムコストとなります。つまり、アカウントの準備だけで約`500`の追加ガスが消費されます。外部アカウントからコピーしない場合は、1200+ガスがさらに消費される可能性が高いです。

### テンプレートによる作成

イニットコードの有無にかかわらず、ユーザーがアカウントで実行したいコードを指定する方法についての疑問があります。主な2つのオプションは、トランザクションでバイトコードを直接指定するか、コードへのポインタを指定することです。最も単純なポインタは、オンチェーンにデプロイされた一部のコードのアドレスです。

コスト分析により答えは明確です。最小のプロキシは約50バイトで、アドレスは20バイトです。30バイトの差は有用な追加機能を提供せず、チェーン上で何十億回も非効率的に複製されることになります。

さらに、コードを直接指定することで、EOAがトランザクションのコールデータで指定された任意のコードを実行する新しい独自の能力を持つことが可能になります。

### 命令禁止の欠如

EVMにおける一貫性は、実装の観点からもユーザーの理解の観点からも価値のある特性です。EOAのコンテキストでいくつかの命令ファミリーの禁止を検討しましたが、著者らはそうする説得力のある理由がないと感じています。これにより、スマートコントラクトウォレットとEOAスマートコントラクトウォレットが異なるコントラクト開発の道を進むことを強制することになります。

禁止が検討された主な命令ファミリーは、ストレージ関連と契約作成関連でした。ストレージ命令を禁止しないという決定は、主にスマートコントラクトウォレットにとってのその重要性に基づいています。スマートコントラクトウォレットが呼び出す外部ストレージコントラクトを持つことは可能ですが、不必要に非効率的です。将来的に、新しい状態スキームにより、特定のストレージスロットへのアクセスが大幅に安くなる可能性があります。これは、ストレージコントラクトではサポートされないスマートコントラクトウォレットが非常に活用したい機能です
作成命令は他の類似のEIPでも禁止が検討されましたが、このEIPではEOAがトランザクション内で価値を使用することを許可しているため、トランザクション内でnonceを増やし、保留中のトランザクションを無効にすることへの懸念は重要ではありません。これの興味深い副産物として、EIP-7702とCREATE2を組み合わせることで、手数料市場のパラメータにコミットすることなく、特定のバイトコードをアドレスにデプロイすることにコミットできるようになります。これにより、ユニバーサルなクロスチェーンコントラクトデプロイメントの長年の問題が解決されます。

### 署名構造

このEIPの署名スキームは柔軟な設計パターンをサポートし、`address`への完全な委任と、より保護された`address`への委任の両方を可能にします。

#### コードポインタ

コードポインタに署名する際の考慮事項の1つは、そのアドレスが他のチェーンでどのコードを指す可能性があるかということです。一部のユースケースでは、デプロイメントが決定論的であることを確認する労力を費やすことが望ましくない場合があります。そのような状況では、認証の範囲を制限するためにチェーンIDを設定することができます。ウォレットプロキシへの委任など、ユニバーサルなデプロイメントが望ましい他の状況では、すべてのEIP-7702チェーンで有効になるようにチェーンIDを0に設定することが可能です。ウォレット開発者は、クロスチェーンコードの可変性が問題にならないように、単一のEIP-7702認証メッセージをウォレットにハードコードすることができます。

チェーンIDを追加する代替案として、アドレスが指すコードに署名することが考えられます。これは、認証タプルのオンチェーンサイズを最小限に抑えながら、アカウントで実行される実際のコードの特異性を維持するという利点があるように見えます。しかし、この形式の残念な問題は、各認証タプルの署名者を決定するためにデータベース検索を課すことです。この課題自体がトランザクションの伝播に十分な複雑さを生み出すように思われるため、避けることにし、単純にアドレスに直接署名することにしました。

#### プロトコル内での取り消し

このEIPの以前のバージョンや類似のEIPとは異なり、委任指定子は、アカウントの現在のnonceで新しいターゲットにEIP-7702認証に署名して送信することで、いつでも取り消すことができます。そのような行動がない限り、委任は永続的に有効なままです。

### 自己スポンサー：`tx.origin`がコードを設定することを許可

`tx.origin`がコードを設定することを許可すると、外部トランザクションの送信者が署名アカウントとなる単純なトランザクションバッチ処理が可能になります。現在2つの別々のトランザクションを必要とするERC-20の承認後転送パターンは、この提案により1つのトランザクションで完了できるようになります。

EOAにコードが存在すると、自己スポンサーのEIP-7702トランザクションでは、EOAのコードが呼び出しをディスパッチするたびに`msg.sender == tx.origin`が可能になります。EIP-7702がなければ、この状況はトランザクションの最上位実行レイヤーでのみ発生する可能性がありました。したがって、このEIPはその不変性を破り、`require(msg.sender == tx.origin)`チェックを含むスマートコントラクトに影響を与えます。このチェックは少なくとも3つの目的で使用されています：

 1. `msg.sender`がEOAであることを確認する（`tx.origin`は常にEOAでなければならないため）。この不変性は実行レイヤーの深さに依存せず、したがって影響を受けません。
 2. フラッシュローンのような原子的なサンドイッチ攻撃から保護する。これらの攻撃は、同じ原子的なトランザクションの一部としてターゲットコントラクトの実行の前後に状態を変更する能力に依存しています。この保護はこのEIPによって破られます。ただし、このように`tx.origin`に依存することは悪い慣行とみなされ、マイナーがブロックにトランザクションを条件付きで含めることですでに回避できます。
 3. リエントランシーを防ぐ。

(1)と(2)の例はEthereumメインネットにデプロイされたコントラクトで見つかり、(1)がより一般的です（そしてこの提案の影響を受けません）。一方、ユースケース(3)はこの提案によってより深刻な影響を受けますが、このEIPの著者らは、この形式のリエントランシー保護の例を見つけることができませんでした（ただし、検索は網羅的ではありませんでした）。

この発生分布—多くの(1)、いくつかの(2)、そして(3)がない—は、このEIPの著者らが予想したとおりです。なぜなら：

 * `tx.origin`なしで`msg.sender`がEOAであるかどうかを判断することは困難（不可能ではないにしても）です。
 * 原子的なサンドイッチ攻撃から安全な唯一の実行コンテキストは最上位のコンテキストであり、`tx.origin == msg.sender`はそのコンテキストを検出する唯一の方法です。
 * 対照的に、リエントランシーを防ぐための直接的で柔軟な方法が多くあります（例：一時的なストレージ変数の使用）。`msg.sender == tx.origin`は最上位のコンテキストでのみ真であるため、他のより一般的なアプローチよりも、リエントランシーを防ぐための不明瞭なツールとなるでしょう。

この制限を緩和するための他のアプローチで、不変性を破らないものがあります：

 * EOAのコンテキストで`CALL*`命令を使用する際に、`tx.origin`を定数の`ENTRY_POINT`アドレスに設定する。
 * `tx.origin`を送信者または署名者アドレスから派生した特別なアドレスに設定する。
 * `tx.origin`がコードを設定することを禁止する。これにより単純なバッチ処理のユースケースが不可能になりますが、将来的に緩和される可能性があります。

### 将来のアカウント抽象化との前方互換性

このEIPは、[ERC-4337](./eip-4337.md)やRIP-7560の細かい詳細を過度に固定化することなく、エンドゲームのアカウント抽象化と非常に前方互換性があるように設計されています。

具体的には：

* ユーザーが署名する必要があるコードは、文字通り既存のERC-4337ウォレットコードである可能性があります。
* 使用される「コードパスウェイ」は、多くの場合（すべてではないかもしれませんが）、純粋なスマートコントラクトウォレットの世界でも「意味をなす」コードパスウェイです。
* したがって、「2つの別々のコードエコシステムを作成する」という問題を避けることができます。なぜなら、大部分が同じエコシステムになるからです。この解決策の下では一部のワークフローが回避策を必要とし、「エンドゲームAA」の下では「よりネイティブ」に行われる方が良いものもありますが、これは比較的小さなサブセットです。
* ポストEOAの世界で無用で邪魔になるようなオペコードを追加する必要がありません。
* EOAが既存の`EntryPoint`と互換性のある方法でERC-4337バンドルに含まれるようにコントラクトとして偽装することを可能にします。
* これが実装されれば、EOAが永続的に移行できるようにすることは「たった1行のコード」です：最後にコードを空に戻さないようにフラグを追加するだけです。

## 後方互換性

このEIPは、アカウントの残高がそのアカウントから発生するトランザクションの結果としてのみ減少するという不変性を破ります。また、EOAのnonceがトランザクション実行開始後に増加しない可能性があるという不変性も破ります。これらの破壊は、メモリプールの設計や、インクルージョンリストなどの他のEIPに影響を与えます。ただし、アカウントは外部トランザクションで静的にリストされているため、競合するトランザクションが転送されないようにトランザクション伝播ルールを変更することが可能です。

## セキュリティに関する考慮事項

### 安全な委任

以下は、委任コントラクトが注意すべきチェック/落とし穴/条件の非網羅的なリストで、アカウントの権限から署名を要求する必要があります：

 * リプレイ保護 -- （例：nonce）は委任者によって実装され、署名される必要があります。これがないと、悪意のある行為者が署名を再利用し、その効果を繰り返す可能性があります。
 * `value` -- これがないと、悪意のあるスポンサーが被呼び出し側に予期しない影響を与える可能性があります。
 * `gas` -- これがないと、悪意のあるスポンサーが被呼び出し側のガス不足を引き起こし、失敗させる可能性があります。
 * `target` / `calldata` -- これらがないと、悪意のある行為者が任意のコントラクトの任意の関数を呼び出す可能性があります。

不適切に実装された委任は、*悪意のある行為者が署名者のEOAをほぼ完全に制御することを可能にする*可能性があります。

### `tx.origin`としてのコード設定

EIP-7702の送信者がコードを設定することを許可すると、以下の可能性があります：

 * `tx.origin`に依存する原子的なサンドイッチ保護を破壊する；
 * `require(tx.origin == msg.sender)`スタイルのリエントランシーガードを破壊する。

このEIPの著者らは、根拠のセクションで概説した理由により、これを許可するリスクは許容可能であると考えています。

### スポンサー付きトランザクションリレー

`authorized`アカウントが、認証を無効にする（つまり、アカウントのnonceを増やす）か、関連する資産をアカウントから引き出すことで、スポンサー付きトランザクションリレーにガスを消費させ、どちらからも償還されない可能性があります。リレーはこれらのケースを考慮して設計される必要があり、おそらく保証金を預けることを要求するか、評判システムを実装することで対応できます。

### 初期化のフロントランニング

スマートコントラクトウォレット開発者は、実行なしでアカウントにコードを設定することの影響を考慮する必要があります。通常、コントラクトはイニットコードを実行してアカウントに配置する正確なコードを決定することでデプロイされます。これにより、開発者は同時にストレージスロットを初期化する機会を得ます。アカウントの初期値は、作成トランザクションの場合はEOAによって署名されるか、イニットコードのハッシュからコントラクトのアドレスを決定論的に計算することでコミットされるため、観察者によって置き換えることはできません。

このEIPは、開発者に委任中にイニットコードを実行してストレージスロットを設定する機会を提供しません。彼らが制御するアカウントで委任の初期化を観察者がフロントランニングすることからアカウントを保護するために、スマートコントラクトウォレット開発者は、セットアップ目的のアカウントへの初期コールデータがEOAのキーを使用してecrecoverで署名されていることを確認する必要があります。これにより、アカウントが望ましい値でのみ初期化されることが保証されます。

### トランザクションの伝播

委任指定子を通じてEOAがスマートコントラクトとして振る舞うことを許可することは、トランザクションの伝播にいくつかの課題をもたらします。従来、EOAはトランザクションを通じてのみ価値を送信することができました。この不変性により、ノードはそのアカウントのトランザクションの有効性を静的に判断することができました。言い換えれば、1つのトランザクションは送信者のアカウントからの保留中のトランザクションのみを無効にすることができました。

このEIPにより、他のアカウントからのトランザクションを古くする可能性が生じます。これは、EOAがコードに委任すると、その
コードが誰でもトランザクション中のどの時点でも呼び出すことができるようになるためです。アカウントの残高が静的な方法で掃除されたかどうかを知ることは不可能になります。

これに対していくつかの緩和策がありますが、著者らは、非ゼロの委任指定子を持つEOAに対して、クライアントが1つ以上の保留中のトランザクションを受け入れないことを推奨しています。これにより、1つのトランザクションによって無効化される可能性のあるトランザクションの数を最小限に抑えます。別の選択肢として、EIP-7702トランザクションを拡張し、呼び出し元がトランザクション中に「ハイドレート」したいアカウントのリストを含めることができます。これらのアカウントは、そのようなリストに含まれるEIP-7702トランザクションに対してのみ委任されたコードとして振る舞い、クライアントが保留中のトランザクションを静的に分析し推論する能力を回復させます。

関連する問題として、EOAのnonceがトランザクションごとに複数回増加する可能性があります。クライアントはすでにより悪い状況（上記で説明）で堅牢である必要があるため、これは大きなセキュリティ上の懸念ではありません。ただし、クライアントはこの動作が可能であることを認識し、それに応じてトランザクションの伝播を設計する必要があります。

## 著作権

Copyright and related rights waived via [CC0](../LICENSE.md).