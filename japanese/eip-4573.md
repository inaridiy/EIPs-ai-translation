---
original: 61d0b7b6e967c98047929894ea136914f499c2595839c717d1d2ffaa76391a58
---

---
eip: 4573
title: EVMプロシージャの手順
description: EVMプロシージャのサポートを導入します。
status: 停滞
type: Standards Track
category: Core
author: Greg Colvin (@gcolvin), Greg Colvin <greg@colvin.org>
discussions-to: https://ethereum-magicians.org/t/eip-4573-named-procedures-for-evm-code-sections/7776
created: 2021-12-16
requires: 2315, 3540, 3670, 3779, 4200
---

## 概要

EVMに5つの命令が導入され、名前付きのEVM_プロシージャ_を定義、呼び出し、返すことができるようになり、そのメモリ内の_呼び出しフレーム_にアクセスできるようになりました - `ENTERPROC`、`LEAVEPROC`、`CALLPROC`、`RETURNPROC`、`FRAMEADDRESS`。

## 動機

現在、Ethereumバイトコードには構文構造がなく、_サブルーチン_にも定義されたインターフェイスがありません。

我々は_プロシージャ_を追加することを提案します - 定義されたインターフェイスを介してのみ入力できる、区切られたコードブロックです。

また、EVMには現在_プロシージャ_のメモリ自動管理がありません。そのため、メモリ上のスタックにコールフレームを自動的に予約することも提案します。

_プロシージャ_の使用制約は、[EIP-3779](./eip-3779.md)の安全性を維持するために、コントラクト初期化時に検証される必要があります。有効なプログラムは、ガス切れや再帰的なスタックオーバーフロー以外の例外で停止しないはずです。

### 先行事例

用語は明確に定義されていませんが、Intel方式に従って、低レベルの概念を_サブルーチン_、高レベルの概念を_プロシージャ_と呼びます。違いは、_サブルーチン_はほとんど飛び先を知っているだけの飛び先に過ぎないのに対し、_プロシージャ_はインターフェイスが定義されており、スタックとしてメモリを管理するということです。[EIP-2315](./eip-2315.md)は_サブルーチン_を導入し、このEIPは_プロシージャ_を導入します。

## 仕様

### 命令

#### ENTERPROC (0x??) dest_section: uint8, dest_offset: uint8, n_inputs: uint16, n_outputs: uint16, n_locals: uint16
```
frame_stack.push(FP)
FP -= n_locals * 32
PC +- <length of immediates>
```
プロシージャのエントリポイントを示します
* `dest_section`の先頭から`dest_offset`オフセットの位置に
* `data stack`から`n_inputs`個の引数を取り、
* `data stack`に`n_outputs`個の値を返し、
* `frame stack`に`n_locals`ワードのデータを予約します。

プロシージャは`CALLPROC`からのみ入力できます。

#### LEAVEPROC (0x??)

```
   FP = frame_stack.pop()
   asm RETURNSUB
```
> `frame stack`をポップし、`RETURNSUB`を使って呼び出し元のプロシージャに戻ります。

プロシージャの終了を示します。各`ENTERPROC`には対応する`LEAVEPROC`が必要です。

*注: プロシージャの外部からプロシージャ本体(その`LEAVEPROC`を含む)に飛ぶことや、`ENTERPROC`に飛ぶことは、検証時に防止されなければなりません。`CALLPROC`がプロシージャに入る唯一の有効な方法です。*

#### CALLPROC (0x??) dest_section: uint16, dest_proc: uint16
 ```
   FP -= n_locals
   asm JUMPSUB <offset of section> + <offset of procedure>
```
> *スタックフレーム*を割り当て、制御と`JUMPSUB`を、コードの*M番目*(M=*dest_section*)のセクションの*N番目*(N=*dest_proc*)_プロシージャ_に転送します。*セクション0*は現在のコードセクション、それ以外のコードセクションは1から始まります。

*注: プロシージャが定義されており、必要な`n_inputs`ワードが`data stack`にあることを、検証時に示す必要があります。*

#### RETURNPROC (0x??)
```
   FP += n_locals
   asm RETURNSUB
```
> `frame stack`をポップし、`RETURNSUB`を使って呼び出し元のプロシージャに制御を返します。

*注: 約束された`n_outputs`ワードが`data stack`にあることを、検証時に示す必要があります。*

#### FRAMEADDRESS (0x??) offset: int16
```
asm PUSH2 FP + offset
```
> `FP + offset`のアドレスを`data stack`にプッシュします。

呼び出しフレームのデータは、`FP`に対する即値`offset`で指定されたアドレスにあります。

呼び出しフレームにデータを格納したり
```
PUSH 0xdada
FRAMEADDRESS 32
MSTORE
```
呼び出しフレームからデータを読み出したりするのに使用されます
```
FRAMEADDRESS 32
MLOAD
```

### メモリコスト

現在、`MSTORE`は次のように定義されています
```
   memory[stack[0]...stack[0]+31] = stack[1]
   memory_size = max(memory_size,floor((stack[0]+32)÷32)
```
* ここで`memory_size`は、_0_より上の有効なメモリワード数です。

我々は、メモリアドレスを符号付きとして扱うことを提案します。そのため、式は次のようになります
```
   memory[stack[0]...stack[0]+31] = stack[1]
   if (stack[0])+32)÷32) < 0
      negative_memory_size = max(negative_memory_size,floor((stack[0]+32)÷32))
   else
      positive_memory_size = max(positive_memory_size,floor((stack[0]+32)÷32))
   memory_size = positive_memory_size + negative_memory_size
```
* ここで`negative_memory_size`は_0_より下の有効なメモリワード数、
* `positive_memory_size`は_0_以上の有効なメモリワード数です。

### コールフレームスタック

これらの命令は、_プロシージャ_のローカルデータ用のフレームを割り当てて解放するために、`frame stack`を使用します。フレームメモリはメモリアドレス0から始まり、下方向、つまりより負のアドレス方向に成長します。各プロシージャが呼び出されるときにフレームが割り当てられ、返されるときに解放されます。

メモリは、フレームポインタ`FP`に対する相対アドレスや絶対アドレスで指定できます。`FP`は0から始まり、`CALLPROC`ごとにより負のアドレス方向に移動して各フレームを指し示し、`RETURNPROC`ごとにより正のアドレス方向に移動して前のフレームを指し示します。

同等に、EVMの2の補数演算では、`FP`は一般的な呼び出し規約と同様に、最高アドレスから下方向に移動します。

例えば、最初の`CALLPROC`で2ワードのデータを必要とするプロシージャを呼び出した後、`frame stack`は次のようになります

```
     0-> ........
         ........
    FP->
```
その後、3ワードのデータを必要とするプロシージャを`CALLPROC`すると、`frame stack`は次のようになります

```
     0-> ........
         ........
   -64-> ........
         ........
         ........
    FP->
```
その後、その手順から`RETURNPROC`すると、`frame stack`は次のようになります
```
     0-> ........
         ........
    FP-> ........
         ........
         ........
```
最後に`RETURNPROC`すると、次のようになります
```
    FP-> ........
         ........
         ........
         ........
         ........
```

## 根拠

ここにはそれほど新しいことはありません。[EIP-615](./eip-615.md)を洗練・リファクタリングし、他の機械に一般的な形に分割したものです。

この提案は、[EIP-2315](./eip-2315.md)のリターンスタックを使ってコールとリターンを管理し、[EIP-615](./eip-615.md)、[EIP-3336](./eip-3336.md)、[EIP-4200](./eip-4200.md)のアイデアを盗用しています。`ENTERPROC`は、EIP-615の`BEGINSUB`に相当します。EIP-615のように、`FP`を使ってコールフレームアドレスをトラッキングするフレームスタックを使いますが、EIP-3336やEIP-3337のように、コールフレームをデータスタックからメモリに移動させます。

コールフレームを通常のメモリと同様に扱えるようにすることで、C言語のようにスタック上の変数へのポインタを提供するのに役立ちます。

ここでのデザインモデルは、Intelx86アーキテクチャの_サブルーチン_と_プロシージャ_です。
* `JUMPSUB`と`RETURNSUB`(EIP-2315から - `CALL`と`RET`のように)は_サブルーチン_に飛び、そこから戻ります。
* `ENTERPROC` - `ENTER`のように - _プロシージャ_のスタックフレームを設定します。
* `CALLPROC`は`ENTERPROC`への`JUMPSUB`に相当します。
* `RETURNPROC`は早期の`LEAVEPROC`に相当します。
* `LEAVEPROC` - `LEAVE`のように - _プロシージャ_のスタックフレームを取り下げます。その後、`RETURNSUB`を実行します。

## 下位互換性

この提案はEVMの新しい命令を追加するものです。既存の命令のセマンティクスを削除または変更するものではないので、下位互換性の問題はないはずです。

## セキュリティ

これらの構造の安全な使用は、EIP-3779に従って完全に検証時に確認されなければなりません。そのため、実行時にセキュリティ上の問題はないはずです。

`ENTERPROC`と`LEAVEPROC`は、EIP-2315の`JUMPSUB`と`RETURNSUB`と同じ安全ルールに従う必要があります。さらに、次の制約が検証されなければなりません:

* 各`ENTERPROC`には対応する`LEAVEPROC`が必要で、_プロシージャ_の本体を区切らなければならない。
* _プロシージャ_をネストすることはできない。
* _プロシージャ_の本体(その`LEAVEPROC`を含む)の外部から、その本体に飛ぶことはできない。
* `BEGINPROC`に飛ぶことや、そこにステップすることはできない - `CALLPROC`のみ。
* 指定された`n_inputs`と`n_outputs`がスタックにあることを示す必要がある。

## 著作権
著作権およびそれに関連する権利は[CC0](../LICENSE.md)で放棄されています。