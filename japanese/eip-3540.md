---
original: a7e204f5607548c7c1c43d43f7c055bd298d006a63084ddf831432f1ad974825
---

---
eip: 3540
title: EOF - EVM Object Format v1
description: EOF は、デプロイ時に1回の検証で拡張可能でバージョン管理された EVM バイトコードのコンテナ形式です。
author: Alex Beregszaszi (@axic)、Paweł Bylica (@chfast)、Andrei Maiboroda (@gumb0)、Matt Garnett (@lightclient)
discussions-to: https://ethereum-magicians.org/t/evm-object-format-eof/5727
status: Review
type: Standards Track
category: Core
created: 2021-03-16
requires: 3541, 3860
---

## 概要

我々は、デプロイ時に1回の検証で拡張可能でバージョン管理された EVM のコンテナ形式を紹介します。ここで説明するバージョンは、コードとデータの分離という具体的な利点をもたらし、将来さまざまな変更を容易に導入できるようにします。この変更は、[EIP-3541](./eip-3541.md) で導入された予約バイトに依存しています。

要約すると、EOF バイトコードのレイアウトは以下のようになります:

```
magic, version, (section_kind, section_size_or_sizes)+, 0, <section contents>
```

## 動機

現在、オンチェーンにデプロイされた EVM バイトコードには事前定義された構造がありません。コードは通常、実行前にクライアントによって `JUMPDEST` 分析の範囲で検証されます。これは、オーバーヘッドだけでなく、新機能の導入や既存の機能の非推奨化にも課題があります。

コントラクト作成プロセス中にコードを検証することで、アカウントに追加のバージョンフィールドを設けることなくコードのバージョン管理ができます。バージョン管理は、特に大規模な変更(制御フローの大幅な変更やアカウントアブストラクションのような機能など)を導入または非推奨化する際に有用なツールです。

このEIPで説明する形式は、クライアントと言語に最小限の変更を加えて、シンプルで拡張可能なコンテナを導入し、検証を行います。

最初の具体的な機能は、コードとデータの分離です。このような分離は、レイヤー2スケーリングツール(Optimismなど)で使用されるオンチェーンコード検証機能にとって特に有益です。なぜなら、コードとデータ(デプロイメントコードと構築引数を含む)を区別できるからです。現在、これらのツールは a) デプロイ前に変更を加える必要があり、b) 脆弱な方法を実装し、c) 高価で制限的なジャンプ分析を実装しています。コードとデータの分離により、使いやすさと大幅なガス削減につながります。さらに、さまざまな(静的)分析ツールも恩恵を受けますが、オフチェーンツールは既存のコードに対応できるため、影響は小さくなります。

提案されている変更のうち、このフォーマットから恩恵を受けられるものは以下の通りです:

- `JUMPDEST` テーブルの導入(実行時の分析を回避する)や `JUMPDEST` の完全な削除
- 相対アドレスを使った静的ジャンプとジャンプテーブルの導入、動的ジャンプの禁止
- ワークアラウンドなしでのマルチバイトオペコード
- サブルーチンではなく個別のコードセクションとしての関数の表現
- アカウントアブストラクションなどの特殊用途のためのセクションの導入

## 仕様

この文書の中の "MUST"、"MUST NOT"、"REQUIRED"、"SHALL"、"SHALL NOT"、"SHOULD"、"SHOULD NOT"、"RECOMMENDED"、"NOT RECOMMENDED"、"MAY"、"OPTIONAL" というキーワードは、RFC 2119 およびRFC 8174 に記載されているように解釈されるものとします。

状態内のすべての EOF 形式のコントラクトが有効であることを保証するために、すでにデプロイされた(検証されていない)コントラクトが、このフォーマットとして認識されるのを防ぐ必要があります。これは、すでにデプロイされたコントラクトに存在しないバイト列を *magic* として選択することで実現します。

### 注記

コードが `MAGIC` で始まる場合、それは EOF 形式と見なされ、そうでない場合は *レガシー* コードと見なされます。明確にするために、`MAGIC` にバージョン番号 *n* を付けたものを *EOFn prefix* と呼びます。

EOF 形式のコントラクトは、別の EIP で導入される新しい命令を使って作成されます。

オペコード `0xEF` は現在未定義の命令なので、*スタックアイテムをポップせず、スタックアイテムをプッシュせず、実行時に例外的な中断を引き起こします。* つまり、レガシーの *initcode* や既にデプロイされたレガシーの *code* がこの命令で始まる場合も、引き続き実行が中断されます。

特に指定がない限り、すべての整数はビッグエンディアンのバイト順で符号化されています。

### コードの検証

新しいコントラクト作成時に *コードの検証* を導入します。これを実現するために、EVM Object Format (EOF) と呼ばれる形式を定義し、バージョンごとの有効性ルールセットを定義します。

レガシーコードは EOF コードの検証の影響を受けません。

コード検証はコントラクト作成時に行われ、別の EIP で詳しく説明されます。
EOF 形式自体と正式な検証については、以下のセクションで説明します。

### コンテナ仕様

EOF コンテナは、EOF バージョン番号とEOFセクションのリストを提供できるバイナリ形式です。

コンテナは EOF プレフィックスから始まります:

| 説明       | 長さ     | 値         |                    |
|------------|----------|------------|--------------------|
| magic      | 2バイト  | 0xEF00     |                    |
| version    | 1バイト  | 0x01–0xFF  | EOF バージョン番号 |

EOF プレフィックスの後には、少なくとも1つのセクションヘッダーが続きます。各セクションヘッダーには、`section_kind` と `section_size` または `section_size_list` の2つのフィールドが含まれています。`section_size_list` は、このタイプの複数のセクションが許可されている場合のサイズ値のリストで、アイテム数とアイテムが符号化されています。

| 説明             | 長さ     | 値           |                   |
|------------------|----------|--------------|-------------------|
| section_kind     | 1バイト  | 0x01–0xFF    | `uint8`           |
| section_size     | 2バイト  | 0x0000–0xFFFF| `uint16`          |
| section_size_list| 可変     | n/a          | `uint16, uint16+` |

セクションヘッダーのリストは、*セクションヘッダー終端バイト* `0x00` で終了します。本文のコンテンツはすぐに続きます。

#### コンテナの検証ルール

1. `version` は `0` であってはいけません。
2. `section_kind` は `0` であってはいけません。値 `0` は *セクションヘッダー終端バイト* に予約されています。
3. 少なくとも1つのセクション(したがってセクションヘッダー)が存在しなければなりません。
5. セクション外にはみ出るバイトが存在してはいけません。これには、最後のセクション後の余分なバイトも含まれます。

### EOF バージョン 1

EOF バージョン1は、このEIPを含む複数のEIPで構成されています。この仕様の一部の値は簡単に説明されているだけです。EOF の完全な範囲を理解するには、各EIPを詳しく確認する必要があります。

#### コンテナ

EOF バージョン1のコンテナは `header` と `body` で構成されています。

```
container := header, body
header := 
    magic, version, 
    kind_type, type_size, 
    kind_code, num_code_sections, code_size+,
    [kind_container, num_container_sections, container_size+,]
    kind_data, data_size,
    terminator
body := types_section, code_section+, container_section*, data_section
types_section := (inputs, outputs, max_stack_height)+
```

*注: `,` は連結演算子、`+` は前の項目を1つ以上と解釈し、`*` は前の項目を0個以上と解釈し、`[item]` は任意の項目と解釈します。*

#### ヘッダー

| 名称                  | 長さ     | 値           | 説明                                                                                                  |
|----------------------|----------|--------------|--------------------------------------------------------------------------------------------------------------|
| magic                 | 2バイト  | 0xEF00       |                                                                                                       |
| version               | 1バイト  | 0x01         | EOF バージョン                                                                                        |
| kind_type             | 1バイト  | 0x01         | タイプセクションのkindマーカー                                                                        |
| type_size             | 2バイト  | 0x0004-0x1000| コードセクション当たり4バイトの、タイプセクションコンテンツの長さを表す16ビットの符号なし整数(ビッグエンディアン) |
| kind_code             | 1バイト  | 0x02         | コードサイズセクションのkindマーカー                                                                  |
| num_code_sections     | 2バイト  | 0x0001-0x0400| コードセクションの数を表す16ビットの符号なし整数(ビッグエンディアン)                                   |
| code_size             | 2バイト  | 0x0001-0xFFFF| コードセクションコンテンツの長さを表す16ビットの符号なし整数(ビッグエンディアン)                       |
| kind_container        | 1バイト  | 0x03         | コンテナサイズセクションのkindマーカー                                                                |
| num_container_sections| 2バイト  | 0x0001-0x0100| コンテナセクションの数を表す16ビットの符号なし整数(ビッグエンディアン)                                |
| container_size        | 2バイト  | 0x0001-0xFFFF| コンテナセクションコンテンツの長さを表す16ビットの符号なし整数(ビッグエンディアン)                     |
| kind_data             | 1バイト  | 0x04         | データサイズセクションのkindマーカー                                                                  |
| data_size             | 2バイト  | 0x0000-0xFFFF| データセクションコンテンツの長さを表す16ビットの符号なし整数(ビッグエンディアン) (*)                   |
| terminator            | 1バイト  | 0x00         | ヘッダーの終端を示す                                                                                 |

(*) まだデプロイされていないコンテナの場合、実際のコンテンツ長よりも大きくなる可能性があります。

#### 本文

| 名称              | 長さ     | 値           | 説明                                                                                |
|-------------------|----------|--------------|------------------------------------------------------------------------------------|
| types_section     | 可変     | n/a          | コードセクションのメタデータを格納する                                               |
| inputs            | 1バイト  | 0x00-0x7F    | コードセクションが消費するスタック要素の数                                           |
| outputs           | 1バイト  | 0x00-0x7F    | コードセクションが返すスタック要素の数                                               |
| max_stack_height  | 2バイト  | 0x0000-0x03FF| コードセクションによって操作数スタックに置かれた最大要素数                            |
| code_section      | 可変     | n/a          | 任意のバイトコード                                                                   |
| container_section | 可変     | n/a          | 任意のEOF形式のコンテナ                                                             |
| data_section      | 可変     | n/a          | 任意のバイト列                                                                       |

タイプセクションのコンテンツの詳細については、[EIP-4750](./eip-4750.md)を参照してください。

**注**: `outputs` の特殊な値 `0x80` は、別のEIPで定義されている通り、非返却関数を示すものとされています。

#### EOF バージョン1の検証ルール

コンテナ形式に対して以下の有効性制約が課されます:

- `types_size` は4で割り切れる
- コードセクションの数は `types_size / 4` に等しい
- まだデプロイされていないコンテナの場合、データ本文の長さが `data_size` より短くなる可能性がある
- コンテナの総サイズは `MAX_INITCODE_SIZE`(EIP-3860で定義)を超えてはいけない

### 実行セマンティクスの変更

EOF コントラクトの場合:

- 実行は、コードセ
クション0の最初のバイトから始まる
- `CODESIZE`、`CODECOPY`、`EXTCODESIZE`、`EXTCODECOPY`、`EXTCODEHASH`、`GAS` は EOF コントラクトの検証で拒否され、代替手段はない
- `CALL`、`DELEGATECALL`、`STATICCALL` は EOF コントラクトの検証で拒否され、代替命令は別の EIP で導入される
- EOF コントラクトから非 EOF コントラクト(レガシーコントラクト、EOA、空アカウント)への `EXTDELEGATECALL`(`DELEGATECALL` の代替)は許可されず、呼び出し深さチェックが失敗した場合と同じ方法で失敗する。既存のプロキシコントラクトが EOF アップグレードを使えるよう、レガシーから EOF への経路は許可する

レガシーコントラクトの場合:

- `EXTCODECOPY` のターゲットアカウントが EOF コントラクトの場合、`EF00` から最大2バイトをコピーするように振る舞う。
- `EXTCODEHASH` のターゲットアカウントが EOF コントラクトの場合、`0x9dbf3648db8210552e9c4f75c6a1c3057c0ca432043bd648be15fe7be05646f5`(`EF00` のハッシュ)を返す。
- `EXTCODESIZE` のターゲットアカウントが EOF コントラクトの場合、2を返す。

**注** レガシーのターゲットの場合と同様に、`EXTCODECOPY`、`EXTCODEHASH`、`EXTCODESIZE` の上記の動作は、作成中の EOF コントラクトのターゲットには適用されず、コードのないアカウントと同じように報告される。

## 根拠

EVM や/またはアカウントのバージョン管理については、過去数年にわたって議論されてきました。この提案は、それらから学んでいます。
Ethereum Magicians Forum の "Ethereum account versioning" を参照すると、良い出発点になります。

### 実行時vs作成時の検証

この仕様では作成時の検証を導入しています。これは以下を意味します:

- *EOFn* プレフィックスを持つすべての作成済みコントラクトは、バージョン *n* のルールに従って有効です。これは非常に強力で有用な性質です。クライアントは、デプロイされたコードが適切に形式化されていることを信頼できます。
- 将来的には、EOF コンテナに `JUMPDEST` マップをシリアル化し、実行前に必要な暗黙の `JUMPDEST` 分析を排除することができます。
- または `JUMPDEST` 命令を完全に削除することができます。
- これは、EVM 命令や機能の非推奨化に役立ちます。
- 最大の欠点は、EOF コードのデプロイ時検証を2回のハードフォークで有効にしなければならないことです。ただし、最初のステップ([EIP-3541](./eip-3541.md))はロンドンですでにデプロイされています。

もう1つの選択肢は、EOF に対する実行時検証です。これは、コントラクトが実行される度に行われますが、クライアントは検証結果をキャッシュできる可能性があります。この *代替* アプローチには以下の特性があります:

- 検証がコンセンサスレベルの実行ステップであるため、常に完全なコードが必要になります。これは *コードのマークル化* を実用的でないものにします。
- 1回のハードフォークで有効化できます。
- 後方互換性が良い: `0xEF` バイトや *EOF prefix* で始まるデータコントラクトをデプロイできます。これは疑わしい利点ですが。

### MAGIC

1. 最初のバイト `0xEF` は、[EIP-3541](./eip-3541.md) によってこの目的のために予約されているため選択されました。

2. 2番目のバイト `0x00` は、**メインネット**にデプロイされた3つのコントラクトとの競合を避けるために選択されました:
   - `0xca7bf67ab492b49806e24b6e2e4ec105183caa01`: `EFF09f918bf09f9fa9`
   - `0x897da0f23ccc5e939ec7a53032c5e80fd1a947ec`: `EF`
   - `0x6e51d4d9be52b623a3d3a2fa8d3c5e3e01175cd0`: `EF`

3. パブリックテストネット(Goerli、Ropsten、Rinkeby、Kovan、Sepolia)のロンドンフォークブロック時点で、`0xEF` バイトで始まるコントラクトは存在しません。

**注**: このEIPは、有効なEOFではないバイトコードで始まるチェーンでは有効にしてはいけません。

### EOF バージョン番号は1から始まる

バージョン番号0は EOF では使用されず、レガシーコードを *EOF0* と呼ぶことができます。
また、実装では0のバージョン番号がレガシーコードを示すAPIを使う可能性があります。

### セクション構造

セクションについて、さまざまな質問を検討しました:

- ストリーミングヘッダー(つまり `section_header, section_data, section_header, section_data, ...`)は、他のフォーマット(WebAssemblyなど)で使用されています。編集可能なフォーマット(セクションの追加/削除)には便利です。EVM の場合は有用な機能ではありません。適用可能な小さな利点は、特定の "ヘッダー終端子" を必要としないことです。一方で、コードのチャンク化/マークル化とうまく連携しないようです。すべてのセクションヘッダーを1つのチャンクに持つことが好ましいからです。
- ヘッダー終端子を持つか、`number_of_sections` や `total_size_of_headers` をエンコードするか。どちらも、これらのフィールドがどの程度の大きさを持てるかという問題を提起します。終端子バイトは、サイズが小さすぎるという問題を回避できるように見えるので、この方法を選択しました。
- (EOF1) セクションサイズを固定16ビット値としてエンコードするか、可変長フィールド(LEB128など)として行うか。クライアント実装を単純化するため、16ビットで十分だと考えられるので、固定サイズを選択しました(EIP-170とEIP-3860で現在公開されているコードサイズ制限は24576バイトです)。将来的にこれが制限になる場合は、新しいEOFバージョンでフォーマットを変更できます。LEB128を使わないことで、オンチェーンのパースも大幅に単純化されます。
- 今後のすべてのEOFバージョンに共通のコンテナヘッダーの構造を持つべきかどうか。チャンク化とマークル化(verkleization)に最適化された将来のフォーマットを可能にするため、一般的に保ち、特定のEOFバージョンの構造のみを指定することにしました。

### データのみのコントラクト

[EIP-7480](./eip-7480.md#lack-of-extdatacopy)のセクション「Lack of `EXTDATACOPY`」を参照してください。

### EOF1 コントラクトは EOF1 コントラクトにのみ `DELEGATECALL` できる

現在、コントラクトは3つの異なる方法でセルフデストラクトできます(`SELFDESTRUCT`を直接使う、`CALLCODE`を間接的に使う、`DELEGATECALL`を間接的に使う)。[EIP-3670](./eip-3670.md)は最初の2つの可能性を無効化しますが、3つ目の可能性は残されています。EOF1 コントラクトが EOF1 コントラクトにのみ `DELEGATECALL` できるようにすることで、以下の強力な主張ができます: EOF1 コントラクトは決して破壊されることはありません。`SELFDESTRUCT` に基づく攻撃は EOF1 コントラクトに完全に消えます。これには、破壊されたライブラリコントラクト(Parity Multisigなど)も含まれます。

### EOF1 コンテナにはサイズ制限がある

EOF コンテナのサイズ制限をデプロイ時検証の上限として課すことで、EVM実装がコンテナの検証と処理を行えるようにする参照上限を提供します。EOF1 では `MAX_INITCODE_SIZE` が選択されました。これは、現在のコントラクト作成で許可されているものと同じです。

制限の主な理由の1つが `JUMPDEST` 分析に対する攻撃ベクトルを回避することですが、EOF はこの `JUMPDEST` 分析の必要性を排除し、デプロイ時分析のコスト構造を導入するため、将来的にはこの制限を緩和または撤廃できるかもしれません。

## 後方互換性

これは破壊的な変更です。なぜなら、`0xEF` で始まるコードは以前デプロイできず(実行すると例外的な中断が発生)、今後はそのサブセットがデプロイおよび正常に実行できるようになるためです。

`MAGIC` の選択により、チェーン上に存在する既存のコントラクトには新しいルールの影響はありません。

## セキュリティ上の考慮事項

予想される EOF 拡張により、検証は線形の計算量とメモリ使用量で行われると期待されます。
検証コストは十分にカバーされると考えています:

- [EIP-3860](./eip-3860.md) による *initcode* の場合
- *code* のデプロイ時の高コスト

## 著作権

著作権およびそれに関連する権利は [CC0](../LICENSE.md) で放棄されています。