---
original: e403a16f9f8067c0fc46aa3241f93400ea753ecaae883e85c39fe49bdb4658f7
---

---
eip: 1459
title: DNSによるノードの発見
description: 認証済み更新可能なEthereumノードリストをDNSを介して提供するスキーム。
author: Felix Lange (@fjl), Péter Szilágyi (@karalabe)
discussions-to: https://github.com/ethereum/devp2p/issues/50
status: 停滞中
type: Standards Track
category: Networking
created: 2018-09-26
requires: 778
---

## 概要

このドキュメントでは、認証済み、更新可能なEthereumノードリストをDNSを介して取得する方式について説明します。

## 動機

多くのEthereum クライアントには、ハードコーディングされたブートストラップノードリストが含まれています。これらのリストを更新するには、ソフトウェアの更新が必要です。現在のリストは小さいため、Ethereumネットワークに参加する初期エントリポイントの選択肢が少ないです。私たちは、数百のノードを含む大規模なノードリストを維持し、定期的に更新したいと考えています。

ここで説明するスキームは、クライアントのブートストラップノードリストの代替策で、同等のセキュリティと多くの追加の利点があります。ノード発見DHT(Distributed Hash Table)を探索して作成された大規模なリストは、ネットワークポリシーの制限により DHT に参加できないノードのフォールバックオプションとして機能できます。DNS ベースのノードリストは、Ethereumピアリングプロバイダにも有用な可能性があります。なぜなら、クライアントをプロバイダのリストを使用するように設定できるためです。

## 仕様

'ノードリスト'は、任意の長さの'ノードレコード'[EIP-778で定義]のリストです。リストは他のリストへのリンクを参照できます。リスト全体はsecp256k1秘密鍵で署名されます。クライアントがリストを検証するには、対応する公開鍵を知っている必要があります。

DNSノードリストを参照するには、クライアントは'enrtree'スキームのURLを使用します。URLには、リストを見つけられるDNS名と、リストに署名した公開鍵が含まれています。公開鍵はURLのユーザー名部分に含まれ、圧縮32バイトバイナリ公開鍵のBase32エンコーディング(RFC-4648)です。

例:

    enrtree://AM5FCQLWIZX2QFPNJAP7VUERCCRNGRHWZG3YYHIUV7BVDQ5FDPRT2@nodes.example.org

このURLは、'nodes.example.org'のDNS名にあるノードリストを参照し、公開鍵
`0x049f88229042fef9200246f49f94d9b77c4e954721442714e85850cb6d9e5daf2d880ea0e53cb3ac1a75f9923c2726a4f941f7d326781baa6380754a360de5c2b6`
によって署名されています。

### DNSレコードの構造

リスト内のノードは、DNSプロトコルを介して配布するためにメルクルツリーにエンコードされます。メルクルツリーのエントリはDNS TXTレコードに含まれています。ツリーのルートは、次のような内容のTXTレコードです:

    enrtree-root:v1 e=<enr-root> l=<link-root> seq=<sequence-number> sig=<signature>

ここで:

- `enr-root`と`link-root`は、ノードとリンクのサブツリーのルートハッシュを参照しています。
- `sequence-number`はツリーの更新シーケンス番号で、10進整数です。
- `signature`は、レコードの内容(「sig=」部分を除く)のkeccak256ハッシュに対するsecp256k1 ECシグネチャで、URL安全なBase64(RFC-4648)でエンコードされています。

サブドメイン上の他のTXTレコードは、ハッシュを3つのエントリタイプにマッピングします。エントリのサブドメイン名は、そのテキストコンテンツのkeccak256ハッシュ(省略形)のBase32エンコーディングです。

- `enrtree-branch:<h₁>,<h₂>,...,<hₙ>`は、サブツリーエントリのハッシュを含む中間ツリーエントリです。
- `enrtree://<key>@<fqdn>`は、別の完全修飾ドメイン名にある別のリストを指すリーフです。このフォーマットはURLエンコーディングと一致します。このタイプのエントリは、`link-root`によって指されるサブツリーにのみ表示されます。
- `enr:<node-record>`は、ノードレコードを含むリーフです。ノードレコードはURL安全なBase64文字列でエンコードされています。このタイプのエントリは、`enr-root`サブツリーにのみ表示されます。

ツリーの順序や構造は特に定義されていません。ツリーが更新されるたびに、シーケンス番号を増やす必要があります。任意のTXTレコードの内容は、UDP DNSパケットに課される512バイトの制限に収まる必要があります。これにより、`enrtree-branch`エントリに配置できるハッシュの数が制限されます。

ゾーンファイル形式の例:

    ; name                        ttl     class type  content
    @                             60      IN    TXT   enrtree-root:v1 e=JWXYDBPXYWG6FX3GMDIBFA6CJ4 l=C7HRFPF3BLGF3YR4DY5KX3SMBE seq=1 sig=o908WmNp7LibOfPsr4btQwatZJ5URBr2ZAuxvK4UWHlsB9sUOTJQaGAlLPVAhM__XJesCHxLISo94z5Z2a463gA
    C7HRFPF3BLGF3YR4DY5KX3SMBE    86900   IN    TXT   enrtree://AM5FCQLWIZX2QFPNJAP7VUERCCRNGRHWZG3YYHIUV7BVDQ5FDPRT2@morenodes.example.org
    JWXYDBPXYWG6FX3GMDIBFA6CJ4    86900   IN    TXT   enrtree-branch:2XS2367YHAXJFGLZHVAWLQD4ZY,H4FHT4B454P6UXFD7JCYQ5PWDY,MHTDO6TMUBRIA2XWG5LUDACK24
    2XS2367YHAXJFGLZHVAWLQD4ZY    86900   IN    TXT   enr:-HW4QOFzoVLaFJnNhbgMoDXPnOvcdVuj7pDpqRvh6BRDO68aVi5ZcjB3vzQRZH2IcLBGHzo8uUN3snqmgTiE56CH3AMBgmlkgnY0iXNlY3AyNTZrMaECC2_24YYkYHEgdzxlSNKQEnHhuNAbNlMlWJxrJxbAFvA
    H4FHT4B454P6UXFD7JCYQ5PWDY    86900   IN    TXT   enr:-HW4QAggRauloj2SDLtIHN1XBkvhFZ1vtf1raYQp9TBW2RD5EEawDzbtSmlXUfnaHcvwOizhVYLtr7e6vw7NAf6mTuoCgmlkgnY0iXNlY3AyNTZrMaECjrXI8TLNXU0f8cthpAMxEshUyQlK-AM0PW2wfrnacNI
    MHTDO6TMUBRIA2XWG5LUDACK24    86900   IN    TXT   enr:-HW4QLAYqmrwllBEnzWWs7I5Ev2IAs7x_dZlbYdRdMUx5EyKHDXp7AV5CkuPGUPdvbv1_Ms1CPfhcGCvSElSosZmyoqAgmlkgnY0iXNlY3AyNTZrMaECriawHKWdDRk2xeZkrOXBQ0dfMFLHY4eENZwdufn1S1o

### クライアントプロトコル

"mynodes.org"などのDNS名でノードを見つけるには:

1. その名前のTXTレコードを解決し、有効な"enrtree-root=v1"エントリが含まれているかどうかを確認します。エントリに含まれる`enr-root`ハッシュが"CFZUWDU7JNQR4VTCZVOJZ5ROV4"だとします。
2. 既知の公開鍵を使ってルートの署名を検証し、シーケンス番号が以前に見た番号以上であることを確認します。
3. ハッシュサブドメイン、例えば"CFZUWDU7JNQR4VTCZVOJZ5ROV4.mynodes.org"のTXTレコードを解決し、その内容がハッシュと一致することを確認します。
4. 見つかったエントリタイプに応じて次の手順を実行します:
   - `enrtree-branch`の場合: ハッシュのリストを解析し、それらを順次解決します(ステップ3)。
   - `enr`の場合: ノードレコードをデコードし、検証してローカルのノードストアにインポートします。

トラバーサル中、クライアントは無限ループに陥らないよう、既に解決したハッシュとドメインを追跡する必要があります。クライアントはツリーをランダムな順序で探索するのが最善です。

クライアント実装では、通常の操作中にツリー全体をダウンロードするのは避けるべきです。必要に応じてDNSを介してエントリを要求するのが much better です。つまり、クライアントがピアを探しているときに要求するのが良いでしょう。

## 根拠

### なぜDNSなのか?

DNSを配布メディアとして選択したのは、常に利用可能で、制限の厳しいネットワーク環境でも機能するためです。プロトコルは低遅延で、DNSクエリの応答は中間リゾルバーによってキャッシュできます。カスタムサーバーソフトウェアは不要です。ノードリストは、それぞれのクライアントライブラリを使ってCloudFlare DNS、dnsimple、Amazon Route 53などの任意のDNSプロバイダにデプロイできます。

### なぜメルクルツリーなのか?

メルクルツリーであるため、リストの認証にはルートの単一の署名で済みます。ハッシュサブドメインはリストの整合性を保護します。最悪の場合、中間リゾルバーがリストへのアクセスをブロックしたり、更新を許可しなかったりできますが、リストの内容を破損することはできません。シーケンス番号は、古いバージョンへの置き換えを防ぎます。

クライアント側での更新の同期は増分的に行えるので、大規模なリストにとって重要です。ツリーの個々のエントリは、単一のUDP パケットに収まるほど小さいため、基本的なUDP DNSしか利用できない環境との互換性が確保されます。ツリー形式はキャッシュリゾルバーとも相性が良いです: ツリーのルートだけ短いTTLを持てば良いからです。中間エントリとリーフは数日間キャッシュできます。

### リンクサブツリーが存在する理由は?

リスト間のリンクにより、連携とWeb of Trust機能が可能になります。大規模なリストの運営者は、メンテナンスを他のリストプロバイダに委譲できます。2つのノードリストがお互いにリンクしていれば、ユーザーはどちらのリストを使っても両方のノードにアクセスできます。

リンクサブツリーは、ENRを含むツリーとは別になっています。これにより、クライアント実装がこれらのツリーを独立して同期できるようになります。可能な限り多くのノードを取得したいクライアントは、まずリンクツリーを同期し、リンク先の名前をすべて同期対象に追加します。

## セキュリティ上の考慮事項

DNSを介した発見は、DHT経由の発見よりも安全性が低いです。なぜなら、定期的にレコードを公開する信頼できる当事者に依存しているためです。その当事者は、自分がコントロールするノードレコードしか公開しないことで、ブートストラッピングノードをイクリプスできてしまいます。

## 著作権

著作権およびそれに関連する権利は[CC0](../LICENSE.md)によって放棄されています。