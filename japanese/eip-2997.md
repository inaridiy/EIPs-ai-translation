---
original: c4e2e9cee5eab2ab15483dfa8cdf11f1a355875e2fa285b6747872e4968e13ff
---

---
eip: 2997
title: IMPERSONATECALL オペコード
author: Sergio Demian Lerner (@SergioDemianLerner)
discussions-to: https://ethresear.ch/t/impersonatecall-opcode/8020
category: Core
type: Standards Track
status: Stagnant
created: 2020-09-24
---

## 概要

新しいオペコード `IMPERSONATECALL` (`0xf6`) を追加します。これは `CALL (0xF1)` に似ていますが、送信者を偽装できます。つまり、呼び出し先では、実際の呼び出し元とは異なる送信者が表示されます。偽装された送信者アドレスは、実際の呼び出し元アドレスとソルトから派生します。

## 動機

この提案により、EIP-712 ベースのメッセージによって制御可能な、複数ユーザーをサポートするウォレット (マルチユーザーウォレット) が実現できます。これにより、メタトランザクションが可能になります。マルチユーザーウォレットは、通常のオンチェーントランザクションと同じアドレス空間を維持しつつ、トランザクションを一括処理するロールアップのようなことも可能になります。そのため、ユーザーのウォレットをアップグレードする必要がありません。
さらに、スポンサー企業が、ユーザー全員のための非管理型スマートウォレットを展開したい場合があります。スポンサーは、各ユーザーのコントラクトの展開コストを事前に支払いたくありません。カウンターファクチュアルコントラクト作成により、これが可能になりますが、ユーザーがイーサやトークンを初めて送金するときにスマートウォレット (またはプロキシコントラクト) を作成する必要があります。この提案では、この追加コスト (少なくとも 42,000 gas/ユーザー) を回避できます。

## 仕様

`IMPERSONATECALL`: `0xf6`は、7つのオペランドを取ります:

- `gas`: コードの実行に使用できるガス量
- `to`: 実行するコードの宛先アドレス
- `in_offset`: メモリ上の入力データの開始位置
- `in_size`: 入力データのサイズ (バイト単位)
- `ret_offset`: メモリ上の出力データの開始位置
- `ret_size`: 出力用のスクラッチパッドのサイズ
- `salt`: 32バイトの値 (スタックアイテム)

### 偽装された送信者のアドレス計算

偽装された送信者アドレスは、`keccak256( 0xff ++ address ++ salt ++ zeros32)[12:]`として計算されます。

- `0xff` は1バイトです。
- `address` は常に20バイトで、実際の呼び出し元コントラクトのアドレスを表します。
- `salt` は常に32バイトです。
- `zeros32` は32バイトのゼロ値です。

このスキームは `CREATE2` アドレス派生を模倣しますが、`CREATE2` アドレス空間と実際に衝突することはほとんどありません。

### 注意点
- オペコードは `CALL` と同様にガス消費を行います。
- 呼び出し先のコンテキストでは、 `CALLER (0x33)` が偽装されたアドレスを返します。
- 呼び出しで値の転送が0以外の場合、その値は偽装されたアカウントから転送されます。これを使って、偽装されたアカウントからイーサを転送できます。

## 根拠

`IMPERSONATECALL` では3つの単語をハッシュする必要があり、これに180 gasの追加コストがかかりますが、ハッシュのコストを考慮しても、実装の複雑さを増やすメリットはないと考えています。

`zeros32` フィールドを使うことで、CREATE2と同程度のプレイメージサイズにアドレス派生を基づけ、既存のアドレス派生関数を再利用できます。また、EOAの派生 (65バイトのプレイメージ)、CREATE の派生 (23~27バイトのプレイメージ、32ビットのnonce用) 、CREATE2の派生 (85バイトのプレイメージ) との間でアドレス衝突を気にする必要がありません。

`zeros32` フィールドを省略するオプションもあります。その場合、IMPERSONATECALLアドレスのプレイメージの長さは53バイトになり、アドレス衝突は発生しません。

同様の機能をプリコンパイルドコントラクトで提供することもできますが、新しいオペコードを使う方が、よりクリーンな解決策だと考えています。

## 明確化

- この EIP により、アドレスの衝突が可能になりますが、実際にはほとんど起こりません。

- 既に偽装されたアドレスのコントラクトが存在する場合、`IMPERSONATECALL` は同じ方法で実行されますが、既存のコードは実行されません。 `SELFDESTRUCT` (`0xff`) は、偽装されたアカウントのコンテキストでは直接実行できないことに注意が必要です。

## 下位互換性

オペコード番号 `0xf6` は現在未使用で、ガス切れ (OOG) 例外を引き起こします。Solidityでは、ガス切れ例外を発生させるために `INVALID (0xfe)` オペコード (EIP-1803 では `ABORT` と呼ばれる) を使用しています。したがって、 `0xf6` オペコードは通常のSolidityプログラムには現れません。プログラマーには、EVMアセンブリで書かれたコントラクトにこのオペコードを含めないよう助言されています。 したがって、下位互換性の問題はありません。

## テストケース

偽装されたアドレスの派生の例を4つ示します:

例0
* アドレス `0x0000000000000000000000000000000000000000`
* ソルト `0x0000000000000000000000000000000000000000000000000000000000000000`
* 結果: `0xFFC4F52F884A02BCD5716744CD622127366F2EDF`

例1
* アドレス `0xdeadbeef00000000000000000000000000000000`
* ソルト `0x0000000000000000000000000000000000000000000000000000000000000000`
* 結果: `0x85F15E045E1244AC03289B48448249DC0A34AA30`

例2
* アドレス `0xdeadbeef00000000000000000000000000000000`
* ソルト `0x000000000000000000000000feed000000000000000000000000000000000000`
* 結果: `0x2DB27D1D6BE32C9ABFA484BA3D591101881D4B9F`

例3
* アドレス `0x00000000000000000000000000000000deadbeef`
* ソルト `0x00000000000000000000000000000000000000000000000000000000cafebabe`
* 結果: `0x5004E448F43EFE3C7BF32F94B83B843D03901457`

## セキュリティ上の考慮事項

アドレス派生スキームにより、偽装された送信者アドレスが実際の呼び出し元アドレスとソルトから派生するため、別のデプロイ済みコントラクトや外部所有アカウントとのアドレス衝突を防ぐことができます。

## 著作権

[CC0](../LICENSE.md)によりすべての著作権およびそれに関連する権利が放棄されています。