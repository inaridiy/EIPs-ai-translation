---
original: 98e2e40c303dd2e7e1c7cadda6e304376721cce4de0c0650496851f4bcaa4132
---

---
eip: 7698
title: EOF - 作成トランザクション
description: 作成トランザクションを使用してEOFコントラクトをデプロイする
author: Piotr Dobaczewski (@pdobacz), Andrei Maiboroda (@gumb0), Paweł Bylica (@chfast), Alex Beregszaszi (@axic)
discussions-to: https://ethereum-magicians.org/t/eip-7698-eof-creation-transaction/19784
status: レビュー
type: Standards Track
category: Core
created: 2024-04-24
requires: 3540
---

## 概要

空の `to` を持つ作成トランザクション（すなわち、作成トランザクション）を使用して、トランザクションの `data` にEOF initコンテナと `calldata` を連結することで、EOFコントラクトをデプロイできます。initコンテナの実行は `EOFCREATE` 命令の実行中と同様で、`RETURNCONTRACT` 命令で終わります。新しいアカウントアドレスの計算は送信者のアドレスとノンスに基づいています。

## 動機

作成トランザクションは、レガシーEVMが提供する新しいコードをデプロイする3つの方法の1つです。レガシーの作成命令（`CREATE` と `CREATE2`）がEOFコードをデプロイすることができないため、作成トランザクションでEOFをサポートすることが、最初のEOFをオンチェーンで取得する唯一の方法です。

initコンテナにコンストラクター引数を提供するメカニズムは、レガシーコードをデプロイする場合と全く同じ（initコンテナと連結するだけ）ため、既存のデプロイメントツールをそのまま使ってEOFをデプロイできます。

## 仕様

### パラメーター

| 定数 | 値 |
| - | - |
| `EOF_MAGIC` | [EIP-3540](./eip-3540.md)で定義された `0xEF00` |
| `MAX_CODE_SIZE` | [EIP-170](./eip-170.md)で定義された `24576` |


空の `to` を持つ作成トランザクション（トランザクション）の `data` が `EOF_MAGIC` で始まる場合、`data` はEOF `initcontainer` と `calldata` の連結と解釈されます。具体的には以下のようになります:

1. [EIP-3860](./eip-3860.md)で定義された作成トランザクションの固有ガスコストのルールと制限が適用されます。トランザクションの全 `data` がこれらの計算に使用されます。
2. `data` を `initcontainer` と `calldata` に分割する:
    - EOFヘッダーを解析する
    - ヘッダーからすべてのセクションサイズを読み取り、ヘッダーサイズを加えて全コンテナサイズを求める。
3. `initcontainer` とその全サブコンテナを再帰的に検証する。
    - 一般的な検証とは異なり、`initcontainer` のヘッダーに宣言された `data_size` が実際の `data_section` サイズと等しいことが要求される。
    - 検証には `initcontainer` に `RETURN` や `STOP` が含まれていないことのチェックが含まれる
4. EOFヘッダーの解析または全コンテナの検証に失敗した場合、トランザクションは有効で失敗したと見なされます。initコードの実行にはガスは消費されず、作成トランザクションの固有コストのみが請求されます。
5. トランザクションの `data` の `initcontainer` の後の部分は、実行フレームに渡される `calldata` として扱われます。
6. コンテナを実行し、実行ガスを差し引く。
    1. `new_address` を `keccak256(sender || sender_nonce)[12:]` として計算する
    2. 正常な実行は `RETURNCONTRACT{deploy_container_index}(aux_data_offset, aux_data_size)` 命令で終わります。その後:
        - `deploy_container_index` のサブコンテナからデプロイコントラクトをロードする
        - `(aux_data_offset, aux_data_offset + aux_data_size)` メモリセグメントとデータセクションを連結し、ヘッダーのデータサイズを更新する
        - `deployed_code_size` を更新されたデプロイコンテナのサイズとする
        - `deployed_code_size > MAX_CODE_SIZE` の場合、命令が例外的に中断する
        - [EIP-3541](./eip-3541.md)のルール（`EF` で始まるコードのデプロイを禁止）は適用されず、`state[new_address].code` を更新されたデプロイコンテナに設定する
7. `200 * deployed_code_size` ガスを差し引く

## 根拠

### 作成者コントラクトのデプロイのための不規則な状態変更

最初は、不規則な状態変更を使って最初のEOFコントラクトをデプロイすることが提案されていました。この契約は `TXCREATE` 命令を実行し、その後他のEOFコードをデプロイするためのエントリポイントとして使用できるようになります。これには `InitcodeTransaction` の導入も必要でした。しかし、変更範囲を縮小するために、この案は却下されました。

### コンストラクター引数をinitcontainerの外部 vs データセクションに

initcontainerの実行にコンストラクター引数を提供するための別のメカニズムとして、initcontainerのデータセクションに連結し、`DATA*` 命令で アクセスするというものが検討されました。これにはトランザクション.dataを `initcontainer` と `calldata` に分割する必要がないという利点がありました。しかし、以下の理由から却下されました:

- 既存のツールを変更せずにEOFをデプロイできない。EOFの作成トランザクションを構築するには、ツールがコンテナにコンストラクター引数を追加し、EOFヘッダーのデータセクションサイズを更新する必要があります。コンパイラは可変長のコンストラクター引数のサイズを予測してヘッダーの予想データサイズを設定できますが、それは不可能です。
- 後の更新でEOF作成トランザクションの専用フィールド（`calldata`）が導入された場合、initコードはそのフィールドにアクセスするために `CALLDATA*` 命令を使う必要があります。コンパイラが使用されるコンテキストに応じて initコードを異なる方法で生成する必要があるのは避けたほうがよい。
- 一般的な議論として、データセクションはコード定義と密接に結びついた検証済みのデータと見なされるのに対し、calldataは任意の入力と見なされます。

## 下位互換性

レガシーコードをデプロイする作成トランザクションは影響を受けません。以前は `EF` バイトで始まるそのようなトランザクションは無効な命令の実行で失敗していました。

## セキュリティ上の考慮事項

TBA

## 著作権

[CC0](../LICENSE.md)によりすべての著作権およびそれに関連する権利が放棄されています。