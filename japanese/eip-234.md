---
original: e84593e225fe39f566a017cfe28fce713bb0f5e3b4be255da84fb6f5fcd38b81
---

---
eip: 234
title: JSON-RPC フィルターオプションに `blockHash` を追加する
author: Micah Zoltu (@MicahZoltu)
discussions-to: https://github.com/ethereum/EIPs/issues/234
type: Standards Track
category: Interface
status: Final
created: 2017-03-24
requires: 1474
---

## 簡単な概要

`eth_newFilter` と `eth_getLogs` で使用されるJSON-RPCフィルターオプションに、結果に含めるべきブロックハッシュを指定するオプションを追加する。このオプションは `fromBlock`/`toBlock` オプションの代替手段となる。

## 概要

この追加により、クライアントは現在のメインチェーンにあるかどうかに関わらず、特定のブロックのログを取得できるようになる。これにより、チェーンの再編成、信頼できないネットワーク接続、空の結果セットに十分な詳細が含まれていないという問題に対処できる。

## 仕様

`eth_newFilter` で使用されるフィルターオプションに、任意のパラメーター `blockHash` が追加される。その値はブロックハッシュ1つである。リクエストに応答するEthereumノードは、ブロックハッシュが見つからない場合はエラーを返すか、通常の動作に従ってフィルターに一致するログの結果を、指定されたブロックに制限して返す。内部的には、これは `fromBlock` と `toBlock` フィルターオプションと同様に機能すると考えられる。

## 根拠

ログの追加(新しいブロックで)とログの削除(チェーンの再編成で)の両方の確実な通知を必要とするクライアント(dApp)は、サブスクリプションとフィルターのみに頼っては達成できない。これは、ネットワークやリモートノードの障害が再編成の際に発生すると、クライアントの状態が現実から乖離してしまうためである。Websocketの場合の例として、クライアントがWebSocket接続を開き、ログフィルターサブスクリプションを設定し、新しいログの通知を受け取った後、接続が切れ、その間に再編成が発生し、クライアントが再接続してフィルターを新しく設定した場合、ノードがクライアントの存在を忘れていたため、ログの削除の通知を受け取れないという状況が考えられる。HTTPクライアントの場合も、ポーリングの間にノードが停止して再起動し、その間に再編成が発生した場合に同様の問題が起こる可能性がある。

この問題に対処し、ブロックとログの追加/削除の確実なメカニズムを提供するために、クライアントは内部的にブロックチェーンを維持(最後の `n` ブロック)し、新しいブロックのみを購読/ポーリングすることができる。新しいブロックを受け取ると、クライアントは内部モデルを新しいブロックと照合し、親ブロックの補完や、内部モデルからのブロックの巻き戻し/削除を行って、ノードの状態と同期させることができる。これにより、あらゆる種類の切断/再編成/停止シナリオに対応でき、クライアントがEthereumノードのクラスター(ラウンドロビンなど)と対話できるようにもなる。

ユーザーが信頼できるブロックストリームを持っている場合、新しいブロックのブルームフィルターを見て、そのブロックに関心のあるログが含まれている可能性がある場合は、そのブロックのフィルタリングされたログをノードから取得できる。問題は、クライアントがブロックを受け取ってからログを取得するまでの間に再編成が発生する可能性があることである。現在のフィルターオプションでは、ログをブロック番号で要求することしかできない。この場合、取得したログは、クライアントが求めていたブロックではなく、再編成で取り込まれたブロックのものになる可能性がある。これは、取得したログ自体を調べて、要求したブロックハッシュに一致するかどうかを確認することで部分的に回避できる。しかし、結果セットが空の配列(ログが取得できなかった)場合、クライアントはその結果がどのブロックのものかわからなくなる。その空のログは、ブルームフィルターの偽陽性のためその
ブロックに正当に存在しなかったのか、それとも、クライアントが知らないブロックのログなのかが判断できない。この時点で、クライアントが確実に回復できる判断を下すことはできない。空のログが正しいブロックのものだと仮定できるが、そうでなかった場合、二度と取得しようとしない。これは問題となる可能性があり、ブロックが一時的に再編成から外れていた場合、次のブロックポーリングまでに元に戻ってしまい、クライアントがその再編成を見逃してしまうからである。空のログが間違ったブロックのものだと仮定して再取得すれば、引き続き空の結果が返され、同じ状況に陥ってしまう。

ハッシュによるログ取得を可能にすることで、クライアントは取得したログが確実に要求したブロックのものであることを保証できる。エラーが返された場合は、適切な対処(ブロックをクライアント側で巻き戻して最新のものを再取得など)を取ることができる。

## 下位互換性

ここで問題となるのは `fromBlock` と `toBlock` フィールドである。ハッシュと番号を両方含めるのは意味がないため、`fromBlock`/`toBlock` は `blockHash` と相互排他的であるべきだ。

## テストケース

`{ "jsonrpc": "2.0", "id": 1, "method": "eth_getLogs", params: [{"blockHash": "0xbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0c"}] }` は、ハッシュ `0xbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0c` のブロックのすべてのログを返すはずである。`topics` フィールドがフィルターオプションに追加された場合は、そのブロックのフィルタリングされたログセットが返される。そのようなハッシュのブロックが存在しない場合は、エラーが返され、`code` は `-32000`、`message` は `"Block not found."`、`data` は `"0xbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0c"` となる。

## 実装

- [x] [Geth](https://github.com/ethereum/go-ethereum/pull/16734)

## 著作権

著作権およびそれに関連する権利は[CC0](../LICENSE.md)によって放棄されています。