---
original: 59778ec2e103cc99d4a0da159b64a6137634bc6d10d20e016e31c8ee1444ace6
---

---
eip: 3076
title: スラッシング保護インターチェンジフォーマット
description: プルーフ・オブ・ステーク(PoS)バリデータがスラッシング保護データをクライアント間で移行するためのJSONインターチェンジフォーマット。
author: Michael Sproul (@michaelsproul)、Sacha Saint-Leger (@sachayves)、Danny Ryan (@djrtwo)
discussions-to: https://ethereum-magicians.org/t/eip-3076-validator-client-interchange-format-slashing-protection/4883
status: 最終コール
last-call-deadline: 2021-11-03
type: Standards Track
category: Interface
created: 2020-10-27
---

## 概要

キーの署名履歴を転送する標準フォーマットにより、バリデータは競合するメッセージに署名するリスクなしにクライアント間を簡単に切り替えることができます。共通のキーストアフォーマットは部分的な解決策を提供しますが、キーの署名履歴に関する情報は含まれていません。クライアントAからクライアントBにキーを移行するバリデータの場合、クライアントBが誤ってクライアントAで署名した以前のメッセージと競合するメッセージに署名する可能性があります。ここで説明するインターチェンジフォーマットはこの問題の解決策を提供します。

## 動機

プルーフ・オブ・ステーク(PoS)プロトコルは、最終的に2つの異なるバージョンのチェーンが確定されるような方法で投票したバリデータに対してペナルティを科します。これらのタイプのペナルティをスラッシングと呼びます。

プロトコルに従って正しく行動するバリデータには、原則的にスラッシングのリスクはありません。しかし、クライアントを変更する(クライアントAからクライアントBに変更する、など)と、クライアントBがクライアントAで署名したブロックや証明書を認識していない場合、スラッシングのリスクが生じる可能性があります。

これは、クライアントAとクライアントBの時間認識が一致しない場合に発生する可能性があります。例えば、クライアントAの時間が誤って未来の1日(225エポック)に設定されていて、バリデータがクライアントAからクライアントBに切り替える際に、BにクライアントAで署名したブロックと証明書の記録を渡さなかった場合、バリデータは次の225エポックの間、同じエポックの2つのブロックに証明書を付与する(スラッシング対象の行為)リスクがあります。このような時間ズレのバグは実際に観察されています。

スラッシング保護が重要となるもう1つの状況は、再編成(re-org)の場合です。再編成中、バリデータに以前に証明書を付与したエポックの新しい証明書の割り当てが行われる可能性があります。この場合、前の証明書の記録が利用可能であることが不可欠です。バリデータがたった1エポックの間にクライアントを移行した場合でも同様です。

## 仕様

### JSONスキーマ

有効なインターチェンジファイルは、以下のJSONスキーマに準拠しており、[条件](#条件)に従って解釈されるものです。

```json
{
  "title": "署名履歴",
  "description": "このスキーマは、一連のバリデータによって署名されたブロックと証明書の記録を提供します",
  "type": "object",
  "properties": {
    "metadata": {
      "type": "object",
      "properties": {
        "interchange_format_version": {
          "type": "string",
          "description": "このドキュメントが準拠するインターチェンジフォーマットのバージョン"
        },
        "genesis_validators_root": {
          "type": "string",
          "description": "ジェネシス時に計算され、チェーンを一意に識別する"
        }
      },
      "required": [
        "interchange_format_version",
        "genesis_validators_root"
      ]
    },
    "data": {
      "type": "array",
      "items": [
        {
          "type": "object",
          "properties": {
            "pubkey": {
              "type": "string",
              "description": "バリデータのBLSパブリックキー(0x接頭辞付き16進数文字列でエンコーディング)"
            },
            "signed_blocks": {
              "type": "array",
              "items": [
                {
                  "type": "object",
                  "properties": {
                    "slot": {
                      "type": "string",
                      "description": "署名されたブロックのスロット番号"
                    },
                    "signing_root": {
                      "type": "string",
                      "description": "compute_signing_root(block, domain)の出力"
                    }
                  },
                  "required": [
                    "slot"
                  ]
                }
              ]
            },
            "signed_attestations": {
              "type": "array",
              "items": [
                {
                  "type": "object",
                  "properties": {
                    "source_epoch": {
                      "type": "string",
                      "description": "署名された証明書のattestationdata.source.epochの値"
                    },
                    "target_epoch": {
                      "type": "string",
                      "description": "署名された証明書のattestationdata.target.epochの値"
                    },
                    "signing_root": {
                      "type": "string",
                      "description": "compute_signing_root(attestation, domain)の出力"
                    }
                  },
                  "required": [
                    "source_epoch",
                    "target_epoch"
                  ]
                }
              ]
            }
          },
          "required": [
            "pubkey",
            "signed_blocks",
            "signed_attestations"
          ]
        }
      ]
    }
  },
  "required": [
    "metadata",
    "data"
  ]
}
```

### JSONインスタンスの例

```json
{
  "metadata": {
    "interchange_format_version": "5",
    "genesis_validators_root": "0x04700007fabc8282644aed6d1c7c9e21d38a03a0c4ba193f3afe428824b3a673"
  },
  "data": [
    {
      "pubkey": "0xb845089a1457f811bfc000588fbb4e713669be8ce060ea6be3c6ece09afc3794106c91ca73acda5e5457122d58723bed",
      "signed_blocks": [
        {
          "slot": "81952",
          "signing_root": "0x4ff6f743a43f3b4f95350831aeaf0a122a1a392922c45d804280284a69eb850b"
        },
        {
          "slot": "81951"
        }
      ],
      "signed_attestations": [
        {
          "source_epoch": "2290",
          "target_epoch": "3007",
          "signing_root": "0x587d6a4f59a58fe24f406e0502413e77fe1babddee641fda30034ed37ecc884d"
        },
        {
          "source_epoch": "2290",
          "target_epoch": "3008"
        }
      ]
    }
  ]
}
```

### 条件

データフィールド `data` を持つインターチェンジファイルをインポートした後、署名者は以下の条件を守らなければなりません:

1. `data.signed_blocks` に含まれるブロックに関して、スラッシング対象となるブロックの署名を拒否する。スラッシング対象となるブロックの詳細については、`process_proposer_slashing`(`consensus-specs`から)を参照。`signing_root`が欠落しているブロックの場合、署名者は同じ`slot`を持つ新しいブロックはすべてインポートされたブロックに関してスラッシング対象であると見なさなければならない。

2. `data.signed_blocks`の中で最小のスロットを持つブロックのスロットよりも小さいスロットを持つブロックの署名を拒否する。ただし、`signing_root`によって判断される繰り返し署名の場合は除く。

3. `data.signed_attestations`に含まれる証明書に関して、スラッシング対象となる証明書の署名を拒否する。スラッシング対象となる証明書の詳細については、`is_slashable_attestation_data`を参照。

4. 自身の証明書(`data.signed_attestations`に含まれる)の中で最小のソースエポックよりも小さいソースエポックを持つ証明書の署名を拒否する。擬似コードで表すと以下のようになります:

```python3
source.epoch <
    min(att.source_epoch
        for att in data.signed_attestations
        if att.pubkey == attester_pubkey)
```

{:start="5"}
5. 自身の証明書(`data.signed_attestations`に含まれる)の中で最小のターゲットエポックよりも小さいか同じターゲットエポックを持つ証明書の署名を拒否する。ただし、`signing_root`によって判断される繰り返し署名の場合は除く。擬似コードで表すと以下のようになります:

```python3
target_epoch <=
    min(att.target_epoch
        for att in data.signed_attestations
        if att.pubkey == attester_pubkey)
```

### 追加情報

- `interchange_format_version`のバージョンは5に設定されています。

- ブロックや証明書の`signing_root`は、BLS署名で署名されるメッセージデータ(ハッシュツリールート)を指します。これにより、バリデータは要求された場合にブロックや証明書を再署名して再送信できます。

- `signed_blocks`の`signing_root`は、`compute_signing_root(block, domain)`を使って計算されます。ここで`block`は署名されたブロック(`BeaconBlock`または`BeaconBlockHeader`型)、`domain`は`compute_domain(DOMAIN_BEACON_PROPOSER, fork, metadata.genesis_validators_root)`と等しくなります。

- `signed_attestations`の`signing_root`は、`compute_signing_root(attestation, domain)`を使って計算されます。ここで`attestation`は署名された証明書(`AttestationData`型)、`domain`は`compute_domain(DOMAIN_BEACON_ATTESTER, fork, metadata.genesis_validators_root)`と等しくなります。

## 根拠

### 異なる戦略のサポート

インターチェンジフォーマットは、クライアントが実装する可能性のあるスラッシング保護戦略の全範囲をサポートするように設計されています。これらの戦略は主に2つのタイプに分類できます:

1. **完全(Complete)**: 各バリデータが署名したすべてのメッセージを含むデータベース。
2. **最小限(Minimal)**: 各バリデータが署名した最新のメッセージのみを含むデータベース。

最小限の戦略の利点は、その単純さと簡潔さです。各バリデータの最新のメッセージのみを使用することで、以前のメッセージに署名しないことによってスラッシング保護を安全に実現できます。

一方、完全な戦略は、誤検知(スラッシングを保証しない限り署名を拒否しない)を避けつつ、安全なスラッシング保護を提供できます。

2つの戦略は、[条件](#条件)の(2)、(4)、(5)を通して統一されています。これにより、必要に応じて詳細または簡潔な情報をインターチェンジ形式で転送できます。

### 整数表現

JSONスキーマのほとんどのフィールドは文字列です。値を文字列または整数のいずれかでエンコードできるフィールドの場合、文字列が選択されました。この選択は、異なる言語が異なる範囲の整数をサポートする可能性がある問題(特にJavaScriptの`number`型が64ビットの浮動小数点数である)を回避するためです。バリデータがまだブロックや証明書に署名していない場合、関連するリストは単に空のままになります。

### バージョニング

`interchange_format_version`は5に設定されています。これは、設計中に実装者からのフィードバックを取り入れながら、仕様に複数の破壊的な変更が加えられたためです。

## 下位互換性

この仕様は、バージョン番号が5未満の以前のドラフト版とは下位互換性がありません。

## セキュリティ上の考慮事項

リスクと複雑さを最小限に抑えるため、このフォーマットは実装者が使用する内部データベースフォーマットにきれいにマッピングされるように設計されています。ただし、いくつかの落とし穴に注意を払う必要があります。

### 完全なデータベースに関するアドバイス

署名済みメッセージの完全な記録を使ってスラッシング保護データベースを実装する実装者には、以下のようなアドバイスをします:

- インターチェンジからすべてのメッセージをインポートするだけでなく、[条件](#条件)をすべて確実に適用しなければなりません。特に、条件(2)、(4)、(5)は、インターチェンジフォーマットを採用する前は適用されていなかった可能性があります。これらのルールを常に適用することをお勧めします
(続き)

- これにより、実装を簡潔に保ち、攻撃対象面積を最小限に抑えることができます。例えば、スラッシング保護メカニズムは、以前に署名したブロックの最小スロット番号以下または等しいスロット番号を持つブロックに署名してはいけません。これは、その最小スロットブロックがインターチェンジファイルからインポートされたものか、データベースの通常の操作の一部として挿入されたものかに関係なく適用されるべきです。
- データベースがメッセージのスロット/エポックに加えて署名ルートも記録している場合、署名ルートのない imported メッセージに対して適切なダミーの署名ルートを内部的に割り当てる必要があります。「null」値を使用することをお勧めしますが、0x0のような値を使用することもできます(実際の署名ルートと衝突する可能性は極めて低いため)。
- データベースに不明な署名活動の領域(ギャップ)がある場合に、そのギャップ内でメッセージに署名することは避ける必要があります。これは、最初のインターチェンジの最後のエントリと2番目のインターチェンジの最初のエントリの間に大きなギャップがある場合に発生する可能性があります。このギャップ内で署名するのは安全ではなく、条件(2)、(4)、(5)に違反します。これは、実際のメッセージに加えて明示的な最小ウォーターマークを保存するか、インポート時にプルーニングを行って、インターチェンジの最古のメッセージがデータベースの最古のメッセージになるようにすることで回避できます。

### 最小限のデータベースに関するアドバイス

バリデータごとの最新のブロックと証明書のみを保存するスラッシング保護データベースを実装したい実装者には、以下のようなアドバイスをします:

- インポート時には、各バリデータについて_最大の_スロットブロックと_最大の_ソースおよびターゲットの証明書を確実に取得してください。[条件](#条件)では最小値の適用が要求されていますが、インターチェンジファイルから最大値を取得し、既存のデータベースの値とマージするのが推奨アプローチです。例えば、インターチェンジファイルにバリデータ`V`のブロックがスロット4、98、243にある場合、バリデータ`V`の最新の署名済みブロックはスロット243のものになります。ただし、データベースにすでにこのバリデータのスロット351のブロックが含まれている場合は、データベースの既存の値を変更しないでください。

### 一般的な推奨事項

- 期限切れのインターチェンジファイルをエクスポートすることによってスラッシングのリスクを生み出すのを避けるため、スラッシング保護データベースをエクスポートできるのは、バリデータクライアントまたは署名者が_停止_している(つまり、新しいメッセージをデータベースに追加していない)場合のみにしてください。
- 同様に、インターチェンジファイルをインポートできるのは、バリデータクライアントが停止している場合のみにしてください。

## 著作権

著作権およびそれに関連する権利は[CC0](../LICENSE.md)によって放棄されています。