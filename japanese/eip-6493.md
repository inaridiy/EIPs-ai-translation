---
original: ed68803bd49bfb24ec825a2c09d4e431532321434ac552f01ede5c76bf1d8ff5
---

---
eip: 6493
title: SSZトランザクション署名スキーム
description: SSZトランザクションの署名スキーム
author: Etan Kissling (@etan-status)、Matt Garnett (@lightclient)、Vitalik Buterin (@vbuterin)
discussions-to: https://ethereum-magicians.org/t/eip-6493-ssz-transaction-signature-scheme/13050
status: レビュー
type: Standards Track
category: Core
created: 2023-02-24
requires: 155, 191, 1559, 2718, 2930, 4844, 5793, 7495
---

## 概要

このEIPは、[Simple Serialize (SSZ)](https://github.com/ethereum/consensus-specs/blob/ef434e87165e9a4c82a99f54ffd4974ae113f732/ssz/simple-serialize.md)でエンコードされたトランザクションの署名スキームを定義しています。

## 動機

各トランザクションについて、2つの永続的なハッシュが導出されます。

1. `sig_hash`は署名されていないトランザクションのハッシュです。2つの有効なトランザクションが同じ`sig_hash`を共有することは決してあってはなりません。

2. `tx_hash`は署名されたトランザクションを参照するための一意の識別子です。このハッシュはメンプールでトランザクションを参照するのに使用され、トランザクションがブロックに含まれた後も安定したままです。

既存の[EIP-2718](./eip-2718.md) Recursive-Length Prefix (RLP)トランザクションでは、これらのハッシュはシリアル化全体にわたるkeccak256ハッシュに基づいています。

[Simple Serialize (SSZ)](https://github.com/ethereum/consensus-specs/blob/ef434e87165e9a4c82a99f54ffd4974ae113f732/ssz/simple-serialize.md)トランザクションタイプについては、このEIPでSHA256 Merkleツリーに基づく代替の署名スキームが定義されています。

さらに、このEIPはRLPトランザクションとSSZトランザクションおよびレシートの間で一貫した表現を実現するための変換メカニズムを定義しています。

## 仕様

このドキュメントの「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、「OPTIONAL」というキーワードは、RFC 2119およびRFC 8174に記載されているように解釈されるものとします。

### [EIP-2718](./eip-2718.md)トランザクションタイプ

| 名称 | SSZ等価 | 説明 |
| - | - | - |
| `TransactionType` | `uint8` | [EIP-2718](./eip-2718.md)トランザクションタイプ、範囲`[0x00, 0x7F]` |

`0x00`と`0x04`は予約済みの[EIP-2718](./eip-2718.md)トランザクションタイプです。

- `0x00`は[EIP-2718](./eip-2718.md)`LegacyTransaction`を示します。
- `0x04`はこのEIPで定義されるSSZ`Transaction`を示します。

| 名称 | 値 | 説明 |
| - | - | - |
| (n/a) | `None` | 型なし [`LegacyTransaction`](./eip-2718.md#transactions) ('Homestead'スキーム) |
| `TRANSACTION_TYPE_LEGACY` | `TransactionType(0x00)` | 型なし [`LegacyTransaction`](./eip-2718.md#transactions) ([EIP-155スキーム](./eip-155.md)) |
| `TRANSACTION_TYPE_EIP2930` | `TransactionType(0x01)` | [EIP-2930](./eip-2930.md#definitions)トランザクション |
| `TRANSACTION_TYPE_EIP1559` | `TransactionType(0x02)` | [EIP-1559](./eip-1559.md#specification)トランザクション |
| `TRANSACTION_TYPE_EIP4844` | `TransactionType(0x03)` | [EIP-4844](./eip-4844.md#parameters)トランザクション |
| `TRANSACTION_TYPE_SSZ` | `TransactionType(0x04)` | SSZ `Transaction` |

`0x19`は[ERC-191](./eip-191.md)署名データとの衝突を防ぐために予約されています。

### 既存の定義

このドキュメントで使用される既存の仕様からの定義を参照のために再掲しています。

| 名称 | SSZ等価 |
| - | - |
| [`Hash32`](https://github.com/ethereum/consensus-specs/blob/ef434e87165e9a4c82a99f54ffd4974ae113f732/specs/phase0/beacon-chain.md#custom-types) | `Bytes32` |
| [`ExecutionAddress`](https://github.com/ethereum/consensus-specs/blob/ef434e87165e9a4c82a99f54ffd4974ae113f732/specs/bellatrix/beacon-chain.md#custom-types) | `Bytes20` |
| [`KZGCommitment`](https://github.com/ethereum/consensus-specs/blob/ef434e87165e9a4c82a99f54ffd4974ae113f732/specs/deneb/polynomial-commitments.md#custom-types) | `Bytes48` |
| [`KZGProof`](https://github.com/ethereum/consensus-specs/blob/ef434e87165e9a4c82a99f54ffd4974ae113f732/specs/deneb/polynomial-commitments.md#custom-types) | `Bytes48` |
| [`Blob`](https://github.com/ethereum/consensus-specs/blob/ef434e87165e9a4c82a99f54ffd4974ae113f732/specs/deneb/polynomial-commitments.md#custom-types) | `ByteVector[BYTES_PER_FIELD_ELEMENT * FIELD_ELEMENTS_PER_BLOB]` |
| [`VersionedHash`](https://github.com/ethereum/consensus-specs/blob/ef434e87165e9a4c82a99f54ffd4974ae113f732/specs/deneb/beacon-chain.md#custom-types) | `Bytes32` |

| 名称 | 値 |
| - | - |
| [`BYTES_PER_LOGS_BLOOM`](https://github.com/ethereum/consensus-specs/blob/ef434e87165e9a4c82a99f54ffd4974ae113f732/specs/bellatrix/beacon-chain.md#execution) | `uint64(2**8)` (= 256) |
| [`BYTES_PER_FIELD_ELEMENT`](https://github.com/ethereum/consensus-specs/blob/ef434e87165e9a4c82a99f54ffd4974ae113f732/specs/deneb/polynomial-commitments.md#constants) | `uint64(32)` |
| [`FIELD_ELEMENTS_PER_BLOB`](https://github.com/ethereum/consensus-specs/blob/ef434e87165e9a4c82a99f54ffd4974ae113f732/specs/deneb/polynomial-commitments.md#blob) | `uint64(4096)` |
| [`MAX_BLOB_COMMITMENTS_PER_BLOCK`](https://github.com/ethereum/consensus-specs/blob/ef434e87165e9a4c82a99f54ffd4974ae113f732/specs/deneb/beacon-chain.md#execution) | `uint64(2**12)` (= 4,096) |

### SSZ `Transaction` コンテナ

すべてのSSZトランザクションは単一の正規化されたSSZコンテナとして表現されます。定義では`StableContainer[N]`SSZタイプと[EIP-7495](./eip-7495.md)で定義された`Optional[T]`を使用しています。

| 名称 | 値 | 説明 |
| - | - | - |
| `MAX_CALLDATA_SIZE` | `uint64(2**24)` (= 16,777,216) | トランザクションの`input`コールデータバイト長の最大値 |
| `MAX_ACCESS_LIST_STORAGE_KEYS` | `uint64(2**19)` (= 524,288) | アクセスタプル内のストレージキーの最大数 |
| `MAX_ACCESS_LIST_SIZE` | `uint64(2**19)` (= 524,288) | `access_list`内のアクセスタプルの最大数 |
| `ECDSA_SIGNATURE_SIZE` | `32 + 32 + 1` (= 65) | ECDSA (secp256k1)署名のバイト長 |
| `MAX_FEES_PER_GAS_FIELDS` | `uint64(2**4)` (= 16) | `FeesPerGas`が将来的に成長できる最大フィールド数 |
| `MAX_TRANSACTION_PAYLOAD_FIELDS` | `uint64(2**5)` (= 32) | `TransactionPayload`が将来的に成長できる最大フィールド数 |
| `MAX_TRANSACTION_SIGNATURE_FIELDS` | `uint64(2**4)` (= 16) | `TransactionSignature`が将来的に成長できる最大フィールド数 |

| 名称 | SSZ等価 | 説明 |
| - | - | - |
| `ChainId` | `uint64` | 署名時の[EIP-155](./eip-155.md)チェーンID |
| `FeePerGas` | `uint256` | ガス単位当たりの手数料、ブロック全体で溢れることはない |

```python
class FeesPerGas(StableContainer[MAX_FEES_PER_GAS_FIELDS]):
    regular: Optional[FeePerGas]

    # EIP-4844
    blob: Optional[FeePerGas]

class AccessTuple(Container):
    address: ExecutionAddress
    storage_keys: List[Hash32, MAX_ACCESS_LIST_STORAGE_KEYS]

class TransactionPayload(StableContainer[MAX_TRANSACTION_PAYLOAD_FIELDS]):
    # EIP-2718
    type_: Optional[TransactionType]

    # EIP-155
    chain_id: Optional[ChainId]

    nonce: Optional[uint64]
    max_fees_per_gas: Optional[FeesPerGas]
    gas: Optional[uint64]
    to: Optional[ExecutionAddress]
    value: Optional[uint256]
    input_: Optional[ByteList[MAX_CALLDATA_SIZE]]

    # EIP-2930
    access_list: Optional[List[AccessTuple, MAX_ACCESS_LIST_SIZE]]

    # EIP-1559
    max_priority_fees_per_gas: Optional[FeesPerGas]

    # EIP-4844
    blob_versioned_hashes: Optional[List[VersionedHash, MAX_BLOB_COMMITMENTS_PER_BLOCK]]

class TransactionSignature(StableContainer[MAX_TRANSACTION_SIGNATURE_FIELDS]):
    from_: Optional[ExecutionAddress]
    ecdsa_signature: Optional[ByteVector[ECDSA_SIGNATURE_SIZE]]

class Transaction(Container):
    payload: TransactionPayload
    signature: TransactionSignature
```

[EIP-7495](./eip-7495.md)`Profile`を使用して有効なトランザクションタイプを定義できます。

```python
class BasicFeesPerGas(Profile[FeesPerGas]):
    regular: FeePerGas

class BlobFeesPerGas(Profile[FeesPerGas]):
    regular: FeePerGas
    blob: FeePerGas

class EcdsaTransactionSignature(Profile[TransactionSignature]):
    from_: Optional[ExecutionAddress]
    ecdsa_signature: Optional[ByteVector[ECDSA_SIGNATURE_SIZE]]

class ReplayableTransactionPayload(Profile[TransactionPayload]):
    type_: TransactionType
    nonce: uint64
    max_fees_per_gas: BasicFeesPerGas
    gas: uint64
    to: Optional[ExecutionAddress]
    value: uint256
    input_: ByteList[MAX_CALLDATA_SIZE]

class ReplayableTransaction(Container):
    payload: ReplayableTransactionPayload
    signature: EcdsaTransactionSignature

class LegacyTransactionPayload(Profile[TransactionPayload]):
    type_: TransactionType
    chain_id: ChainId
    nonce: uint64
    max_fees_per_gas: BasicFeesPerGas
    gas: uint64
    to: Optional[ExecutionAddress]
    value: uint256
    input_: ByteList[MAX_CALLDATA_SIZE]

class LegacyTransaction(Container):
    payload: LegacyTransactionPayload
    signature: EcdsaTransactionSignature

class Eip2930TransactionPayload(Profile[TransactionPayload]):
    type_: TransactionType
    chain_id: ChainId
    nonce: uint64
    max_fees_per_gas: BasicFeesPerGas
    gas: uint64
    to: Optional[ExecutionAddress]
    value: uint256
    input_: ByteList[MAX_CALLDATA_SIZE]
    access_list: List[AccessTuple, MAX_ACCESS_LIST_SIZE]

class Eip2930Transaction(Container):
    payload: Eip2930TransactionPayload
    signature: EcdsaTransactionSignature

class Eip1559TransactionPayload(Profile[TransactionPayload]):
    type_: TransactionType
    chain_id: ChainId
    nonce: uint64
    max_fees_per_gas: BasicFeesPerGas
    gas: uint64
    to: Optional[ExecutionAddress]
    value: uint256
    input_: ByteList[MAX_CALLDATA_SIZE]
    access_list: List[AccessTuple, MAX_ACCESS_LIST_SIZE]
    max_priority_fees_per_gas: BasicFeesPerGas

class Eip1559Transaction(Container):
    payload: Eip1559TransactionPayload
    signature: EcdsaTransactionSignature

class Eip4844TransactionPayload(Profile[TransactionPayload]):
    type_: TransactionType
    chain_id: ChainId
    nonce: uint64
    max_fees_per_gas: BlobFeesPerGas
    gas: uint64
    to: ExecutionAddress
    value: uint256
    input_: ByteList[MAX_CALLDATA_SIZE]
    access_list: List[AccessTuple, MAX_ACCESS_LIST_SIZE]
    max_priority_fees_per_gas: BlobFeesPerGas
    blob_versioned_hashes: List[VersionedHash, MAX_BLOB_COMMITMENTS_PER_
BLOCK]

class Eip4844Transaction(Container):
    payload: Eip4844TransactionPayload
    signature: EcdsaTransactionSignature

class BasicTransactionPayload(Profile[TransactionPayload]):
    chain_id: ChainId
    nonce: uint64
    max_fees_per_gas: BasicFeesPerGas
    gas: uint64
    to: Optional[ExecutionAddress]
    value: uint256
    input_: ByteList[MAX_CALLDATA_SIZE]
    access_list: List[AccessTuple, MAX_ACCESS_LIST_SIZE]
    max_priority_fees_per_gas: BasicFeesPerGas

class BasicTransaction(Container):
    payload: BasicTransactionPayload
    signature: EcdsaTransactionSignature

class BlobTransactionPayload(Profile[TransactionPayload]):
    chain_id: ChainId
    nonce: uint64
    max_fees_per_gas: BlobFeesPerGas
    gas: uint64
    to: ExecutionAddress
    value: uint256
    input_: ByteList[MAX_CALLDATA_SIZE]
    access_list: List[AccessTuple, MAX_ACCESS_LIST_SIZE]
    max_priority_fees_per_gas: BlobFeesPerGas
    blob_versioned_hashes: List[VersionedHash, MAX_BLOB_COMMITMENTS_PER_BLOCK]

class BlobTransaction(Container):
    payload: BlobTransactionPayload
    signature: EcdsaTransactionSignature

def select_transaction_profile(cls, value: Transaction) -> Type[Profile]:
    if value.payload.type_ is None:
        if value.payload.blob_versioned_hashes is not None:
            return BlobTransaction
        return BasicTransaction

    if value.payload.type_ == TRANSACTION_TYPE_EIP4844:
        return Eip4844Transaction

    if value.payload.type_ == TRANSACTION_TYPE_EIP1559:
        return Eip1559Transaction

    if value.payload.type_ == TRANSACTION_TYPE_EIP2930:
        return Eip2930Transaction

    if value.payload.chain_id is not None:
        return LegacyTransaction

    return ReplayableTransaction
```

将来の仕様では以下のことが行われる可能性があります:

- `TransactionPayload`と`TransactionSignature`の末尾にフィールドを追加する
- `Profile`タイプを調整し、`select_transaction_profile`ロジックを更新する

このような変更は[影響を受けません](./eip-7495.md)既存のトランザクションのシリアル化やマーク化。

![トランザクションのマーク化](../assets/eip-6493/transaction.png)

### トランザクション署名スキーム

SSZトランザクションに署名する際、基礎となる仕様を一意に識別するための追加情報が`sig_hash`にミックスされます。他のネットワークがSSZデータに追加のトランザクションタイプを定義する場合、異なる`DomainType`を使用する必要があります。

| 名称 | 値 | 説明 |
| - | - | - |
| `DOMAIN_TRANSACTION_SSZ` | `DomainType('0x04000080)` | このEIPと互換性のあるSSZトランザクションに署名するための[`DomainType`](https://github.com/ethereum/consensus-specs/blob/ef434e87165e9a4c82a99f54ffd4974ae113f732/specs/phase0/beacon-chain.md#custom-types) |

署名するハッシュ`sig_hash`と一意のトランザクション識別子`tx_hash`は、[`hash_tree_root`](https://github.com/ethereum/consensus-specs/blob/ef434e87165e9a4c82a99f54ffd4974ae113f732/ssz/simple-serialize.md#merkleization)を使用して計算されます。

```python
class ExecutionSigningData(Container):
    object_root: Root
    domain_type: DomainType

def compute_ssz_sig_hash(payload: TransactionPayload) -> Hash32:
    return Hash32(ExecutionSigningData(
        object_root=payload.hash_tree_root(),
        domain=DOMAIN_TRANSACTION_SSZ,
    ).hash_tree_root())

def compute_ssz_tx_hash(tx: Transaction) -> Hash32:
    assert tx.payload.type_ == TRANSACTION_TYPE_SSZ
    return Hash32(tx.hash_tree_root())
```

### トランザクションの検証

`Transaction`の検証の一環として、`ecdsa_signature`との一貫性を確認するために`from`アドレスをチェックする必要があります。

```python
def ecdsa_pack_signature(y_parity: bool,
                         r: uint256,
                         s: uint256) -> ByteVector[ECDSA_SIGNATURE_SIZE]:
    return r.to_bytes(32, 'big') + s.to_bytes(32, 'big') + bytes([0x01 if y_parity else 0x00])

def ecdsa_unpack_signature(signature: ByteVector[ECDSA_SIGNATURE_SIZE]) -> tuple[bool, uint256, uint256]:
    y_parity = signature[64] != 0
    r = uint256.from_bytes(signature[0:32], 'big')
    s = uint256.from_bytes(signature[32:64], 'big')
    return (y_parity, r, s)

def ecdsa_validate_signature(signature: ByteVector[ECDSA_SIGNATURE_SIZE]):
    SECP256K1N = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141
    assert len(signature) == 65
    assert signature[64] in (0, 1)
    _, r, s = ecdsa_unpack_signature(signature)
    assert 0 < r < SECP256K1N
    assert 0 < s < SECP256K1N

def ecdsa_recover_from_address(signature: ByteVector[ECDSA_SIGNATURE_SIZE],
                               sig_hash: Hash32) -> ExecutionAddress:
    ecdsa = ECDSA()
    recover_sig = ecdsa.ecdsa_recoverable_deserialize(signature[0:64], signature[64])
    public_key = PublicKey(ecdsa.ecdsa_recover(sig_hash, recover_sig, raw=True))
    uncompressed = public_key.serialize(compressed=False)
    return ExecutionAddress(keccak(uncompressed[1:])[12:])

def validate_transaction(tx):
    ecdsa_validate_signature(tx.signature.ecdsa_signature)
    assert tx.signature.from_ == ecdsa_recover_from_address(
        tx.signature.ecdsa_signature,
        compute_sig_hash(tx),
    )
```

`compute_sig_hash`の定義については、[EIPアセット](../assets/eip-6493/tx_hashes.py)を参照してください。

### SSZ `PooledTransaction` コンテナ

トランザクションゴシップ応答([`PooledTransactions`](https://github.com/ethereum/devp2p/blob/6b259a7003b4bfb18365ba690f4b00ba8a26393b/caps/eth.md#pooledtransactions-0x0a))の際、各`Transaction`は`PooledTransaction`にラップされます。定義では[EIP-7495](./eip-7495.md)で定義された`StableContainer[N]`SSZタイプと`Optional[T]`を使用しています。

| 名称 | 値 | 説明 |
| - | - | - |
| `MAX_POOLED_TRANSACTION_FIELDS` | `uint64(2**3)` (= 8) | `PooledTransaction`が将来的に成長できる最大フィールド数 |

```python
class BlobData(Container):
    blobs: List[Blob, MAX_BLOB_COMMITMENTS_PER_BLOCK]
    commitments: List[KZGCommitment, MAX_BLOB_COMMITMENTS_PER_BLOCK]
    proofs: List[KZGProof, MAX_BLOB_COMMITMENTS_PER_BLOCK]

class PooledTransaction(StableContainer[MAX_POOLED_TRANSACTION_FIELDS]):
    tx: Transaction
    blob_data: Optional[BlobData]
```

[EIP-4844](./eip-4844.md)で定義された追加の検証制約も、`tx.payload.blob_versioned_hashes`または`blob_data`を定義するトランザクションに適用されます。

将来の仕様では以下のことが行われる可能性があります:

- `PooledTransactionPayload`の末尾にフィールドを追加する
- 既存のフィールドを`Optional`に変換する

このような変更は[影響を受けません](./eip-7495.md)既存のプールされたトランザクションのシリアル化、マーク化、または検証。

### SSZ `Receipt` コンテナ

すべてのSSZレシートは単一の正規化されたSSZコンテナとして表現されます。定義では[EIP-7495](./eip-7495.md)で定義された`StableContainer[N]`SSZタイプと`Optional[T]`を使用しています。

| 名称 | 値 | 説明 |
| - | - | - |
| `MAX_TOPICS_PER_LOG` | `4` | `LOG0`から`LOG4`オペコードでは、ログごとに0-4個のトピックが許可されます |
| `MAX_LOG_DATA_SIZE` | `uint64(2**24)` (= 16,777,216) | ログの`data`バイト長の最大値 |
| `MAX_LOGS_PER_RECEIPT` | `uint64(2**21)` (= 2,097,152) | `logs`内のエントリの最大数 |
| `MAX_RECEIPT_FIELDS` | `uint64(2**5)` (= 32) | `Receipt`が将来的に成長できる最大フィールド数 |

```python
class Log(Container):
    address: ExecutionAddress
    topics: List[Bytes32, MAX_TOPICS_PER_LOG]
    data: ByteList[MAX_LOG_DATA_SIZE]

class Receipt(StableContainer[MAX_RECEIPT_FIELDS]):
    root: Optional[Hash32]
    gas_used: Optional[uint64]
    contract_address: Optional[ExecutionAddress]
    logs_bloom: Optional[ByteVector[BYTES_PER_LOGS_BLOOM]]
    logs: Optional[List[Log, MAX_LOGS_PER_RECEIPT]]

    # EIP-658
    status: Optional[boolean]
```

[EIP-7495](./eip-7495.md)`Profile`を使用して有効なレシートタイプを定義できます。

```python
class HomesteadReceipt(Profile[Receipt]):
    root: Hash32
    gas_used: uint64
    contract_address: Optional[ExecutionAddress]
    logs_bloom: ByteVector[BYTES_PER_LOGS_BLOOM]
    logs: List[Log, MAX_LOGS_PER_RECEIPT]

class BasicReceipt(Profile[Receipt]):
    gas_used: uint64
    contract_address: Optional[ExecutionAddress]
    logs_bloom: ByteVector[BYTES_PER_LOGS_BLOOM]
    logs: List[Log, MAX_LOGS_PER_RECEIPT]
    status: boolean

def select_receipt_profile(value: Receipt) -> Type[Profile]:
    if value.status is not None:
        return BasicReceipt

    return HomesteadReceipt
```

将来の仕様では以下のことが行われる可能性があります:

- `Receipt`の末尾にフィールドを追加する
- `Profile`タイプを調整し、`select_receipt_profile`ロジックを更新する

このような変更は[影響を受けません](./eip-7495.md)既存のレシートのシリアル化やマーク化。

![レシートのマーク化](../assets/eip-6493/receipt.png)

### ネットワーキング

[Ethereum Wire Protocol](https://github.com/ethereum/devp2p/blob/6b259a7003b4bfb18365ba690f4b00ba8a26393b/caps/eth.md)を介してSSZトランザクションとレシートを交換する際、以下の[EIP-2718](./eip-2718.md)互換のエンベロープが使用されます:

- `Transaction`: `TRANSACTION_TYPE_SSZ || snappyFramed(ssz)`
- `PooledTransaction`: `TRANSACTION_TYPE_SSZ || snappyFramed(ssz(PooledTransaction))`
- `Receipt`: `TRANSACTION_TYPE_SSZ || snappyFramed(ssz(Receipt))`

オブジェクトは[SSZ](https://github.com/ethereum/consensus-specs/blob/ef434e87165e9a4c82a99f54ffd4974ae113f732/ssz/simple-serialize.md)でエンコードされ、Snappyフレーミング形式で圧縮されます。これは[コンセンサスネットワーキング仕様](https://github.com/ethereum/consensus-specs/blob/ef434e87165e9a4c82a99f54ffd4974ae113f732/specs/phase0/p2p-interface.md#ssz-snappy-encoding-strategy)で定義されているコンセンサスオブジェクトのエンコーディングと一致しています。エンコーディングの一環として、非圧縮オブジェクト長が出力されます。オブジェクトごとに適用される推奨される制限は[`MAX_CHUNK_SIZE`](https://github.com/ethereum/consensus-specs/blob/e3a939e439d6c05356c9c29c5cd347384180bc01/specs/phase0/p2p-interface.md#configuration)バイトです。

実装では、RLPトランザクションをトランザクションプールに受け入れ続ける必要があります。ただし、そのようなトランザクションは`ExecutionPayload`に含めるためにSSZに変換される必要があります。RLPからSSZへの変換、および対応する[テストケース](../assets/eip-6493/convert_tests.py)の参照実装については、[EIPアセット](../assets/eip-6493/convert.py)を参照してください。元の`sig_hash`と`tx_hash`は変換プロセス全体で保持されます。

### トランザクションゴシップアナウンス

トランザクションゴシップアナウンス([`NewPooledTransactionHashes`](https://github.com/ethereum/devp2p/blob/6b259a7003b4bfb18365ba690f4b00ba8a26393b/caps/eth.md#newpooledtransactionhashes-0x08))の`types`要素のセマンティクスは、`ssz(PooledTransaction.active_fields())`に一致するように変
更されます:

| `types` | 説明 |
| - | - |
| `0x00` | 型なし [`LegacyTransaction`](./eip-2718.md#transactions) ('Homestead'スキーム、または[EIP-155スキーム](./eip-155.md)) |
| `0x01` | [EIP-2930](./eip-2930.md)トランザクション、または追加の補助ペイロードのないベーシックなSSZ `PooledTransaction` |
| `0x02` | [EIP-1559](./eip-1559.md)トランザクション |
| `0x03` | [EIP-4844](./eip-4844.md)トランザクション、またはSSZ `PooledTransaction`に`blob_data`を持つもの |

### エンジンAPI

エンジンAPIを介して交換する際、`ExecutionPayload`バージョンの`transactions`フィールドの構造は、`Array of DATA`から`Array of TransactionV1`に変更されます。

`TransactionV1`は以下のようにSSZ `Transaction` `StableContainer`にマッピングされます:

- `payload`: `TransactionPayloadV1` - `TransactionPayloadV1`構造体のフィールドを含むオブジェクト
- `signature`: `TransactionSignatureV1` - `TransactionSignatureV1`構造体のフィールドを含むオブジェクト

`TransactionPayloadV1`は以下のようにSSZ `TransactionPayload` `StableContainer`にマッピングされます:

- `type`: `QUANTITY|null`, 8ビットまたは`null`
- `chainId`: `QUANTITY|null`, 64ビットまたは`null`
- `nonce`: `QUANTITY|null`, 64ビットまたは`null`
- `maxFeesPerGas`: `FeesPerGasV1|null` - `FeesPerGasV1`構造体のフィールドを含むオブジェクトまたは`null`
- `gas`: `QUANTITY|null`, 64ビットまたは`null`
- `to`: `DATA|null`, 20バイトまたは`null`
- `value`: `QUANTITY|null`, 256ビットまたは`null`
- `input`: `DATA|null`, 0から`MAX_CALLDATA_SIZE`バイトまたは`null`
- `accessList`: `Array of AccessTupleV1` - `AccessTupleV1`構造体のフィールドを含む0から`MAX_ACCESS_LIST_SIZE`個のオブジェクト、または`null`
- `maxPriorityFeesPerGas`: `FeesPerGasV1|null` - `FeesPerGasV1`構造体のフィールドを含むオブジェクトまたは`null`
- `blobVersionedHashes`: `Array of DATA|null` - 0から`MAX_BLOB_COMMITMENTS_PER_BLOCK`個の32バイトのDATAエントリ、または`null`

`FeesPerGasV1`は以下のようにSSZ `FeesPerGas` `StableContainer`にマッピングされます:

- `regular`: `QUANTITY|null`, 256ビットまたは`null`
- `blob`: `QUANTITY|null`, 256ビットまたは`null`

`AccessTupleV1`は以下のようにSSZ `AccessTuple` `Container`にマッピングされます:

- `address`: `DATA`, 20バイト
- `storageKeys`: `Array of DATA` - 0から`MAX_ACCESS_LIST_STORAGE_KEYS`個の32バイトのDATAエントリ

`TransactionSignatureV1`は以下のようにSSZ `TransactionSignature` `StableContainer`にマッピングされます:

- `from`: `DATA|null`, 20バイトまたは`null`
- `ecdsaSignature`: `DATA|null`, 65バイトまたは`null`

## 根拠

### なぜSSZトランザクションなのか?

1. **トランザクションの包含証明:** 現在、ブロック上にトランザクションハッシュのコミットメントはありません。したがって、特定のトランザクションがブロック内に含まれていることを証明するには、トランザクション本体全体を送信する必要があります。また、ブロック内のすべてのトランザクションハッシュのリストを証明するには、_すべて_のトランザクション本体を送信する必要があります。SSZでは、トランザクションを[「要約」](https://github.com/ethereum/consensus-specs/blob/ef434e87165e9a4c82a99f54ffd4974ae113f732/ssz/simple-serialize.md#summaries-and-expansions)することで、トランザクション本体を送信せずにトランザクションルートの証明を行うことができ、また、ルートの証明を使ってコンパクトなトランザクションの包含証明を行うことができます。

2. **軽量クライアントにとってより良い:** SSZでは、トランザクションやレシートの個々のフィールドを証明できます。これにより、軽量クライアントは自分に関連するフィールドのみを取得できます。さらに、一般的なフィールドは常に[一般化されたインデックス](https://github.com/ethereum/consensus-specs/blob/ef434e87165e9a4c82a99f54ffd4974ae113f732/ssz/merkle-proofs.md)で同じようにマーク化されるため、将来的に追加のトランザクションやレシートフィールドが導入されても、既存の検証ロジックが引き続き機能します。

3. **スマートコントラクトにとってより良い:** トランザクションやレシートの検証を行うスマートコントラクトは、トランザクションの個々の部分を証明できることから恩恵を受けます。ガス代が低くなり、トランザクションやレシートの全体がコールデータに収まらない場合でも処理できるようになります。

4. **データサイズが小さい:** SSZオブジェクトは通常Snappyフレーム圧縮を使用してコンパクトに圧縮されます。トランザクションの`input`と`access_list`フィールド、およびレシートの`logs_bloom`と`logs`フィールドには多くのゼロバイトが含まれており、この圧縮から恩恵を受けます。Snappyフレーム圧縮では、トランザクションやレシートのシーケンスを再圧縮せずに送信できるため、計算コストも低くなります。

### なぜトランザクションに`from`アドレスを含めるのか?

RLPから変換されたトランザクションの場合、`sig_hash`は元のRLP表現から計算されます。API クライアントに元のRLPエンコーディングとkeccakハッシュの実装を要求するのを避けるため、`from`アドレスをトランザクションの一部として含めています。

これにより、JSON-RPCのAPI要求を処理する際にsecp256k1の公開鍵回復を行う必要がなくなります。`from`アドレスはすでに知られているためです。

さらに、これにより、計算コストの高い`ecrecover`を行う前に、送信者アカウントの残高が不足していることを早期に拒否できるようになります。

### なぜレシートに`contract_address`を含めるのか?

新しく作成されたコントラクトのアドレスを計算するには、RLPエンコーディングとkeccakハッシュが必要です。オンチェーンでコミットメントを追加することで、API クライアントにそれらの形式を実装する必要がなくなります。

`contract_address`は対応する`Transaction`からのみ静的に決定可能ですが、それをレシートに含めることで、将来的にその計算方法を変更できるようになります。

### なぜ`ExecutionSigningData`なのか?

他のSSZオブジェクト(メッセージなど)に署名する必要がある場合、それらのハッシュが`sig_hash`と衝突しないことを確認する必要があります。SSZトランザクションに関する定数をミックスすることで、そのようなハッシュの衝突を防ぐことができます。

### EIP-2718トランザクションタイプについてはどうなっているのか?

すべてのSSZトランザクション(将来のものも含む)は単一の[EIP-2718](./eip-2718.md)トランザクションタイプ`TRANSACTION_TYPE_SSZ`を共有します。新しい機能は、`select_transaction_profile`によって決定される、オプションのフィールドの追加や、オプションフィールドの組み合わせの変更として導入できます。

これにより、組み合わせの爆発を抑えることもできます。たとえば、`access_list`プロパティをすべてのSSZトランザクションで省略可能にしても、定義されるトランザクションタイプの数を倍増する必要がなくなります。

### なぜ`NewPooledTransactionHashes`の`types`を再定義したのか?

eth/68で導入された`types`要素は、[EIP-5793](./eip-5793.md)により、ピアから特定のタイプのデータをフェッチする際のより良い制御を可能にします。

現在の実装では主に、`0x03`のブロブトランザクションを`0x00`、`0x01`、`0x02`の基本的なトランザクションタイプから区別するのに`types`を使用しています。しかし、すべてのSSZ `Transaction`は`0x04`(`TRANSACTION_TYPE_SSZ`)タイプを使用するため、この最適化の可能性がなくなります。

この最適化の可能性を復活させるため、`types`は代わりに`PooledTransaction`に存在する補助ペイロードを示すように再定義されます。SSZブロブトランザクションはRLPブロブトランザクションと共に`0x03`タイプを共有し、ベーシックなSSZトランザクションは現在RLPベーシックトランザクションに使用されている`0x01`タイプが割り当てられます。したがって、実装はブロブトランザクションと基本的なトランザクションを区別するために変更を加える必要がなくなります。

### なぜ`cumulative_gas_used`から`gas_used`にレシートを変更したのか?

[EIP-658](./eip-658.md)は、レシートからの中間的な事後状態`root`をブール値の`status`コードに置き換えました。同様に、`cumulative_gas_used`を`gas_used`に置き換えることで、最終的な状態依存フィールドを状態非依存のものに置き換えることができ、個別の状態で動作するトランザクションレシートの順序に依存する必要がなくなります。さらに、API クライアントは個々のトランザクションの`gas_used`を検証するために、複数のレシートを取得する必要がなくなります。

### レシートの`Log`データについてはどうなっているのか?

`Log`データはEthereum契約ABI に従ってフォーマットされています。元の構造に従ってログデータをマーク化するほうが有用ですが、ログイベントシグネチャのハッシュしか知られていません。発行されたEVMログからプリイメージが消去されているため、元のログイベントシグネチャを確実に復元することはできません。したがって、ログデータとトランザクション入力データは当面`ByteVector`として提供されます。

## 下位互換性

新しいトランザクション署名スキームは、SSZトランザクションにのみ使用されます。

既存のRLPトランザクションをSSZトランザクションに変換できます。元の`sig_hash`と`tx_hash`はSSZ表現から復元できます。

既存のRLPレシートをSSZレシートに変換できます。新しい`contract_address`フィールドを埋めるには、対応するトランザクションのシーケンス全体を知る必要があります。ただし、JSON-RPCがすでに`contract_address`を公開しているため、レシートのクエリを処理するには、トランザクションを知る必要があります。

## セキュリティ上の考慮事項

SSZの署名は、既存のRLPトランザクションおよびメッセージのハッシュと衝突してはいけません。

RLPメッセージはkeccak256でハッシュされ、すべてのSSZオブジェクトはSHA256でハッシュされます。これら2つのハッシュアルゴリズムは両方とも暗号学的に安全であり、根本的に異なるアプローチに基づいているため、これらのハッシュアルゴリズム間のハッシュ衝突のリスクは最小限に抑えられます。

さらに、RLPメッセージはシリアル化全体にわたってlinear にハッシュされるのに対し、SSZオブジェクトは再帰的なMerkleツリーを使ってハッシュされます。このメカニズムの違いにより、ハッシュ衝突のリスクがさらに低減されます。

## 著作権

著作権およびそれに関連する権利は[CC0](../LICENSE.md)で放棄されています。