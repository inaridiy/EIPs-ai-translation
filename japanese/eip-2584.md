---
original: c88304b2f3455f35add7b04ffa85e0efcfa5f519ef5eed4c2e7decdb052f5645
---

---
eip: 2584
title: オーバーレイツリーを使用したトライ形式の移行
author: Guillaume Ballet (@gballet)
discussions-to: https://ethresear.ch/t/overlay-method-for-hex-bin-tree-conversion/7104
status: 停滞
type: Standards Track
category: Core
created: 2020-04-03
---

## 簡単な要約

このEIPは、状態トライ形式をヘキサリーからバイナリに変換する方法を提案しています。新しい値は直接バイナリトライ「オーバーレイ」に格納されます。一方で、ヘキサリートライはバックグラウンドでバイナリトライに変換されます。プロセスが完了すると、両方の層が統合されます。

## 概要

このEIPでは、変換を完了するための4つのフェーズについて説明します。

  * 第1フェーズでは、ヘキサリートライがバイナリに変換されている間、すべての新しい状態の書き込みがオーバーレイバイナリトライに行われます。ブロックフォーマットは、ヘキサリートライ(以下「ベース」トライと呼ぶ)のルートとオーバーレイバイナリトライのルートの2つのストレージルートを持つように変更されます。
  * 変換を行うマイナーに十分な時間が与えられた後、第2フェーズが始まります。オーバーレイツリーは徐々にに新しく変換されたバイナリベーストライに統合されます。一定数のエントリがオーバーレイから削除され、ベーストライに挿入されます。
  * オーバーレイトライが空になると、第3フェーズが始まります。ブロックヘッダーからそのルートを保持するフィールドが削除されます。

## 動機

状態トライをヘキサリー形式からバイナリ形式に切り替えることに長年の関心があります。これは、証明とストレージサイズに関する理由によるものです。変換プロセスには追いつきの問題があり、これは完全な状態の巨大さが原因です。つまり、合理的な時間(ブロック時間と同程度)で変換することはできません。

## 仕様

この仕様は[イエローペーパー](https://ethereum.github.io/yellowpaper)で導入された表記に従います。読む前に、イエローペーパーに精通しておくことをお勧めします。

### バイナリトライ

このEIPでは、MPTを除いて以下のように定義されるバイナリトライを想定しています:

  * I₀の一連のバイトは一連のビットとして見なされ、したがって∀i≤256、I₀[i]はキーI₀の i 番目のビットです。
  * **拡張**または**リーフ**の最初の項目は、ニブルをビットに置き換えます。
  * **ブランチ**は2つの項目で構成される構造体で、両方の項目はこの時点でのキーの2つの可能なビット値に対応します。
  * c(𝕴,i) ≡ RLP((u(0), u(1)) at a branch, where u(j) = n({I : I ∈ 𝕴 ⋀ I₀[i] = j}, i+1)

ßは、与えられたヘキサリートライの等価な表現をこの前述のバイナリトライ形式で計算する関数です。

### フェーズ1

_h₁_を第1フェーズが開始するブロック高さ、_h₂_を第2フェーズが開始するブロック高さとします。_h₁ ≤ _h_ < h₂_の各ブロックについて:

  0. ヘキサリートライをバイナリ等価に変換するプロセスがバックグラウンドで開始されます。このプロセスの最終目的は、変換されたバイナリトライのルートハッシュ_Hᵣ²_を計算することです。ヘキサリートライのルートは以降_Hᵣ¹⁶_と呼びます。正式には、このプロセスはHᵣ² ≡ ß(Hᵣ¹⁶)と書けます。
  1. ブロックヘッダーには新しいHₒフィールドがあり、これはオーバーレイバイナリトライのルートです。
  2. Hᵣ ≡ P(H)ᵣ¹⁶、つまり、ヘキサリーからバイナリへの変換が完了するまでは、ヘキサリートライのルートがその親ブロックと同じです。

実行環境に以下の変更が加えられます:

  * _状態の読み取り_を実行する際、ϒはまずオーバーレイトライでアドレスを検索します。そこにキーが見つからない場合、ϒはh' < h₁のブロック高さと同様にベーストライを検索します。
  * _状態の書き込み_を実行する際、ϒはオーバーレイツリーにその値を挿入または更新します。ベーストリーは変更されません。
  * アカウントが削除された場合、ϒはそのアカウントのアドレスにH(∅)を挿入して削除を示します。そのようなアドレスからの読み取りは、ベーストライに何があっても、存在しないアカウントと同じように動作します。

フェーズ1は、マイナーが変換を行うのに十分な時間が経過したh₂ブロック高さで終了します。

### フェーズ2

  このフェーズは前のフェーズと以下の点で異なります:

  * h₂ブロック高さでは、ϒの実行前に、Hᵣ ≡ Hᵣ²、つまり遷移関数の実行前の値は変換されたバイナリベーストライのルートに設定されます。
  * Hₒはブロックツリーに存在し続けますが、オーバーレイトライの内容は_読み取りまたは削除_のみが可能です。
  * h ≥ h₂のブロック高さでは、ϒの実行前に、N個のアカウントがバイナリオーバーレイトライから削除され、バイナリベーストライに挿入されます。
  * _状態の書き込み_を実行する際、ϒは_ベース_トライに値を挿入または更新します。検索キーがオーバーレイトライに存在する場合、それは削除されます。

アカウントの削除は以下のルールに従って行われます:

  * オーバーレイツリーに残っている最初のN個のアカウント(辞書順)が選択されます。これらのアカウントについて:
  * 値が空ハッシュの場合、同じアドレスのアカウントをバイナリベーストライから削除します。
  * それ以外の場合、オーバーレイトライの値を使ってベーストライの対応するアドレスにアカウントを挿入/更新します。

オーバーレイトライが空になると、フェーズ2が終了し、フェーズ3が始まります。

### フェーズ3

フェーズ3はフェーズ2と同じですが、以下の変更があります:

  * Hₒがブロックヘッダーから削除されます

## 根拠

これまで議論されてきた方法には、変換に必要な大幅な時間の間チェーンを停止する「世界を停止する」アプローチと、アクセスされた際にブランチを変換する「書き換え時コピー」アプローチがあります。
ここで提案されているアプローチは、変換プロセス中にチェーンが通常通り動作し、予測可能な時間内にバイナリ形式に完全に変換されるという利点があります。

## 下位互換性

これはフォークを必要とし、ハッシュとブロックフォーマットが必然的に異なるため、下位互換性は失われます。オーバーレイツリーを実装していないクライアントやバイナリルートを受け入れないクライアントでは、フォークが発生します。緩和策は提案されていません。これはハードフォークです。

## テストケース

  * フェーズ1のテストでは、ヘキサリートライ内のすべてのキーがバイナリトライにも存在することを確認するだけで十分です。より緩やかですが高速なテストでは、ヘキサリートライのキーの1%をランダムに選択し、それらがバイナリトライに存在することを確認します。
  * フェーズ2&3のTBD

## 実装

変換プロセス(フェーズ1)のプロトタイプバージョンは、[このPR](https://github.com/holiman/go-ethereum/pull/12)で`geth`用に利用可能です。

## セキュリティ上の考慮事項

私が予見できる3つの攻撃ベクトルは以下の通りです:

  * オーバーレイトライが不当に大きくなるよう標的攻撃を行うこと。移行プロセス中にガス代が上がる可能性があるため、フェーズ2が長引くと、一定期間Ethereumがより高価になります。これは、フェーズ1中の`SSTORE`コストを上げることで解決できます。
  * 逆に、h₂が早すぎると、過半数のマイナーがHᵣ²の正しい値を生成できない可能性があります。
  * 51%以上のネットワークを占めるマイナーグループが無効な値を報告した場合、誰も文句を言えずに資金を盗む可能性があります。

## コミュニティフィードバック

  * 初期テストによると、高速なマシンでは変換に約30分かかることがわかっています。
  * このEIPの初期バージョンでは、マイナーがバイナリベースルートの値に投票することを想定していました。これは、プロセスの複雑さと「最長チェーン」ルールによってこの機能が既に保証されているため、削除されました。

## 著作権
著作権およびそれに関連する権利は[CC0](../LICENSE.md)によって放棄されています。