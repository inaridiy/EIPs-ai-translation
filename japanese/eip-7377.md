---
original: 736e57839e51326eae51004ab492e61c730c01d7ecfe451a3cef52557d2d0588
---

---
eip: 7377
title: マイグレーション・トランザクション
description: EOAがコードをデプロイする1回限りのトランザクションを送信できるようにする。
author: lightclient (@lightclient), Sam Wilson (@samwilsn), Ansgar Dietrichs (@adietrichs)
discussions-to: https://ethereum-magicians.org/t/eip-xxxx-migration-transaction/15144
status: Draft
type: Standards Track
category: Core
created: 2023-07-21
requires: 170, 1559, 2200, 2718
---

## 概要

[EIP-2718](./eip-2718.md)のトランザクションタイプを新しく導入する。フォーマットは `0x04 || rlp([chainId, nonce, maxFeePerGas, maxPriorityFeePerGas, gasLimit, codeAddr, storage, data, value, accessList, yParity, r, s])` で、送信アカウントの `code` フィールドを `codeAddr` の `code` 値に設定し、送信者のストレージトライにストレージタプルを適用する。

## 動機

スマートコントラクトウォレットは、Ethereumのユーザーエクスペリエンスの問題を解決する解決策として長年提唱されてきました。2015年の時点で、新しいユーザーがスマートコントラクトウォレットにアセットを保管するのを促すために、スマートコントラクトが取引を発信できるようにする提案がありました。しかし、現在のところ、ユーザーの一部しかそうしていません。

今日でも、アカウントの抽象化はEthereumにとって重要な目標であり、これを実現しようとする多くの取り組みがあります。この目標に近づきつつありますが、長年の失敗により、多くのユーザーはEOAに頼るようになってしまいました。

ユーザーがEOAに十分なアセットを蓄積した後、個々のアセットを新しいアドレスに移行するのは現実的ではありません。これは、コストと、数百もの取引に手動で署名し検証する必要があるためです。

これは問題の見落とされた部分です。既存のユーザーをスマートコントラクトウォレットに効率的に移行することは、アドプションを加速し、スマートコントラクトウォレットのためのより良いサポートと統合を推進することになります。スマートコントラクトウォレットはもはやニッチな用途とは見なされなくなるでしょう。

したがって、EOAをスマートコントラクトに移行するためのメカニズムを、プロトコルに組み込む必要があります。このEIPはそのようなメカニズムを提案するものです。

## 仕様

フォークブロック `X` で、マイグレーショントランザクションタイプを導入する。

### マイグレーショントランザクション

#### 定義

| フィールド                  | 型        |
|------------------------|-----------|
| `chainId`              | `uint256` |
| `nonce`                | `uint64`  |
| `maxFeePerGas`         | `uint256` |
| `maxPriorityFeePerGas` | `uint256` |
| `gasLimit`             | `uint64`  |
| `codeAddr`             | `address` |
| `storage`              | `List[Tuple[uint256, uint256]]` |
| `data`                 | `bytes`   |
| `value`                | `uint256` |
| `accessList`           | `List[Tuple[address, List[uint256]]]` |
| `yParity`              | `uint8`   |
| `r`                    | `uint256` |
| `s`                    | `uint256` |

EIP-2718の `TransactionType` は `0x04` で、`TransactionPayload` は `rlp([chainId, nonce, maxFeePerGas, maxPriorityFeePerGas, gasLimit, codeAddr, storage, data, value, accessList, yParity, r, s])` です。

トランザクションの署名ハッシュは `keccak256(0x04 || rlp([chainId, nonce, maxFeePerGas, maxPriorityFeePerGas, gasLimit, codeAddr, storage, data, value, accessList])` です。

#### 検証

マイグレーショントランザクションは、以下の条件を満たす場合に有効とみなされます:

* [EIP-1559](./eip-1559.md)の全プロパティ、別途指定のない限り
* `codeAddr` のコードが[EIP-170](./eip-170.md)の制限である `24576` 未満であること
* `codeAddr` のコードサイズが `0` ではないこと

[EIP-1559](./eip-1559.md)から変更された固有ガス計算は、`21000 + 16 * 非ゼロコールデータバイト数 + 4 * ゼロコールデータバイト数 + 1900 * アクセスリストストレージキー数 + 2400 * アクセスリストアドレス数 + 20000 * ストレージ長` です。

#### 処理

マイグレーショントランザクションの実行には2つの部分があります。

##### コントラクトデプロイ

標準的なコントラクトデプロイとは異なり、マイグレーショントランザクションでは、送信者のアカウントに設定するべき `code` 値を直接指定します。

トランザクション処理の最初のステップとして、送信者の `code` を `state[tx.codeAddr].code` に設定します。次に、`tx.storage` の各タプルと送信者のストレージトライについて、`storage[t.first] = t.second` を設定します。

##### トランザクション実行

次に、[EIP-1559](./eip-1559.md)と同じルールを使って、送信者のアカウントにEVMコールを呼び出し、トランザクションの発信元を `keccak256(sender)[0..20]` に設定します。

## 根拠

### `to` アドレスフィールドなし

このトランザクションは、EOAをスマートコントラクトに移行するための1回限りの使用を目的としています。デプロイ後すぐに、送信者が任意の追加処理を行えるよう、デプロイされたコントラクトを呼び出すように設計されています。

### デプロイメントのためのコードポインター

単純に考えると、マイグレーショントランザクションに `code` フィールド(`bytes`型)を持たせることができます。しかし、多くのユーザーが同じものをデプロイしたい(多くの場合はウォレット)ため、コールデータが大幅に重複することになります。ポインターを使うことで、このトランザクションタイプの圧倒的な使用例を認識し、それを最適化することができます。

### より安価なストレージ

ストレージが空であることが保証されているため、読み取りの必要がありません。これにより、[EIP-2200](./eip-2200.md)の `SSTORE_SET_GAS` 値の20,000ガスのみで済みます。これは、通常の `22,100` (つまり `SSTORE_SET_GAS` と[EIP-2929](./eip-2929.md)の `COLD_SLOAD_COST` の2,100)よりも少ないコストです。

### 固有ガスはコントラクトデプロイを考慮しない

クライアントは通常、コードの単一の一意のコピーを保存するため、デプロイの数に関係なくこの操作は可能です。つまり、ここでの唯一の操作は、状態トライ内のポインターを目的のコードに変更することです。

さらに、マイグレーショントランザクションが有効とみなされるためには、EOAにすでに十分な残高があることが必要です。したがって、新しいアカウントを状態トライに追加するためのプレミアムを支払う必要はありません。

### トランザクション発信元の操作

多くのアプリケーションでは、`caller == origin` というセキュリティチェックを行い、呼び出し元がEOAであることを確認しています。これは「資産を保護する」ためです。これは通常、根本的な解決策ではなく、応急措置に過ぎませんが、我々はこれらのプロジェクトを納得させるために、トランザクションの発信元を変更しようとしています。

### 1回限りのマイグレーション

技術的には、EOAがいつでもこのトランザクションタイプでコードを変更できるようにすることはできます。現時点で阻害要因となっているのは[EIP-3607](./eip-3607.md)で、これによりマイグレーショントランザクションは、アカウントにすでにコードがデプロイされている場合に無効とみなされます。ただし、機能的な理由として、これを維持することで、コントラクトとそのアップグレード可能性について、より簡単に理解できるようになります。

## 下位互換性

下位互換性の問題はありません。

## セキュリティ上の考慮事項

### ブラインド署名

他のすべての十分に洗練されたアカウント設計と同様に、ユーザーが任意のメッセージに署名させられた場合、そのメッセージがユーザーではなく悪意のある主体が所有するマイグレーショントランザクションである可能性があります。これは、ウォレットがこれらのトランザクションを極端に慎重に扱い、署名を完了する前に可能な限り多くの摩擦と検証を行えば、一般的に回避できます。

### `ecrecover` について

[ERC-2612: Permit Extension](./eip-2612.md)のようなアプリケーション標準では、EOAアドレスとその秘密鍵の暗号学的関係が利用されています。多くのトークンがこの拡張をサポートしており、EOAがわずかな署名で自分のアカウントからの資金移動を承認できるようになっています。EOAとコントラクトアカウントの衝突は、現在の計算能力では考えにくく[おそらく不可能](./eip-3607.md)とされていますが、このEIPにより、コントラクトアカウントの秘密鍵の存在が一般的になります。ここにはいくつかのセキュリティ上の考慮事項があります:

* 明らかな攻撃は、デファイプロトコルがこのEIPを使ってコントラクトをデプロイし、後に[ERC-2612](./eip-2612.md)のメッセージに署名して、コントラクトに蓄積された資金を盗もうとするというものです。これは、ウォレットがこのような方法でデプロイされたプロトコルとのやり取りを許可しないことで回避できます。
* また、このEIPがクロスチェーンの経験にどのような影響を与えるかについても検討する必要があります。最終的には、ユーザーの秘密鍵がアカウントの資産に一定の制御権を持ち続ける可能性があり、これはEthereumや他のチェーンで使用されるプロトコルによって異なります。アカウントが移行されたからといって、ユーザーが秘密鍵を公開しても安全だと考えるのは不適切です。これは、特にユーザーがアドレスを他のEVM互換チェーンで使いたい場合に、合理的な要求であると思われます。

これらの問題を一定程度緩和するためには、`ecrecover`にEXTCODEHASHチェックを追加することが考えられます。回復されたアカウントにコードがある場合、プリコンパイルが失敗するようにすれば、[ERC-2612](./eip-2612.md)のようなスタンダードの使用を阻止できます。

## 著作権

著作権およびそれに関連する権利は[CC0](../LICENSE.md)で放棄されています。