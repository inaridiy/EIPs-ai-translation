---
original: d77777a34ddb3e07aebf8d1813d55c3ddf5ab10e518b536bc6cc7b2ec5194c63
---

---
eip: 6110
title: チェーン上のサプライバリデーターデポジットの提供
description: 実行レイヤーブロックに追加されたデポジット操作のリストとしてバリデーターデポジットを提供します
author: Mikhail Kalinin (@mkalinin)、Danny Ryan (@djrtwo)、Peter Davies (@petertdavies)
discussions-to: https://ethereum-magicians.org/t/eip-6110-supply-validator-deposits-on-chain/12072
status: Review
type: Standards Track
category: Core
created: 2022-12-09
requires: 7685
---

## 概要

バリデーターデポジットを実行レイヤーブロック構造に追加します。これにより、デポジットの包含と検証の責任が実行レイヤーに移り、コンセンサスレイヤーからのデポジット(または `eth1data`)投票の必要性が排除されます。

ブロックに提供されるバリデーターデポジットリストは、対象ブロックに含まれる各デポジットトランザクションから発行されたデポジットコントラクトログイベントを解析することで取得されます。

## 動機

バリデーターデポジットは、proof-of-stake コンセンサスメカニズムの中核的な要素です。このEIPにより、コンセンサスレイヤーでのデポジット処理のインプロトコルメカニズムが可能になり、現在利用されている提案者投票メカニズムが不要になります。この提案されたメカニズムは安全性の前提条件を緩和し、クライアントソフトウェアの設計の複雑さを低減することで、デポジットフローのセキュリティに貢献します。また、バリデーターのユーザー体験も向上します。

インプロトコルデポジット処理の利点は以下の通りです:

* 提案者投票を置き換えることで、デポジットのセキュリティを大幅に向上させます。提案されたインプロトコルメカニズムでは、ステークの2/3以上が悪意的であっても、オンラインの正直なノードが偽のデポジットを処理させられることはありません。
* 実行レイヤーでのデポジットトランザクション送信からコンセンサスレイヤーでの処理までの遅延を大幅に短縮できます。つまり、現在の仕組みでは約12時間かかるところ、インプロトコルデポジット処理では約13分で済みます。
* JSON-RPC APIデータのポーリングに依存するビーコンブロック提案の依存関係を排除できます。これは、JSON-RPC API実装間の不整合や、クライアントソフトウェアの内部状態(同期状態など)に依存する API呼び出し処理の失敗に悩まされることがなくなります。
* デポジットコントラクトのスナップショットの維持と配布の要件([EIP-4881](./eip-4881.md))を排除できます。
* コンセンサスレイヤークライアントソフトウェアの設計と実装の複雑さを大幅に削減できます。この部分は脆弱性の原因となってきました。

## 仕様

### 実行レイヤー

#### 定数

| 名称 | 値 | コメント |
| - | - | - |
|`FORK_TIMESTAMP` | *TBD* | Mainnet |
|`DEPOSIT_REQUEST_TYPE` | `b'0'` | [EIP-7685](./eip-7685.md)におけるデポジット操作のリクエストタイプバイト |

#### 設定

| 名称 | 値 | コメント |
| - | - | - |
|`DEPOSIT_CONTRACT_ADDRESS` | `0x00000000219ab540356cbb839cbe05303d7705fa` | Mainnet |

`DEPOSIT_CONTRACT_ADDRESS`パラメーターは**必ず**クライアントソフトウェアのバイナリ配布に含める必要があります。

#### 定義

* **`FORK_BLOCK`** -- `timestamp`が`FORK_TIMESTAMP`以上の最初のブロック。

#### デポジット

新しいデポジット操作を表す構造体は以下のフィールドで構成されます:

1. `pubkey: Bytes48`
2. `withdrawal_credentials: Bytes32`
3. `amount: uint64`
4. `signature: Bytes96`
5. `index: uint64`

デポジットは[EIP-7685](./eip-7685.md)リクエストの一種であるため、構造体のエンコーディングは`DEPOSIT_REQUEST_TYPE`バイトを使って計算する必要があります:

```python
deposit_request_rlp = DEPOSIT_REQUEST_TYPE + rlp([
    pubkey,
    withdrawal_credentials,
    amount,
    signature,
    index
])
```

エンコードされたデポジットは、EIP-7685で定義されたフォーマットに従って、ヘッダーとボディに一般的なリクエストとして含まれます。

#### ブロックの有効性

`FORK_BLOCK`以降、クライアントソフトウェアは以下の条件を含むブロック有効性ルールセットを拡張しなければなりません:

1. ブロックに含まれるデポジット操作のリストは、対象ブロックの各デポジットトランザクションから発行されたログイベントと等しくなければなりません。

2. ブロックに蓄積されたそれぞれのデポジットは、ログに現れた順序でEIP-7685リクエストリストに現れなければなりません。例示すると以下のようになります:

```python
def parse_deposit_data(deposit_event_data) -> bytes[]:
  """
  DepositContractのDepositEventデータからデポジット操作を解析します
  """
  pass

def little_endian_to_uint64(data: bytes) -> uint64:
    return uint64(int.from_bytes(data, 'little'))

def event_data_to_deposit_request_rlp(deposit_event_data) -> bytes:
    deposit_data = parse_deposit_data(deposit_event_data)
    pubkey = Bytes48(deposit_data[0])
    withdrawal_credentials = Bytes32(deposit_data[1])
    amount = little_endian_to_uint64(deposit_data[2])
    signature = Bytes96(deposit_data[3])
    index = little_endian_to_uint64(deposit_data[4])

    return DEPOSIT_REQUEST_TYPE + rlp([
        pubkey, withdrawal_credentials, amount, signature, index
    ])

# ブロック実行結果からレシートを取得
receipts = block.execution_result.receipts

# ブロック内で行われたすべてのデポジットを取り出す
expected_deposit_requests = []
for receipt in receipts:
    for log in receipt.logs:
        if log.address == DEPOSIT_CONTRACT_ADDRESS:
            deposit_request_rlp = event_data_to_deposit_request_rlp(log.data)
            expected_deposit_requests.append(deposit_request_rlp)

deposit_requests = [req for req in block.body.requests if req[:1] == DEPOSIT_REQUEST_TYPE]

# ブロック内のデポジット操作リストと取り出したデポジットを比較
assert deposit_requests == expected_deposit_requests
```

上記の条件を満たさないブロックは**無効**とみなされなければなりません。

### コンセンサスレイヤー

コンセンサスレイヤーの変更点は以下の通りです:

1. `ExecutionPayload`に新しい`deposit_receipts`フィールドが追加され、デポジット操作のリストを収容できるようになります。
2. `BeaconState`に`deposit_receipts_start_index`が追加され、従来のデポジット処理メカニズムから新しいものへの移行に使用されます。
3. 移行ロジックの一環として、`Eth1Data`ポーリングの使用を制限する新しいビーコンブロック有効性条件が追加されます。
4. `deposit_receipts`の処理を行う新しい`process_deposit_receipt`関数がブロック処理ルーチンに追加されます。

コンセンサスレイヤーの詳細な仕様は以下のドキュメントにあります:

* [`eip6110/beacon-chain.md`](https://github.com/ethereum/consensus-specs/blob/2660af05390aa61f06142e1c6311a3a3c633f720/specs/_features/eip6110/beacon-chain.md) -- ステート遷移
* [`eip6110/validator.md`](https://github.com/ethereum/consensus-specs/blob/2660af05390aa61f06142e1c6311a3a3c633f720/specs/_features/eip6110/validator.md) -- バリデーターガイド
* [`eip6110/fork.md`](https://github.com/ethereum/consensus-specs/blob/2660af05390aa61f06142e1c6311a3a3c633f720/specs/_features/eip6110/fork.md) -- EIP適用

#### バリデーターインデックスの不変性

`Eth1Data`ポーリングの大きな追従遅延により、デポジット処理中に新しいバリデーターに割り当てられるインデックスは、ブロックツリーの異なる枝でも同じになります。つまり、既存のメカニズムでは`(pubkey, index)`キャッシュがリオーガニゼーション耐性を持っています。新しいデポジット処理機構ではこの不変性が破られ、コンセンサスレイヤークライアントは同じ`pubkey`を持つバリデーターが異なるブロックツリーの枝で異なるインデックスを持つ可能性があることに対処する必要があります。

詳細な[分析](../assets/eip-6110/pubkey_to_index_cache_analysis.md)によると、`process_deposit`関数は*唯一の*フォーク依存の`(pubkey, index)`キャッシュを必要とする場所です。

#### `Eth1Data`ポーリングの非推奨化

コンセンサスレイヤークライアントは、移行期間が終了した後、`Eth1Data`ポーリングメカニズムを非協調的に削除できるようになります。移行期間は、ネットワークが`state.eth1_deposit_index == state.deposit_receipts_start_index`に到達した時点で終了したと見なされます。

## 根拠

### `index`フィールド

`index`フィールドは見えにくいかもしれませんが、コンセンサスレイヤーでのデポジット処理フローにとって重要な情報です。

### デポジット操作リストのサイズを制限しない

データ複雑性が低く、潜在的なDoS攻撃ベクトルがないため、リストのサイズは無制限とします。詳細は[セキュリティ上の考慮事項](#セキュリティ上の考慮事項)をご覧ください。

### `DEPOSIT_CONTRACT_ADDRESS`のみでイベントをフィルタリングする

デポジットコントラクトは`DepositEvent`以外のイベントを発行しないため、追加のフィルタリングは不要です。

## 下位互換性

このEIPはブロック構造とブロック検証ルールセットに下位互換性のない変更を導入します。しかし、これらの変更はユーザーアクティビティや体験に関連するものではありません。

## セキュリティ上の考慮事項

### データ複雑性

この文書の最新更新時点で、提出されたデポジットの総数は824,598で、これはデポジットデータが164MBに相当します。デポジットトランザクションの頻度が同じ水準で推移すると仮定すると、このEIPによって引き起こされる履歴チェーンデータの複雑性は年間60MBと見積もられ、これは他の履歴データに比べて無視できるレベルです。

2020年12月のビーコンチェーン立ち上げ以降、提出されたデポジットが最も多かったのは2023年6月1日で、24時間で12,000件を超えるデポジットトランザクションが送信されました。これは平均すると1ブロックあたり2件未満、つまり384バイトのデータに過ぎません。

以上から、本提案によって引き起こされるデータ複雑性は無視できると結論付けます。

### DoS攻撃ベクトル

デポジットコントラクトのコードは、すべてのストレージスロットがホットで、単一のリーフのみを変更する最も安価なケースでも15,650ガスかかります。バッチデポジットの中には、より高価なものもありますが、それらのコストは大量のデポジットにわたって平均化すると、デポジットあたり約1,000ガスと小さくなります。現在のガス価格ルールでは、ETHの転送を行う`CALL`に6,900ガスの追加料金がかかりますが、これはガス価格の非効率的な設定であり、将来的に削減される可能性があります。将来の堅牢性のために、ビーコンチェーンは30Mガスブロックで1,916件のデポジットを処理できる必要があります。現在のルールでは、30Mガスブロックで1,271件のデポジットが限界です。

#### 実行レイヤー

最小デポジット額が1 ETHの場合、デポジットデータのバイト当たりの最低コストは1 ETH/192 ~ 5,208,333 Gweiです。これはトランザクションのコールデータのバイト当
たりのコストよりも数桁高いため、ブロックにデポジット操作を追加しても、実行レイヤーのDoS攻撃面は増加しません。

#### コンセンサスレイヤー

デポジット処理で最も計算コストのかかるのは署名の検証です。その複雑性は、ブロックあたりの最大デポジット数(現在は30Mガスブロックで約1,271件)によって制限されます。つまり、約1,271件の署名検証、およそ1.2秒の処理時間(最適化なし)です。攻撃者が1秒の遅延を引き起こすためには1,000 ETHを費やす必要があり、長期的に持続可能な攻撃とは言えません。

楽観的に同期するノードは、より深刻な攻撃シナリオに晒される可能性があります。そのようなノードはペイロードに提供されるデポジットリストを検証できないため、攻撃者は制限いっぱいのデポジットを含めることができます。現在は8,192件(1.5MBのデータ)で、処理時間は約8秒です。攻撃者がこのブロックに経済的に成立する署名を付ける必要があることを考えると(代替チェーンを構築し、同期ノードに供給する必要がある)、この攻撃ベクトルは同期プロセスを大幅に遅延させることはできないため、実用的ではないと考えられます。

### 楽観的同期

楽観的に同期するノードは、多数派が正直であるという前提に依存しなければなりません。つまり、攻撃者が十分な力を持っている場合、デポジットシーケンスを確定化できるため、同期ノードはデポジットレシートの有効性に関わらずこれらのデポジットを適用しなければなりません。したがって、無効なチェーンを確定化できる攻撃者は、正直なノードに偽のデポジットを受け入れさせることもできます。これは、現在の実行レイヤーの世界状態の有効性にも当てはまり、新しいデポジット処理設計はこの点でも既存のセキュリティモデルの範囲内にあります。

オンラインノードはこの状況に騙されることはありません。なぜなら、彼らの実行レイヤーはブロックの実行に関連して提供されたデポジットを検証するからです。

### 弱い主観性期間

このEIPは1エポックあたりのデポジット数の上限を撤廃し、ブロックガス制限がこの数の唯一の制限となります。つまり、1エポックあたりのデポジット数の制限は、`MAX_DEPOSITS * SLOTS_PER_EPOCH = 512`から、`max_deposits_per_30m_gas_block * SLOTS_PER_EPOCH ~ 32,768`(30Mガスブロックの場合、簡単のため`max_deposits_per_30m_gas_block = 1,024`と仮定)に移行します。

この変更は、弱い主観性期間の計算に使用される1エポックあたりのトップアップ数に影響します。自身のバリデーターをトップアップすることで、リークしているバリデーターに対する自身の持ち分を即座に増やすことができます。[分析](../assets/eip-6110/ws_period_analysis.md)では、弱い主観性期間のサイズが大幅に減少することは示されていません。さらに、そのような攻撃は前提条件の1つとしてかなりのステークを失うことが必要であるため、実用的ではないと考えられます。

## 著作権

著作権およびそれに関連する権利は[CC0](../LICENSE.md)によって放棄されています。