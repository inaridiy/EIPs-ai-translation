---
original: 3dfeee49e04f140aaf4835e377601cc59a9f1ec84c888da7811432a535e2e83f
---

---
eip: 7543
title: EVMの任意精度小数演算
description: このEIPは、すべての基本関数を正確なガス消費量で任意精度小数浮動小数点演算できるOPCODEを追加します。
author: 1m1 (@1m1-github)
discussions-to: https://ethereum-magicians.org/t/decimal-math-on-evm/16194
status: Draft
type: Standards Track
category: Core
created: 2023-10-22
---


## 概要

このEIPは、DECADD、DECNEG、DECMUL、DECINV、DECEXP、DECLN、DECSINのOPCODEを追加し、任意精度小数浮動小数点演算を可能にします。int256の係数と指数で表現できる最大精度までの小数値は正確に表現されます(c*10^q)。すべての実装アルゴリズムは、ユーザーが選択した精度で収束します。すべての計算は決定論的であり、ガスは底上げ方式で正確に組み込まれています。任意精度小数の基本関数を使えるようになることで、金融、機械学習、科学、デジタルアート、ゲームなどの分野からEthereumに新しい可能性が生まれます。実装は機能しています。

## 動機

現在、非整数値のべき乗a^bを計算するには膨大なSolidityコードが必要です。
例えば、年間変動率を日次変動率に変換するには16乗根を取る必要があります。

科学電卓と同等の機能を提供することで、より複雑なアプリケーションの開発が可能になります。

[BlackScholes.yul](../assets/eip-7543/BlackScholes.yul)と[Neuron.yul](../assets/eip-7543/Neuron.yul)のファイルは、これらのOPCODEがどのようにスマートコントラクトのコードを簡素化するかを示しています。

### なぜ小数なのか

0.1のような単純な値をバイナリで表現するには無限の桁数が必要で、有限のバイナリマシンでは正確に表現できません。一方、小数型は人間が行う大半の数値計算に非常に適しています。

### EVMについて

EVMは仮想マシンなので、ハードウェアの制限を受けません。通常、アセンブリ言語はハードウェアの機能をミミックするOPCODEを提供しますが、仮想マシンでは制限はありません。適切なガス代を設定さえすれば、より複雑なOPCODEを追加できます。一方で、OPCODEライブラリを過剰に増やしたくありません。EXP、LN、SINは汎用関数であり、べき乗、三角関数、積分、微分方程式、機械学習、デジタルアートなどの道を開きます。

## 仕様

### 小数

小数は以下のように定義されます:

c * 10^q

ここで、cとqはint256です。

表記方法:
a = ac * 10^aq
b = bc * 10^bq
など

### OPCODE定義

0xd0 DECADD a+b -> c    : (ac, aq, bc, bq, precision) -> (cc, cq)
0xd1 DECNEG  -a -> b    : (ac, aq) -> (bc, bq)
0xd2 DECMUL a*b -> c    : (ac, aq, bc, bq, precision) -> (cc, cq)
0xd3 DECINV 1/a -> b    : (ac, aq, precision) -> (bc, bq)
0xd4 DECEXP exp(a) -> b : (ac, aq, precision, steps) -> (bc, bq)
0xd5 DECLN   ln(a) -> b : (ac, aq, precision, steps) -> (bc, bq)
0xd6 DECSIN sin(a) -> b : (ac, aq, precision, steps) -> (bc, bq)

`precision`は計算中に保持する桁数、`steps`はDECEXPとDECSINのテイラー展開ステップ数、DECLNの連分数展開の深さを表します。

### なぜこれらの関数なのか

提案された関数(+、-、*、/、exp、ln、sin)は、すべての基本関数の計算を可能にする小さなセットを形成します。これには、多項式、有理関数、三角関数、双曲関数、指数関数とそれらの逆関数からなる有限個の和、積、根、合成が含まれます。

a^b = exp(b * ln(a))により、べき乗と多項式が得られます。
cos(a) = sin(tau/4-a)、tan(a)=sin(a)/cos(a)などにより、三角関数全体が得られます。

算術演算と合わせて、すべての基本関数が得られます。

### DECNEG vs DECSUB

否定は減算よりも一般的な操作です。OPCODEは可能な限り基本的で、必要に応じて複雑にするべきです。
同様の理由で、DECINVはDECDIVの代わりに用意されています。

DECSUB(a,b) = DECADD(a,DECNEG(b))
DECDIV(a,b) = DECMUL(a,DECINV(b))

### テイラー級数によるDECEXP、DECSIN

expとsinのテイラー級数は全域で収束し、収束が速い。ステップ数の階乗に比例して誤差が減少します。

### 連分数によるDECLN

LnはInterval]0,2]内で連分数を使って高速に収束します。入力をこの区間にスケーリングし、結果を適切にスケーリングし直します。


このドキュメントのキーワード "MUST"、"MUST NOT"、"REQUIRED"、"SHALL"、"SHALL NOT"、"SHOULD"、"SHOULD NOT"、"RECOMMENDED"、"NOT RECOMMENDED"、"MAY"、"OPTIONAL" は、RFC 2119およびRFC 8174の説明に従って解釈されます。

## 根拠

### ガス

上記のすべてのOPCODEは決定論的なので、ガスコストを事前に決定できます。一方で、計算は複雑で入力に依存します。

ノードへの DoS 攻撃を避けるには、正確なガスコストが不可欠です。

そのため、uint256ライブラリをガス消費追跡付きでラップすることが重要です(../assets/eip-EVM+/uint256_wrapped.goの参照実装を参照)。これにより、OPCODEを実行して底上げ方式でガスコストを計算できます。

EVMインタプリタはOPCODEを実行する前にガスコストを期待するため、2回OPCODEを実行する必要があります。最初の実行は2回目の実行と同一で、底上げガスコストを取得するためです。その後、固定エミュレーションコストを加算します。

これにより、複雑なOPCODEに適した組み込みガス計算が実現します(../assets/eip-EVM+/gasEVMPlusEmulate.goのgasEVMPlusEmulateを参照)。

ガス二重消費を避けるには、入力に依存するガス上限を見つける必要があります。
または、将来のEIPでは以下を提案します: 契約コードがガスを実行時に蓄積し、上限を超えた場合にパニックする仕組みを導入する。これは、ユーザー入力とコントラクト内部バイトコードのみに依存する「純粋」な契約コードにのみ適用できます。純粋な契約は、チェーンの状態を使用したり、他のコントラクトを呼び出したりすることはできません。純粋な数学関数は、純粋な契約の例です。純粋な契約は入力によって完全に決定論的なので、ユーザーはオフラインでガスコストを見積もれ、EVMは実行時にパニックできます。

コストは入力に依存するため、ファジングでワーストケースに近い値を得られます(TODO)。

## 下位互換性

下位互換性の問題はありません。

EVMでは無効なコードを持つコントラクトをデプロイできるため、新しいOPCODEを追加すると、以前は無効だったコードが有効になる可能性があります。EVMは、すべてのバイトコードの先頭にバージョンタグを期待したり、有効なコードのみをデプロイするよう設計したりすることで、この問題に対処できます。これは、新しいOPCODEを追加する際の一般的な問題です。

## テストケース

../assets/eip-EVM+/decimal_float_test.go

## 参考実装

参考実装は../assets/eip-EVM+/decimal_float.goにあります。

## セキュリティ上の考慮事項

数値の正確性が保証され、ガスが公平に徴収されれば、セキュリティ上の問題はありません。

## 著作権

著作権およびそれに関連する権利は[CC0](../LICENSE.md)で放棄されています。