---
original: dc84060959f046b200f6b2069b8f19615667b26d32b7cbad30a9b42b7e2fd5ad
---

---
eip: 2537
title: BLS12-381曲線演算のプリコンパイル
description: BLS署名検証などの効率的な演算を行うために、BLS12-381曲線上の演算をプリコンパイルとして追加する。
author: Alex Vlasov (@shamatar)、Kelly Olson (@ineffectualproperty)、Alex Stokes (@ralexstokes)、Antonio Sanso (@asanso)
discussions-to: https://ethereum-magicians.org/t/eip2537-bls12-precompile-discussion-thread/4187
status: Review
type: Standards Track
category: Core
created: 2020-02-21
---

## 概要

BLS12-381曲線上の演算、特にBLS署名検証のための演算を効率的に実行する機能を追加する。

曲線演算に加えて、BLS署名検証時の公開鍵の集約や個々の署名の集約を効率的に行うためのマルチ指数演算も含まれる。

## 動機

このプリコンパイルを追加する動機は、BN254プリコンパイルでは80ビットのセキュリティしか提供できないのに対し、ペアリング友好曲線上の演算で120ビット以上のセキュリティを得られるようにすることである。

## 仕様

### 定数

| 名称                 | 値   | コメント           |
|---------------------|------|-------------------|
| `FORK_TIMESTAMP`    | *TBD* | メインネット       |
| BLS12_G1ADD         | 0x0b  | プリコンパイルアドレス |
| BLS12_G1MUL         | 0x0c  | プリコンパイルアドレス |
| BLS12_G1MSM         | 0x0d  | プリコンパイルアドレス |
| BLS12_G2ADD         | 0x0e  | プリコンパイルアドレス |
| BLS12_G2MUL         | 0x0f  | プリコンパイルアドレス |
| BLS12_G2MSM         | 0x10  | プリコンパイルアドレス |
| BLS12_PAIRING_CHECK | 0x11  | プリコンパイルアドレス |
| BLS12_MAP_FP_TO_G1  | 0x12  | プリコンパイルアドレス |
| BLS12_MAP_FP2_TO_G2 | 0x13  | プリコンパイルアドレス |

`block.timestamp >= FORK_TIMESTAMP`の場合、以下の9つのプリコンパイルを導入する:

- BLS12_G1ADD - G1上の点加算を行う。ガスコストは500ガス。
- BLS12_G1MUL - G1上の点乗算を行う。ガスコストは12000ガス。
- BLS12_G1MSM - G1上のマルチ標数乗算(MSM)を行う。ガスコストは対応するセクションで定義。
- BLS12_G2ADD - G2上の点加算を行う。ガスコストは800ガス。
- BLS12_G2MUL - G2上の点乗算を行う。ガスコストは45000ガス。
- BLS12_G2MSM - G2上のマルチ標数乗算(MSM)を行う。ガスコストは対応するセクションで定義。
- BLS12_PAIRING_CHECK - G1とG2の点のペアリング演算を行う。ガスコストは対応するセクションで定義。
- BLS12_MAP_FP_TO_G1 - 基礎体の要素をG1の点にマッピングする。ガスコストは5500ガス。
- BLS12_MAP_FP2_TO_G2 - 拡大体の要素をG2の点にマッピングする。ガスコストは75000ガス。

マッピング関数の仕様は別の[文書](../assets/eip-2537/field_to_curve.md)に記載されている。このマッピング関数は、バイト列を体の要素にマッピングする部分は含まない(これは様々な方法で効率的に実装できるため)が、体の要素を曲線の点にマッピングする部分のみを含む。署名スキームに必要な機能である。

### 曲線パラメータ

BLS12曲線は以下のパラメータで完全に定義される(BLS12曲線のすべてについて係数`A=0`):

```
基礎体のモジュラス = p = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab
Fp - 位数pの有限体
曲線Fp方程式: Y^2 = X^3+B (mod p)
B係数 = 0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004
主部分群の位数 = q = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001
拡大体
Fp2の構成:
Fp2の2次非剰余元 = nr2 = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaaa
Fp2 = Fp[X]/(X^2-nr2)
曲線Fp2方程式: Y^2 = X^3 + B*(v+1) ここでvはnr2の平方根
Fp6/Fp12の構成:
Fp2の3次非剰余元 c0 = 0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
Fp2の3次非剰余元 c1 = 0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
ねじれパラメータ:
ねじれの種類: M
ねじれc0のB係数 = 0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004
ねじれc1のB係数 = 0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004
ジェネレータ:
H1:
X = 0x17f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb
Y = 0x08b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3edd03cc744a2888ae40caa232946c5e7e1
H2:
X c0 = 0x024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8
X c1 = 0x13e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e
Y c0 = 0x0ce5d527727d6e118cc9cdc6da2e351aadfd9baa8cbdd3a76d429a695160d12c923ac9cc3baca289e193548608b82801
Y c1 = 0x0606c4a02ea734cc32acd2b02bc28b99cb3e287e85a763af267492ab572e99ab3f370d275cec1da1aaa9075ff05f79be
ペアリングパラメータ:
|x| (ミラーループスカラー) = 0xd201000000010000
xは負の値 = true
```

基礎体のモジュラス`p`が`3 mod 4`であることに注意。これにより平方根の抽出が効率的に行えるが、圧縮解除のガスコストは圧縮されたポイントデータを`calldata`で供給するよりも大きくなる。

### 体とグループ

Fpは位数`p`の有限体で、要素は0から`p-1`の整数(両端を含む)で表される。

Fp2は`Fp[X]/(X^2-nr2)`で定義され、要素は`el = c0 + c1 * v`の形式で表される。ここで`v`は`nr2`の平方根を表す形式的な変数で、`(c0,c1)`の整数ペアで表される。

G1は、`(x,y)`が曲線Fp方程式を満たすか`(x,y)=(0,0)`である点の集合として定義される。

G2は、`(x',y')`が曲線Fp2方程式を満たすか`(x',y')=(0,0)`である点の集合として定義される。

### 詳細と基本要素のエンコーディング

#### 体要素のエンコーディング:

演算の入力を生成するために、基礎体と拡大体の要素をエンコーディングする必要がある。

基礎体(Fp)の要素は、対応する(符号なし)整数のビッグエンディアン符号化により64バイトでエンコーディングされる。`p`のサイズにより、上位16バイトはすべて0となる。64バイトを選択したのは、32バイトアラインのABI(例えば`bytes32[2]`や`uint256[2]`で表現可能。後者の場合はビッグエンディアンエンコーディングを前提とする)を表現できるようにするためである。対応する整数は**必ず**体のモジュラスより小さくなければならない。

2次拡大体(Fp2)の要素については、係数の個別エンコーディングを連結したものが128バイトのエンコーディングとなる。Fp2の要素が`el = c0 + c1 * v`の形式で表される場合(ここで`v`は2次非剰余元の平方根を表す形式的な変数)、対応するバイトエンコーディングは`encode(c0) || encode(c1)`となる(ここで`||`はバイト連結を意味する。Solidityの型では`bytes32[4]`や`uint256[4]`で表現できる)。

*上位16バイトが0であることについての注意*: エンコーディングされた要素が"体の中にある"、つまり厳密に`< モジュラス`であることが要求される。ビッグエンディアンエンコーディングでは、モジュラスが381ビットしかない場合、自動的に上位16バイトが0になる。これは**必ず**チェックされなければならない。入力データの一部スライスのみを実際のデコーディングに使用する場合でも同様である。

体要素の有効なエンコーディングではない入力に対しては、プリコンパイルは**必ず**エラーを返さなければならない。

#### G1/G2の点のエンコーディング:

G1とG2の点は、それぞれの`x`と`y`座標のエンコーディングを連結したものとして表される。G1の点の全体エンコーディング長は128バイト、G2の点は256バイトである。

#### 無限遠点のエンコーディング:

"ゼロ点"とも呼ばれる。BLS12曲線では、座標が`(0, 0)`(Fpまたはfp2の0)の点は曲線上にはないため、128バイトまたは256バイトの0バイト列(素朴にはこれがデコードされて`(0, 0)`となる)が、G1およびG2の無限遠点を表すのに使用される。

#### 乗算演算のスカラーのエンコーディング:

乗算演算のスカラーは、対応する(符号なし)整数のビッグエンディアンエンコーディングにより32バイトでエンコーディングされる。対応する整数は**必ずしも**主部分群の位数`q`以下である必要はない。

#### 空の入力に対する動作:

一部の演算には可変長の入力(MSMでは`(点, スカラー)`のペアのリスト、ペアリングでは`(G1, G2)`点のリスト)があるが、これらの演算は空の入力に対しても定義されている(算術的には)。しかし、このEIPではこのような使用例を推奨しておらず、入力が空の場合はエラーを返さなければならない。

### 演算のABI

#### G1加算のABI

G1加算呼び出しでは、128バイトずつの2つのG1点のバイト連結256バイトを入力として受け取る。出力は加算演算の結果 - 単一のG1点(128バイト)のエンコーディングである。

エラーケース:

- 座標エンコーディングが無効
- 入力がG1楕円曲線上の点でも無限遠点でもない
- 入力長が無効

注意:

G1加算プリコンパイルでは部分群チェックは行わない。

#### G1乗算のABI

G1乗算呼び出しでは、128バイトのG1点のエンコーディングと32バイトのスカラー値のエンコーディングの連結160バイトを入力として受け取る。出力は乗算演算の結果 - 単一のG1点(128バイト)のエンコーディングである。

エラーケース:

- 座標エンコーディングが無効
- 入力がG1楕円曲線上の点でも無限遠点でもない
- 入力がG1楕円曲線上にあるが正しい部分群に属していない
- 入力長が無効

#### G1 MSMのABI

G1 MSM呼び出しでは、160*k(kは**正の**整数)バイトの入力を受け取る。これは、128バイトのG1点のエンコーディングと32バイトのスカラー値のエンコーディングの連結が`k`個並んだものと解釈される。出力はMSM演算の結果 - 単一のG1点(128バイト)のエンコーディングである。

エラーケース:

- 座標エンコーディングが無効
- 入力がG1楕円曲線上の点でも無限遠点でもない
- 入力がG1楕円曲線上にあるが正しい部分群に属していない
- 入力長が無効

#### G2加算のABI

G2加算呼び出しでは、256バイトずつの2つのG2点のバイト連結512バイトを入力として受け取る。出力は加算演算の結果 - 単一のG2点(256バイト)のエンコーディングである。

エラーケース:

- 座標エンコーディングが無効
- 入力がG2楕円曲線上の点でも無限遠点でもない
- 入力長が無効

注意:

G2加算プリコンパイルでは部分群チェックは行わない。

#### G2乗算のABI

G2乗算呼び出しでは、256バイトのG2点のエンコーディングと32バイトのスカラー値のエンコーディングの連結288バイトを入力として受け取る。出力は乗算演算の結果 - 単一のG2点(256バイト)のエンコーディングである。

エラーケース:

- 座標エンコーディングが無効
- 入力がG2楕円曲線上の点でも無限遠点でもない
- 入力がG2楕円曲線上にあるが正しい部分群に属していない
- 入力長が無効

#### G2 MSMのABI

G2 MSM呼び出しでは、288*k(kは**正の**整数)バイトの入力を受け取る。これは、256バイトのG2点のエンコーディングと32バイトのスカラー値のエンコーディングの連結が`k`個並んだものと解釈される。出力はMSM演算の結果 - 単一のG2点(256バイト)のエンコーディングである。

エラーケース:

- 座標エンコーディングが無効
- 入力がG2楕円曲線上の点でも無限遠点でもない
- 入力がG2楕円曲線上にあるが正しい部分群に属していない
- 入力長が無効

#### ペアリングチェックのABI

ペアリングチェック呼び出しでは、384*k(kは**正の**整数)バイトの入力を受け取る。これは、以下の構造の`k`個のスライスの連結と解釈される:

- G1点のエンコーディング128バイト
- G2点のエンコーディング256バイト

各点は位数`q`の部分群に属していることが期待される。

出力は32バイトで、最初の31バイトは`0x00`、最後の1バイトは、ペアリング結果がペアリング目標体の乗法単位元と等しい場合は`0x01`、そうでない場合は`0x00`となる。

エラーケース:

- 座標エンコーディングが無効
- 入力がそれぞれの楕円曲線上の点でも無限遠点でもない
- 入力がそれぞれの楕円曲線上にあるが正しい部分群に属していない
- 入力長が無効

注意:

入力が無限遠点の場合、ペアリング結果は1になる。プロトコルでは、プリコンパイルを呼び出す前に無限遠点をチェックし、拒否することを望むかもしれない。

#### Fp要素をG1点にマッピングするABI

体からカーブへのマッピング呼び出しでは、64バイトの入力を受け取り、それをFpの要素と解釈する。この呼び出しの出力は128バイトで、エンコーディングされたG1点である。

エラーケース:

- 入力長が無効
- 入力が正しくエンコーディングされていない

#### Fp2要素をG2点にマッピングするABI

体からカーブへのマッピング呼び出しでは、128バイトの入力を受け取り、それをFp2の要素と解釈する。この呼び出しの出力は256バイトで、エンコーディングされたG2点である。

エラーケース:

- 入力長が無効
- 入力が正しくエンコーディングされていない

### エラー時のガス消費

他のすべてのプリコンパイルの現在の状態に従い、このEIPのプリコンパイルの1つへの呼び出しがエラーになった場合、`CALL`または`STATICCALL`とともに供給されたすべてのガスが消費される。

### DDoS対策

このEIPの賢明な実装には**決して**無限ループの可能性がないはずであり(すべての機能をwhile ループなしで実装するのは可能で、それほど難しくもない)、ガススケジュールは対応する関数の計算時間を正確に反映している(プリコンパイルの価格設定は、そのような場合が存在する場合の最悪の場合のガス消費量を反映している)。

### ガススケジュール

30 MGas/秒を前提とすると、以下の価格が提案される。

#### G1加算

500ガス

#### G1乗算

12000ガス

#### G2加算

800ガス

#### G2乗算

45000ガス

#### G1/G2 MSM

MSMはPippenger's アルゴリズムで実行されることが期待される(また、ペアごとに乗算して結果を加算するナイーブな実装に比べて高速化するためには、Pippenger's アルゴリズムで実行**しなければならない**)。この場合、`k <= 128`点のMSMの場合の割引と、`k > 128`の場合の最大割引`max_discount`が用意されている。

整数演算を避けるため、呼び出しコストは`(k * 乗算コスト * 割引) / 乗数`として計算される。ここで`乗数 = 1000`、`k`は(スカラー、点)ペアの数、`乗算コスト`は対応するG1/G2の単一乗算呼び出しのコストである。

割引テーブルはペアのベクトル`[k, 割引]`として以下のようになる:

```
[[1, 1200], [2, 888], [3, 764], [4, 641], [5, 594], [6, 547], [7, 500], [8, 453], [9, 438], [10, 423], [11, 408], [12, 394], [13, 379], [14, 364], [15, 349], [16, 334], [17, 330], [18, 326], [19, 322], [20, 318], [21, 314], [22, 310], [23, 306], [24, 302], [25, 298], [26, 294], [27, 289], [28, 285], [29, 281], [30, 277], [31, 273], [32, 269], [33, 268], [34, 266], [35, 265], [36, 263], [37, 262], [38, 260], [39, 259], [40, 257], [41, 256], [42, 254], [43, 253], [44, 251], [45, 250], [46, 248], [47, 247], [48, 245], [49, 244], [50, 242], [51, 241], [52, 239], [53, 238], [54, 236], [55, 235], [56, 233], [57, 232], [58, 231], [59, 229], [60, 228], [61, 226], [62, 225], [63, 223], [64, 222], [65, 221], [66, 220], [67, 219], [68, 219], [69, 218], [70, 217], [71, 216], [72, 216], [73, 215], [74, 214], [75, 213], [76, 213], [77, 212], [78, 211], [79, 211], [80, 210], [81, 209], [82, 208], [83, 208], [84, 207], [85, 206], [86, 205], [87, 205], [88, 204], [89, 203], [90, 202], [91, 202], [92, 201], [93, 200], [94, 199], [95, 199], [96, 198], [97, 197], [98, 196], [99, 196], [100, 195], [101, 194], [102, 193], [103, 193], [104, 192], [105, 191], [106, 191], [107, 190], [108, 189], [109, 188], [110, 188], [111, 187], [112, 186], [113, 185], [114, 185], [115, 184], [116, 183], [117, 182], [118, 182], [119, 181], [120, 180], [121, 179], [122, 179], [123, 178], [124, 177], [125, 176], [126, 176], [127, 175], [128, 174]]
```

`max_discount = 174`

#### ペアリングチェック演算

ペアリングチェック演算のコストは`43000*k + 65000`で、`k`はペアの数である。

#### Fpからg1へのマッピング演算

Fp -> G1マッピングは5500ガス。

#### Fp2からG2へのマッピング演算

Fp2 -> G2マッピングは75000ガス。

#### 可変長入力のためのガススケジュールの明確化

MSMとペアリング関数では、入力長に応じてガスコストが変わる。主要クライアントの現在の実装(執筆時点)では、ガスコスト関数は入力長の検証を**行わず**、エラーを返さない。そのため、クライアント間の一貫性と安全性を確保するために、ガスコスト関数の実装方法について以下のルールを示す。

##### G1/G2 MSMのためのガススケジュールの明確化

定数`LEN_PER_PAIR`を定義する。G1の場合は160、G2の場合は288となる。対応するセクションのルールに従って`discount(k)`関数を定義する。ここで`k`はペアの数。

ガス計算の擬似関数は以下のようになる:

```
k = floor(len(input) / LEN_PER_PAIR);
if k == 0 {
  return 0;
}
gas_cost = k * 乗算コスト * discount(k) / 乗数;
return gas_cost;
```

ペアの数を床関数で取得する。入力長が`LEN_PER_PAIR`で割り切れない場合でも、何らかの結果を生成するが、後にプリコンパイルがエラーを返す。`k = 0`の場合も安全である:`CALL`または`STATICCALL`コストは0ではなく、`Blake2f`プリコンパイルでも形式的な0ガスコストが使用されている。いずれにしろ、エンコーディングルールに違反した入力に対しては、メインのプリコンパイル処理**必ず**エラーを返さなければならない。

##### ペアリングのためのガススケジュールの明確化

定数`LEN_PER_PAIR = 384`を定義する。

ガス計算の擬似関数は以下のようになる:

```
k = floor(len(input) / LEN_PER_PAIR);
gas_cost = 43000*k + 65000;
return gas_cost;
```

ペアの数を床関数で取得する。入力長が`LEN_PER_PAIR`で割り切れない場合でも、何らかの結果を生成するが、後にプリコンパイルがエラーを返す(エンコーディングルールに違反した入力に対しては、メインのプリコンパイル処理**必ず**エラーを返さなければならない)。

## 根拠

動機の節では、BLS12-381曲線上の演算を利用可能にする全体的な動機が述べられている。より具体的な詳細についても根拠を示す。

### 別個のMSM呼び出し

MSMの明示的な個別呼び出しにより、使用するアルゴリズム(具体的にはPippenger's アルゴリズム)による実行時間(ガス)の節約と、Ethereumの`CALL`操作が高コストであるという事実(執筆時点)による節約(例えば100点のMSMを個別の乗算呼び出し100回と加算呼び出し99回で行うよりも、約138600ガス節約できる)が可能になる。

## 後方互換性

後方互換性の問題はない。

### 部分群チェック

スカラー乗算、MSM、ペアリングでは**必ず**部分群チェックを行わなければならない。
実装では、専用の[文書](../assets/eip-2537/fast_subgroup_checks.
md)に詳述された最適化された部分群チェック方法を使用すべきである。
部分群チェックに失敗した入力に対しては、プリコンパイルは**必ず**エラーを返さなければならない。
エンドモルフィズムの高速化には正しい部分群の入力が必要なため、実装者はエンドモルフィズムの高速化を使用してもよい。

### 体からカーブへのマッピング

SWUマッピング手法のアルゴリズムとパラメータセットは、別の[文書](../assets/eip-2537/field_to_curve.md)で提供されている。

## テストケース

膨大なテストパラメータ空間のため、まず各種演算が満たすべき性質を示す。点演算には加法記法を使い、点には大文字(`P`, `Q`)、スカラーには小文字(`a`, `b`)を使う。G1のジェネレータは`G`、G2のジェネレータは`H`、それ以外は曲線上のランダムな点とする。`0`はスカラーゼロまたは無限遠点、`1`はスカラー1または乗法単位元を意味する。`group_order`は主部分群の位数。`e(P, Q)`はPがG1、Qがg2の点のペアリング演算を表す。

基本演算(加算/乗算)に必要な性質:

- 可換性: `P + Q = Q + P`
- 単位元: `P + 0 = P`
- 加法逆元: `P + (-P) = 0`
- 倍加: `P + P = 2*P`
- 部分群チェック: `group_order * P = 0`
- 単純な乗算チェック: `1 * P = P`
- ゼロによる乗算: `0 * P = 0`
- 正規化されていないスカラーによる乗算: `(scalar + group_order) * P = scalar * P`

ペアリング演算に必要な性質:

- 双線形性: `e(a*P, b*Q) = e(a*b*P, Q) = e(P, a*b*Q)`
- 非退化性: `e(P, Q) != 1`
- `e(P, 0*Q) = e(0*P, Q) = 1`
- `e(P, -Q) = e(-P, Q)`

テストベクトルは[テストベクトルファイル](../assets/eip-2537/test-vectors.md)にある。

### ベンチマークテストケース

新しい実装のクイックベンチマーキングのためのテストベクトルは別の[ファイル](../assets/eip-2537/bench_vectors.md)にある。

## 参考実装

執筆時点で、完全に仕様に準拠した2つの実装がある:

- [EIP-196](./eip-196.md)のコードをベースにしたRust実装で、OpenEthereum用に統合されたもの
- Gethの現在のコードベースに特別に実装されたもの

## セキュリティ上の考慮事項

仕様を厳密に従えば、前のBN254プリコンパイルと比べて、セキュリティ上の問題や合意上の問題は排除できる。

重要なトピックは、実行された演算の"一定時間"特性である。このプリコンパイルは、すべての演算を一定時間アルゴリズムで実行する**必要はない**と明示的に述べている。

## 著作権

著作権およびその関連権利は[CC0](../LICENSE.md)で放棄されている。