---
original: cfd4105b56086ddfb652fc788fa9020a68df6d3d043cdb25ce80ee44140d5391
---

---
eip: 6888
title: EVMにおける数学チェック
description: EVMレベルでのアンダーフロー、オーバーフロー、ゼロ除算のチェック
author: Renan Rodrigues de Souza (@RenanSouza2)
discussions-to: https://ethereum-magicians.org/t/eip-math-checking/13846
status: 停滞
type: Standards Track
category: Core
created: 2023-04-16
---

## 概要

このEIPはEVM演算に多くのチェックを追加し、対応するフラグを取得してクリアするための新しいオペコードを追加します。チェックリストには、アンダーフロー、オーバーフロー、ゼロ除算が含まれます。

## 動機

スマートコントラクトプロジェクトにおける数学チェックの重要性は非常に明確です。これはOpenZeppelinライブラリにあり、その後Solidityのデフォルトの動作に組み込まれました。これをEVMレベルに導入することで、ガス効率と安全性を両立できます。

## 仕様

この文書の中の「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、「OPTIONAL」というキーワードは、RFC 2119およびRFC 8174に記載されているように解釈されるものとします。

`BLOCK_TIMESTAMP >= HARDFORK_TIMESTAMP`から開始します。

### 定数

|     定数            | 型        | 値           |
| ------------------- | --------- |:------------- |
| `INT_MIN`           | `int`     | -(2**255)     |
| `UINT_MAX`          | `uint`    | 2 ** 256      |

### フラグ

|     変数            | 型        | 初期値       |
| ------------------- | --------- |:------------- |
| `carry`             | `bool`    | false         |
| `overflow`          | `bool`    | false         |

2つの新しいフラグがEVMの状態に追加されます。符号なしエラー(`carry`)と符号付きエラー(`overflow`)です。これらのフラグのスコープはプログラムカウンターと同じです。各実行フレームにはそれぞれのフラグがあります。フレームの作成時にはフラグはクリアされ、呼び出し時に更新されます。

以降、`a`、`b`、`c`は演算の引数を、`res`は出力を表します。`c`は3つの入力を取る演算でのみ使用されます。

`carry`フラグは以下の場合に設定されなければなりません:

 - オペコードが`ADD`(`0x01`)で`res < a`の場合
 - オペコードが`MUL`(`0x02`)で`a != 0 ∧ res / a != b`の場合
 - オペコードが`SUB`(`0x03`)で`b > a`の場合
 - オペコードが`DIV`(`0x04`)または`MOD`(`0x06`)で`b == 0`の場合
 - オペコードが`ADDMOD`(`0x08`)で`c == 0 ∨ ((a + b) / UINT_MAX > c)`の場合
 - オペコードが`MULMOD`(`0x08`)で`c == 0 ∨ ((a * b) / UINT_MAX > c)`の場合
 - オペコードが`EXP`(`0x0A`)で理想的に`a ** b > UINT_MAX`の場合
 - オペコードが`SHL`(`0x1b`)で`res >> a != b`の場合

`overflow`フラグは以下の場合に設定されなければなりません:

 - オペコードが`SUB`(`0x03`)で`a != 0 ∧ sgn(a) != sgn(b) ∧ sgn(b) == sgn(res)`の場合
 - オペコードが`ADD`(`0x01`)で`a != 0 ∧ sgn(a) == sgn(b) ∧ sgn(a) != sgn(res)`の場合
 - オペコードが`MUL`(`0x02`)で`(a == -1 ∧ b == INT_MIN) ∨ (a == INT_MIN ∧ b == -1) ∨ (a != 0 ∧ (res / a != b))`(ここの`/`は`SDIV`を表す)の場合
 - オペコードが`SDIV`(`0x05`)または`SMOD`(`0x06`)で`b == 0 ∨ (a == INT_MIN ∧ b == -1)`の場合
 - オペコードが`SHL`(`0x1b`)で`res >> a != b`(ここの`>>`は`SAR`を表す)の場合

`sgn(num)`関数は数値の符号を返します。負、ゼロ、正のいずれかになります。

| 値 | ニーモニック | δ | α | 説明 |
|-------|----------|---|---|---------------------------------------------------------------------------------------|
| `JUMPC` | `0x5B` | 1 | 0 | プログラムカウンターを条件付きで変更する。
|||||```J_JUMPC = carry ? µ_s[0] : µ_pc + 1```
|||||```carry = overflow = false``` |
| `JUMPO` | `0x5C` | 1 | 0 | プログラムカウンターを条件付きで変更する。
|||||```J_JUMPO = ovewrflow ? µ_s[0] : µ_pc + 1```
|||||```carry = overflow = false``` |

### ガス

両方のインストラクションのガスコストは`G_high`、つまり`JUMPI`と同じです。

## 根拠

EVMはマイナスの数値に2の補数を使用しています。上記のオペコードは符号付きと符号なしの数値に応じて1つまたは2つのフラグをトリガーします。

各オペコードの説明された条件は、実装の容易さを念頭に置いて作られています。`EXP`は例外で、逆演算に基づいた簡潔なテストを提供するのが難しいため、ほとんどの実装が内部的に`MUL`を使用するため、`carry`フラグは`EXP`ではなく`MUL`から引き出すことができます。

`ADDMOD`と`MULMOD`での`UINT_MAX`による除算は、内部の512ビット表現の上位256ビットを表す別の方法です。

両方のフラグが同時にクリアされるのは、符号付きまたは符号なしの数値として扱われるコード間を遷移する際に使用されることが期待されるためです。

## 下位互換性

このEIPは新しいオペコードを導入し、EVMの動作を変更します。

## テストケース

TBD

## 参考実装

TBD

## セキュリティ上の考慮事項

これは新しいEVMの動作ですが、各コードがどのように対話するかを決めます。

## 著作権

著作権およびそれに関連する権利は[CC0](../LICENSE.md)により放棄されています。