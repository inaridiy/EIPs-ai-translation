---
original: 177b2040bf0376b1182eb5571c7fda7a41b6f594083fa816506d65cfcf2acc4a
---

---
eip: 2929
title: ステートアクセスオペコードのガスコスト増加
author: Vitalik Buterin (@vbuterin), Martin Swende (@holiman)
discussions-to: https://ethereum-magicians.org/t/eip-2929-gas-cost-increases-for-state-access-opcodes/4558
status: Final
type: Standards Track
category: Core
created: 2020-09-01
---

## 簡単な要約

トランザクション内で初めて使用される場合の `SLOAD`、`*CALL`、`BALANCE`、`EXT*`、および `SELFDESTRUCT` のガスコストを増加させます。

## 概要

`SLOAD` (`0x54`) のガスコストを2100に、`*CALL`オペコードファミリー (`0xf1`、`f2`、`f4`、`fA`)、`BALANCE` `0x31`、および `EXT*`オペコードファミリー (`0x3b`、`0x3c`、`0x3f`) のガスコストを2600に増加させます。(i) プリコンパイルと、(ii) 同じトランザクション内で既にアクセスされたアドレスとストレージスロットは除外され、ガスコストが減少します。さらに、これらのオペコードに固有の「事実上のストレージロード」が正しく価格付けされるよう、`SSTORE`メータリングと `SELFDESTRUCT` を改革します。

## 動機

一般的に、オペコードのガスコストの主な機能は、そのオペコードを処理するのに必要な時間の見積もりであり、ガスリミットがブロック処理に必要な時間の上限に対応することが目標です。しかし、ストレージアクセスオペコード (`SLOAD`、`*CALL`、`BALANCE`、`EXT*`オペコード) は、歴史的に過小評価されてきました。2016年の上海DoS攻撃では、最も深刻なクライアントのバグが修正された後も、攻撃者が多数のアカウントにアクセスまたは呼び出すトランザクションを単に送信することが、最も持続的に成功した戦略の1つでした。

ガスコストは緩和策として引き上げられましたが、最近の数値では十分ではありませんでした。[https://arxiv.org/pdf/1909.07220.pdf](https://arxiv.org/pdf/1909.07220.pdf)から引用すると:

> 自体は無害に見えるかもしれませんが、`EXTCODESIZE`はクライアントにコントラクトをディスク上で検索させ、I/O集約的なトランザクションになります。Ethereumの履歴を我々のハードウェアで再生すると、悪意のあるトランザクションの実行に20〜80秒かかりましたが、平均トランザクションは数ミリ秒でした。

この提案されたEIPでは、これらのオペコードのコストを約3倍に引き上げ、最悪のケースの処理時間を約7〜27秒に減らします。ストレージを直接読み取るようにクライアントを再設計するデータベースレイアウトの改善により、これはさらに減少しますが、これらの技術が完全に展開されるまでには時間がかかる可能性があり、そのような技術があっても、ストレージにアクセスするI/Oオーバーヘッドは依然として重要です。

このEIPのもう1つの副次的な利点は、[Ethereumの無状態証拠サイズ](https://ethereum-magicians.org/t/protocol-changes-to-bound-witness-size/3885)を許容可能なレベルにするために必要な作業の大部分を行うことです。[バイナリトライ](https://ethresear.ch/t/binary-trie-format/7621)への切り替えを前提とすると、コードサイズを除く理論上の最大証拠サイズは、`(12500000ガスリミット) / (700ガス/BALANCE) * (800証拠バイト/BALANCE) ~= 14.3Mバイト`から`12500000 / 2600 * 800 ~= 3.85Mバイト`に減少します。コードアクセスの価格付けは、コードのマークル化が実装されたときに変更できます。

さらに将来的には、SNARK/STARK証拠の場合にも同様の利点があります。Starkwareの最近の数値によると、消費者デスクトップ上で秒あたり10000個のRescueハッシュを証明できるそうです。マークルブランチ当たり25ハッシュを仮定し、ブロック全体がステートアクセスで満たされていると、現在では`12500000 / 700 * 25 / 10000 ~= 44.64`秒かかりますが、このEIP後は`12500000 / 2500 * 25 / 10000 ~= 12.5`秒に減少し、単一のデスクトップコンピューターでも、あらゆる条件下で証拠を適時に生成できるようになります。STARKの証明性能の将来的な向上は、(i) より堅牢なハッシュ関数の使用、または(ii)証明時間のさらなる短縮に使用できます。これにより、そのような証拠に依存する無状態クライアントのユーザーエクスペリエンスが改善されます。

## 仕様

### パラメータ

| 定数 | 値 |
| - | - |
| `FORK_BLOCK` | 12244000 |
| `COLD_SLOAD_COST` | 2100 |
| `COLD_ACCOUNT_ACCESS_COST` | 2600 |
| `WARM_STORAGE_READ_COST` | 100 |

`block.number >= FORK_BLOCK`のブロックの場合、以下の変更が適用されます。

トランザクションの実行中、`accessed_addresses: Set[Address]`と`accessed_storage_keys: Set[Tuple[Address, Bytes32]]`を維持します。

これらのセットはトランザクションコンテキスト全体で実装され、自己破壊リストやグローバル`refund`カウンターなどの他のトランザクションスコープの構造と同様に扱われます。スコープが巻き戻された場合、アクセスリストはそのスコープに入る前の状態に戻されます。

トランザクションの実行が始まると、
  - `accessed_storage_keys`は空で初期化され、
  - `accessed_addresses`には以下が含まれるように初期化されます:
    - `tx.sender`、`tx.to`(またはコントラクト作成トランザクションの場合は作成されるアドレス)
    - すべてのプリコンパイルのセット

### ストレージ読み取りの変更

アドレスが(`EXTCODESIZE` (`0x3B`)、`EXTCODECOPY` (`0x3C`)、`EXTCODEHASH` (`0x3F`)、`BALANCE` (`0x31`)）オペコードのターゲットになるか、(`CALL` (`0xF1`)、`CALLCODE` (`0xF2`)、`DELEGATECALL` (`0xF4`)、`STATICCALL` (`0xFA`)）オペコードのターゲットになる場合、ガスコストは以下のように計算されます:

* ターゲットが`accessed_addresses`にない場合、`COLD_ACCOUNT_ACCESS_COST`ガスを請求し、アドレスを`accessed_addresses`に追加します。
* それ以外の場合、`WARM_STORAGE_READ_COST`ガスを請求します。

すべての場合において、ガスコストは請求され、マップは、オペコードが呼び出されるタイミングで更新されます。
`CREATE`または`CREATE2`オペコードが呼び出された場合、アドレスが未請求かどうかの確認を行う前に、直ちに(つまり、チェックを行う前に)作成されるアドレスを`accessed_addresses`に追加しますが、`CREATE`と`CREATE2`のガスコストは変更されません。
補足: `CREATE`/`CREATE2`の操作が後で失敗した場合(例えば`initcode`の実行中や、状態に保存するためのガスが不足している場合)、コントラクト自体のアドレスは`access_addresses`に残りますが(内部スコープで行われた追加は巻き戻されます)。

`SLOAD`の場合、`(address, storage_key)`ペア(ここで`address`はストレージが読み取られているコントラクトのアドレス)が`accessed_storage_keys`にまだない場合、`COLD_SLOAD_COST`ガスを請求し、そのペアを`accessed_storage_keys`に追加します。ペアがすでに`accessed_storage_keys`にある場合は、`WARM_STORAGE_READ_COST`ガスを請求します。

注: コール関数の場合、`100`/`2600`コストは即座に適用されます(つまり、呼び出しに使える`63/64`を計算する前と同様)。

注2: 'cold account'上で'cold sload read/write'を行う方法はありません。なぜなら、`slot`を読み書きするためには、すでに`account`の内部で実行されている必要があるためです。したがって、このEIPの時点では、cold ストレージの読み書きのcold accountに対する動作は未定義です。'remote read/write'を提案する将来のEIPでは、その変更の価格設定動作を定義する必要があります。

### SSTOREの変更

`SSTORE`を呼び出す際、`(address, storage_key)`ペアが`accessed_storage_keys`にあるかどうかを確認します。ない場合は、追加の`COLD_SLOAD_COST`ガスを請求し、そのペアを`accessed_storage_keys`に追加します。さらに、[EIP-2200](./eip-2200.md)で定義されたパラメータを以下のように変更します:

| パラメータ | 旧値 | 新値 |
| - | - | - |
| `SLOAD_GAS` | 800 | `= WARM_STORAGE_READ_COST` |
| `SSTORE_RESET_GAS` | 5000 | `5000 - COLD_SLOAD_COST` |

EIP 2200で定義された他のパラメータは変更されていません。
注: 定数`SLOAD_GAS`は、EIP 2200の複数の場所で使用されています(例: `SSTORE_SET_GAS - SLOAD_GAS`)。複合定義を使用する実装では、それらの定義も更新する必要があります。

### SELFDESTRUCTの変更

`SELFDESTRUCT`のETH受取人が`accessed_addresses`にない場合(送信額が0以外であるかどうかに関わらず)、既存のガスコストに加えて`COLD_ACCOUNT_ACCESS_COST`を請求し、ETH受取人をセットに追加します。

注: `SELFDESTRUCT`は、受取人が既にwarmの場合、`WARM_STORAGE_READ_COST`を請求しません。これは、他のコール関数とは異なる動作です。この理由は、変更を小さく抑えるためです。`SELFDESTRUCT`は既に`5K`コストがかかり、1回以上呼び出された場合はno-opです。

## 根拠

### オペコードコストvsウィットネスデータ1バイトあたりの課金

ガスコストを変更してウィットネスサイズを反映させる別の自然な方法は、ウィットネスデータ1バイトあたりの課金です。しかし、これを実装するには時間がかかり、短期的なセキュリティ対策という目標を阻害してしまいます。さらに、この方法を忠実に実行すると、コントラクトコードにアクセスするトランザクションに極端に高いガスコストがかかることになり、開発者にとって受け入れがたい負担となります。[コードのマークル化](https://medium.com/ewasm/evm-bytecode-merklization-2a8366ab0c90)が実装されるまで、個々のコードチャンクにアクセスするガスコストを適切に考慮するのは待つ方がよいでしょう。DoS防止の観点から短期的に見ると、24kBのディスクアクセスと32バイトのディスクアクセスの違いはそれほど大きくないため、コードサイズを気にする必要はありません。

### accessed_addresses / accessed_storage_keysセットの追加

既にアクセスされたアカウントとストレージスロットのセットを追加することで、キャッシュできるものを不必要に課金しないようにします。さらに、自己呼び出しやプリコンパイルの呼び出しが不当に高価になるという現在の望ましくない状況を解消し、ある将来の実行で期待されるガス量で実行できるよう、ある保存キーを事前にフェッチするコントラクト破壊の緩和策を可能にします。

### SSTOREガスコストの変更

SSTOREの変更は、ランダムに選択された0ストレージスロットを0から0に変更するDoS攻撃(800ガスのコストで、事実上のストレージロードが必要)を回避するために必要です。`SSTORE_RESET_GAS`の減少により、SSTORE全体のコスト(`COLD_SLOAD_COST`の支払いが必要)は変わりません。さらに、`
SLOAD`に続いて`SSTORE`(例: `storage_variable += x`)を行うアプリケーションは_実際に安くなる_ことに注意してください!

### SSTOREの会計処理を最小限に変更する

SSTOREのガスコストは、Wei Tangの元の/現在の/新しいアプローチを使い続けており、汚れたマップを使うようには設計されていません。これは、ストレージを変更する実際のコストを正しく計算するWei Tangのアプローチが、中間値ではなく現在値と最終値のみに関心があるためです。

### この提案の下で、平均的なアプリケーションのガス消費量はどのように増加するでしょうか?

#### ウィットネスサイズからの粗い分析

Alexey Akhunov氏の以前の[作業](https://medium.com/@akhounov/data-from-the-ethereum-stateless-prototype-8c69479c8abc)のデータを見ると、平均ブロックのウィットネスサイズは約1000kBで、そのうち約750kBがマークルプルーフで、コードではありません。1つのマークルブランチあたり2000バイトと保守的に仮定すると、ブロックあたり約375アクセスがあることを意味します(SLOADはバイト当たりのガス増加比がほぼ同じなので、別途分析する必要はありません)。

Etherscanのデータ[1日当たりのトランザクション数](https://etherscan.io/chart/tx)と[1日当たりのブロック数](https://etherscan.io/chart/blocks)から、1ブロックあたり約160トランザクションがあることがわかります(参照日: 7月1日)。これは、それらのアクセスの大部分が単に`tx.sender`と`tx.to`であり、ガスコスト増加の対象外であることを示唆していますが、重複アドレスのため320未満になる可能性があります。

したがって、これは1ブロックあたり50〜375の請求可能なアクセスを意味し、各アクセスは1900ガスの増加を被ります。`50 * 1900 = 95000`と`375 * 1900 = 712500`から、ガスリミットを1〜6%引き上げる必要があることがわかります。ただし、この分析は、(i)アカウント/ストレージキーが複数のトランザクションでアクセスされ、ウィットネスには1回しか現れないが、ガスコスト増加には2回現れる可能性、および(ii)同じトランザクション内で同じアカウント/ストレージキーが複数回アクセスされ、ガスコストが_減少_する可能性によって、さらに複雑化する可能性があります。

#### Goerli分析

より正確な分析は、Martin Swendeによってここで行われたGoerliトランザクションのスキャンから得られます: https://github.com/holiman/gasreprice

その結果、平均的にガスコストは約2.36%増加することがわかりました。ガスコストを大幅に_削減_する要因の1つは、多くのコントラクトが非効率的に同じストレージスロットを複数回読み取っているため、このEIPによってガスコストが10%以上削減される取引が多数あることです。

## 下位互換性

これらのガスコストの増加により、固定ガスコストに依存するコントラクトが破損する可能性があります。詳細とリスクが全体的に低いと予想される理由、およびさらなる低減が必要な場合の方法については、セキュリティ上の考慮事項のセクションを参照してください。

## テストケース

いくつかのテストケースはここにあります: https://gist.github.com/holiman/174548cad102096858583c6fbbb0649a

理想的には以下をテストする必要があります:

* 同じストレージスロットを{1、2、3}回SLOADする
* 同じアドレスを{1、2、3}回CALLする
* サブコールでSLOAD | CALLし、巻き戻し、同じ(ストレージスロット | アドレス)をSLOAD | CALLする
* サブコールし、SLOADし、再びサブコールし、内部サブコールを巻き戻し、同じストレージスロットをSLOADする
* 同じストレージスロットを{1、2、3}回SSTOREする。元の値と設定する値の組み合わせとして、0/非0をすべて使用する
* SSTOREしてから同じストレージスロットをSLOADする
* アドレスに`OP_1`してから`OP_2`する。ここで`OP_1`と`OP_2`は(`*CALL`、`EXT*`、`SELFDESTRUCT`)のすべての組み合わせ
* ガスが不足したり、ETHが不足したりして失敗するすべての可能性がある方法で、あるアドレスに`CALL`を試み、その後、正常に(`CALL` | `EXT*`)そのアドレスを呼び出す

## 実装

Gethの初期ドラフト実装は以下にあります: https://github.com/holiman/go-ethereum/tree/access_lists

## セキュリティ上の考慮事項

ガスコストを引き上げるEIPの場合、アプリケーションが破損する可能性がある3つのケースがあります:

1. コントラクトのサブコールに固定ガス制限がある場合
2. トランザクションのガスリミットに近い量を消費するコントラクトコールに依存しているアプリケーション
3. ETH転送呼び出しによってコーラーに与えられる2300ベースリミット

これらのリスクは、以前のガスコスト引き上げEIP、EIP-1884の文脈で既に研究されています。[Martin Swende氏の以前の報告書](https://github.com/holiman/eip-1884-security)と[Hubert Ritzdorf氏の分析](https://gist.github.com/ritzdorf/1c6bd72955391e831f8a397d3152b4e0/)を参照してください。(2)については、アプリケーションがほとんど常にトランザクションのガスリミット全体を使用しないこと、およびガスリミットが最近10百万から12.5百万に引き上げられたことから、リスクは非常に低いと論じることができます。EIP-1884は実際に、この理由でいくつかのコントラクトが破損したことが[報告されています](https://www.coindesk.com/ethereums-istanbul-upgrade-will-break-680-smart-contracts-on-aragon)。

これらのリスクを見る2つの方法があります。まず、開発者には今日までガスコスト引き上げの可能性について警告が出されていることを指摘できます。ストレージアクセスオペコードのガスコストの引き上げは[長い間議論されてきました](https://ethereum-magicians.org/t/protocol-changes-to-bound-witness-size/3885)。主要なdappの開発者にもそのような変更の可能性について複数回声明されています。したがって、EIP-1884よりもはるかにリスクが低いと主張できます。

### コントラクト破壊の緩和策

2つ目の見方は、緩和策を探ることです。まず、`accessed_addresses`と`accessed_storage_keys`マップの存在(このEIPにあり、EIP-1884にはない)により、いくつかのケースが回復可能になります。コントラクトAがアドレスBに資金を送る必要があり、アドレスBがあらゆる送信元からの資金を受け入れるが、ストレージ依存のログを残す場合、Bに別個の呼び出しを行ってキャッシュに引き込み、その後Aを呼び出すことで回復できます。これにより、Bの実行がAによって引き起こされた場合、SLOADあたり100ガスしか請求されません。これは全ての状況を修正するものではありませんが、リスクを大幅に軽減します。

さらに、この方式の使用性を拡張する方法もあります。1つの可能性は、アドレスとストレージキーを入力として受け取る`POKE`プリコンパイルを追加することです。これにより、トランザクションがアクセスするすべてのストレージスロットを事前に「突き刺す」ことで、取り残されたコントラクトを救済することができます。これは、アドレスがコントラクトからのみトランザクションを受け入れる場合でも機能し、他の多くのコンテキストでも機能します。EOA -> コントラクト -> コントラクトのようなケースでは機能しません。

別のオプションは[EIP-2930](./eip-2930.md)で、これは`POKE`と同様の効果がありますが、より一般的です。EOA -> コントラクト -> コントラクトのケースでも機能し、ガスコスト引き上げによる破損の知られているすべてのケースで機能するはずです。このオプションはより複雑ですが、アクセスリストがその他の用途(リジェネシス、アカウントアブストラクション、SSAなど)にも使用されるようになる道筋となります。

## 著作権
著作権およびそれに関連する権利は[CC0](../LICENSE.md)によって放棄されています。