---
original: dccef031ad1fb0588fa3a4bf8def2b527d733216f464598accf6ff5f2dc756d1
---

---
eip: 211
title: "新しいオペコード: RETURNDATASIZE と RETURNDATACOPY"
author: Christian Reitwiessner <chris@ethereum.org>
type: Standards Track
category: Core
status: Final
created: 2017-02-13
---

## 簡単な要約

EVM 内で任意の長さのデータを返すメカニズムが長らく要求されてきました。既存の提案はガス課金に関する複雑な問題を抱えていました。本提案は同じ問題を解決しつつ、非常にシンプルなガス課金メカニズムを持ち、呼び出しオペコードへの変更も最小限に抑えています。その動作は既存の呼び出しデータ (calldata) の扱いと非常に似ています。呼び出し後、返却データはバーチャルバッファに保持され、呼び出し側はそこからデータ (あるいはその一部) をメモリにコピーできます。次の呼び出しでバッファは上書きされます。このメカニズムは 100% 下位互換性を持っています。

## 概要

要約をご覧ください。

## 動機

ある状況では、呼び出し前にその長さを予測できないデータを返す必要があります。原則的にはEVMへの変更なしでこれを解決できますが、例えば呼び出しを2回に分けて最初の呼び出しでサイズを計算するなど、いくつかの状況では非常に高コストになります。最悪のケースの良い例は汎用的な転送コントラクトです。このコントラクトは呼び出しデータを受け取り、いくつかのチェックを行った後、そのままほかのコントラクトに転送します。返却データも同様に元の呼び出し側に転送されるべきです。コントラクトが汎用的で呼び出し先のコントラクトについて知らないため、出力サイズを事前に知る方法がありません。

コンパイラ実装者は、返却データのサイズが呼び出し前に不明な場合、ゼロ長のエリアを予約し、`RETURNDATACOPY` と `RETURNDATASIZE` を使ってデータを実際に取得することをお勧めします。

また、意図的な状態の巻き戻しを許可する提案 ([EIP-140](./eip-140.md)) をより有用にします。失敗データのサイズが通常の返却データよりも大きい、あるいは不明な可能性があるため、CALL オペコードが失敗を通知した後でも、失敗データを取得できるようになります。

## 仕様

`block.number >= BYZANTIUM_FORK_BLKNUM` の場合、2つの新しいオペコードを追加し、呼び出しフレームを生成するオペコード (CALL、CREATE、DELEGATECALL など) の意味を変更します。EVM (具体的には EVMの呼び出しフレーム) に可変サイズの新しい内部バッファ、返却データバッファが存在すると仮定します。このバッファは新しい呼び出しフレームごとに空で作成されます。呼び出しオペコードを実行すると、バッファはクリアされ (サイズがゼロに設定される)、呼び出しの完全な返却データ (あるいは失敗データ、[EIP-140](./eip-140.md) 参照) がバッファに格納され、サイズも更新されます。例外として、`CREATE` と `CREATE2` は成功時に空のバッファを、失敗時に失敗データを返します。呼び出しオペコードが実行されたが実際には呼び出しフレームを生成しない場合 (例えば、値の転送に資金が不足している、呼び出し先のコントラクトが存在しない場合)、返却データバッファは空になります。

最適化として、返却データバッファを呼び出しフレーム間で共有することができます。常に1つしか非空にならないためです。

`RETURNDATASIZE`: `0x3d`

返却データバッファのサイズをスタックにプッシュします。
ガスコスト: 2 (CALLDATASIZE と同じ)

`RETURNDATACOPY`: `0x3e`

このオペコードは `CALLDATACOPY` と似た意味を持ちますが、呼び出しデータの代わりに返却データバッファからデータをコピーします。さらに、返却データバッファのサイズを超えてアクセスすると失敗します。つまり、`start + length` がオーバーフローするか `RETURNDATASIZE` より大きくなる場合、現在の呼び出しはガス切れで停止します。特に、バッファの末尾から0バイト読み取ると0バイト返り、バッファの1バイト外から0バイト読み取ると例外が発生します。

ガスコスト: `3 + 3 * ceil(amount / 32)` (CALLDATACOPY と同じ)

## 根拠

動的データの返却を可能にする他の解決策も検討されましたが、いずれもガスを呼び出しオペコードから差し引く必要があり、実装と仕様が複雑でした ([5/8](https://github.com/ethereum/EIPs/issues/8))。本提案はコールデータの扱いと非常に似ているため、概念に良く適合します。さらに、eWASMアーキテクチャでも返却データを全く同じ方法で扱っています。

EVM実装では、次の呼び出しまたは現在の呼び出しの返却まで、返却データを保持する必要があります。このリソースは既に呼び出し先のメモリの一部としてコストが支払われているため、問題にはならないはずです。実装では、呼び出し先のメモリ全体を次の呼び出しまで保持するか、返却データのみを特別なメモリ領域にコピーするかを選択できます。

呼び出し先のメモリを次の呼び出しオペコードまで保持することで、ピークメモリ使用量が増加しません。呼び出しの後に発生するcaller のメモリ割り当ては、呼び出しの前に移動できるため、ガスコストは変わりません。ただし、ピーク割り当てには含まれることになります。

オペコードの番号は、`CALLDATASIZE` と `CALLDATACOPY` も含まれる同じニブルブロックから割り当てられています。

## 下位互換性

本提案は2つの新しいオペコードを導入しますが、それ以外は完全に下位互換性を持っています。

## テストケース

## 実装

## 著作権
[CC0](../LICENSE.md) によりすべての著作権およびそれに関連する権利が放棄されています。