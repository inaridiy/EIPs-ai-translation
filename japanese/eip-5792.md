---
original: 8145fe417e7b22b3d700c63100908c3ac190a759f3525cc8f69e02a0d97e315e
---

---
eip: 5792
title: ウォレットコールAPI
description: ユーザーのウォレットから複数のコールを送信し、そのステータスを確認するためのJSON-RPCメソッドを追加
author: Moody Salem (@moodysalem), Lukas Rosario (@lukasrosario), Wilson Cusack (@wilsoncusack), Dror Tirosh (@drortirosh), Jake Moxey (@jxom), Derek Rein (@arein)
discussions-to: https://ethereum-magicians.org/t/eip-5792-wallet-abstract-transaction-send-api/11374
status: レビュー
type: 標準トラック
category: インターフェース
created: 2022-10-17
---

## 要約

アプリがウォレットにオンチェーンの書き込みコールのバッチを処理するよう要求し、それらのコールのステータスを確認できるようにする新しいJSON-RPCメソッドを定義します。
アプリケーションは、これらのオンチェーンコールが、ウォレットによって以前に表明された特定の機能を利用して実行されるよう指定できます。さらに、アプリがウォレットにそれらの機能を問い合わせるための新しいウォレットRPCが定義されています。

## 動機

現在、ユーザーウォレットからトランザクションを送信し、そのステータスを確認するために使用されているメソッドは、`eth_sendTransaction`と`eth_getTransactionReceipt`です。

現在のメソッドは、現代の開発者の要求を満たしておらず、新しいトランザクション形式に対応できません。`eth_sendTransaction`という名前さえも、ノードがウォレットとして機能していた時代の遺物です。

今日、開発者は複数のコールを1つのRPCコールにバッチ処理して送信したいと考えており、多くのスマートアカウントはこれを1つのトランザクションで原子的に実行できます。開発者はまた、[ERC-4337](./eip-4337.md)トランザクションのペイマスターなど、新しいトランザクション形式によって提供される機能を利用したいと考えています。`eth_sendTransaction`はこれらのことを行う方法を提供していません。

新しい`wallet_` RPCセットに更新する際の主な目標は、ウォレットとアプリの関心事をクリーンに分離し、開発者がペイマスターやバッチトランザクションなどを利用できるようにし、より安全に発見可能な機能を最小限の調整で時間とともに追加するための明確な方法を作成することです。

## 仕様

4つの新しいJSON-RPCメソッドが追加されます：3つはオンチェーンコールのバッチを処理するためのもので、1つはウォレットの機能サポートを問い合わせるためのものです。これは、最初の3つのメソッドをより良く利用するためのものです。
アプリは、これらの最初の3つのメソッドをすぐに使用し始めることができ、利用できない場合は`eth_sendTransaction`と`eth_getTransactionReceipt`にフォールバックすることができます。

また、4番目のメソッドで使用するための1つの機能表現を定義します。これにより、ウォレットは最初の3つのメソッドで渡され管理されるコールの実行の原子性を約束することができます。

### `wallet_sendCalls`

ウォレットがコールのバッチを送信するよう要求します。`from`と`chainId`はトップレベルのプロパティであり、コールごとのプロパティではありません。これは、すべてのコールが同じ送信者から、同じチェーン上で送信されるべきだからです。チェーンは16進数表記で表現された[EIP-155](./eip-155.md)整数で識別されます。`calls`フィールドの項目は、すべてのトランザクションタイプで共有されているもののみです。ウォレットがトランザクションを送信するために必要な他のフィールドは、ウォレットによって処理されるべきです。

capabilitiesフィールドは、アプリがウォレットがサポートする機能についてウォレットと通信する方法です。例えば、これは[ERC-4337](./eip-4337.md)ウォレットがユーザーオペレーションの`paymasterAndData`入力を要求できるペイマスターサービスURLをアプリが指定できる場所です。

ウォレットは：

* リクエストで指定された順序でコールを送信しなければなりません（MUST）
* コールの`chainId`プロパティで識別される同じチェーン上でコールを送信しなければなりません（MUST）
* バッチを完了するためにコールが確定するのを待ってはいけません（MUST NOT）
* ユーザーがリクエストを拒否した場合、リクエストからのコールを送信してはいけません（MUST NOT）
* コールが失敗した場合、すべてのコールを元に戻すことができます（MAY）
* ウォレットの機能に応じて、1つまたは複数のトランザクションの一部としてすべてのコールを送信することができます（MAY）
* コールが失敗した場合、コールの実行を停止すべきです（SHOULD）
* fromアドレスが有効なアカウントと一致しない場合、リクエストを拒否することができます（MAY）
* バッチ内の1つ以上のコールが、順次シミュレートされた場合に失敗すると予想される場合、リクエストを拒否することができます（MAY）

#### `wallet_sendCalls` RPC仕様

```typescript
type SendCallsParams = {
  version: string;
  from: `0x${string}`;
  calls: {
    to?: `0x${string}` | undefined;
    data?: `0x${string}` | undefined;
    value?: `0x${string}` | undefined; // 16進数値
    chainId?: `0x${string}` | undefined; // 16進数チェーンID
  }[];
  capabilities?: Record<string, any> | undefined;
};

type SendCallsResult = string;
```

##### `wallet_sendCalls` パラメータ例

```json
[
  {
    "version": "1.0",
    "from": "0xd46e8dd67c5d32be8058bb8eb970870f07244567",
    "calls": [
      {
        "to": "0xd46e8dd67c5d32be8058bb8eb970870f07244567",
        "value": "0x9184e72a",
        "data": "0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675",
        "chainId": "0x01",
      },
      {
        "to": "0xd46e8dd67c5d32be8058bb8eb970870f07244567",
        "value": "0x182183",
        "data": "0xfbadbaf01",
        "chainId": "0x01",
      }
    ],
    "capabilities": {
      // 例示的
      "paymasterService": {
        "url": "https://..."
      }
    }
  }
]
```

##### `wallet_sendCalls` 戻り値例

識別子は任意の文字列です。唯一の要件は、与えられたセッションに対して、ユーザーがこの値で`wallet_getCallsStatus`を呼び出し、コールバッチのステータスが返されることを期待できることです。

```json
"0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331"
```

### `wallet_getCallsStatus`

`wallet_sendCalls`を介して送信されたコールバッチのステータスを返します。トランザクションの識別子は、`wallet_sendCalls` RPCから返された値です。このメソッドは、`eth_getTransactionReceipt`が返すフィールドのサブセットのみを返すことに注意してください。ウォレットの実装間で異なる可能性のあるフィールドは除外されます。

* ウォレットが複数のコールを原子的に実行しない場合（つまり、複数のトランザクションで）、`receipts`フィールドのレシートは送信されたコールの順序でなければなりません（MUST）。
* ウォレットが複数のコールを原子的に実行する場合（つまり、単一のトランザクションで）、`wallet_getCallsStatus`は単一のレシートを返さなければなりません（MUST）。これは、コールが含まれたトランザクションに対応します。
* レシートオブジェクトの`logs`は、`wallet_sendCalls`を使用して送信されたコールに関連するログのみを含まなければなりません（MUST）。例えば、[ERC-4337](./eip-4337.md)バンドラーによってオンチェーンで送信されたトランザクションの場合、ログには`wallet_sendCalls`を介して送信されたコールを使用して構築されたユーザーオペレーションに関連するもののみを含める必要があります。つまり、ログには同じバンドルで送信された他の無関係なユーザーオペレーションのものを含めるべきではありません。

#### `wallet_getCallsStatus` RPC仕様

```typescript
type GetCallsParams = string;

type GetCallsResult = {
  status: 'PENDING' | 'CONFIRMED';
  receipts?: {
    logs: {
      address: `0x${string}`;
      data: `0x${string}`;
      topics: `0x${string}`[];
    }[];
    status: `0x${string}`; // 16進数1または0（成功または失敗）
    chainId: `0x${string}`;
    blockHash: `0x${string}`;
    blockNumber: `0x${string}`;
    gasUsed: `0x${string}`;
    transactionHash: `0x${string}`;
  }[];
};
```

##### `wallet_getCallsStatus` パラメータ例

`wallet_sendCalls`の戻り値と同様に、バッチ識別子は任意の文字列です。

```json
[
  "0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331"
]
```

##### `wallet_getCallsStatus` 戻り値例

```json
{
  "status": "CONFIRMED",
  "receipts": [
    {
      "logs": [
        {
          "address": "0xa922b54716264130634d6ff183747a8ead91a40b",
          "topics": [
            "0x5a2a90727cc9d000dd060b1132a5c977c9702bb3a52afe360c9c22f0e9451a68"
          ],
          "data": "0xabcd"
        }
      ],
      "status": "0x1",
      "chainId": "0x01",
      "blockHash": "0xf19bbafd9fd0124ec110b848e8de4ab4f62bf60c189524e54213285e7f540d4a",
      "blockNumber": "0xabcd",
      "gasUsed": "0xdef",
      "transactionHash": "0x9b7bb827c2e5e3c1a0a44dc53e573aa0b3af3bd1f9f5ed03071b100bb039eaff"
    }
  ]
}
```

### `wallet_showCallsStatus`

ウォレットに`wallet_sendCalls`で送信された特定のコールバンドルに関する情報を表示するよう要求します。このメソッドは何も返さないことに注意してください。

#### `wallet_showCallsStatus` RPC仕様

```typescript
type ShowCallsParams = string; // wallet_sendCallsによって返されたコールバンドル識別子
```

##### `wallet_showCallsStatus` パラメータ例

このメソッドは、`wallet_sendCalls`呼び出しによって返されたコールバンドル識別子を受け入れます。

```json
[
  "0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331"
]
```

### `wallet_getCapabilities`

このRPCは、アプリケーションがウォレットから機能（例：バッチトランザクション、ペイマスターコミュニケーション）を要求することを可能にします。これは、個別の発見と許可リクエストなしで行われます。機能の要求と機能の発見の違いについては、["プライバシーに関する考慮事項"セクション](#プライバシーに関する考慮事項)を参照してください。

このメソッドは、ユーザーがアプリケーションと要求されたアドレス間の接続をまだ承認していない場合、エラーを返すべきです（SHOULD）。

コミュニティが時間とともに別のERCで追加の機能の定義に合意することを期待しています。

ウォレットに直接機能を問い合わせる代わりに、または加えて、同じ機能オブジェクトがアウトオブバンドで公開される場合があります（MAY）。例えば、[CAIP-25](https://github.com/ChainAgnostic/CAIPs/blob/ad0cfebc45a4b8368628340bf22aefb2a5edcab7/CAIPs/caip-25.md)に準拠したウォレットプロバイダーインターフェースで永続化された`sessionProperty.capabilities`オブジェクト、または周知の場所（[EIP-6963](./eip-6963.md)の`
rdns`識別子から派生したURLなど）で公開される場合があります。
プロバイダーの抽象化は、より良いユーザーエクスペリエンスを促進するために、以前のリクエストから機能をキャッシュしたり、アウトオブバンドから注入したりすることもあります（MAY）。
これらの補足的な機能表現がライブのウォレットRPCレスポンスで表現された機能と矛盾する場合、後者の値を正規かつ現在の機能表現として扱うべきです（SHOULD）。

#### `wallet_getCapabilities` RPC仕様

機能はキー/値ペアで返され、キーは機能の名前を示し、値はその名前に対して定義された形状に準拠し、16進数表記で表現された関連する[EIP-155](./eip-155.md)の`chainId`をキーとするオブジェクトにネストされます。
機能はチェーンごとのオブジェクトにネストされています。これは、ウォレットが特定のセッションで承認された複数のチェーンにわたって異なる機能をサポートする可能性があるためです。

```typescript
type GetCapabilitiesParams = [`0x${string}`]; // ウォレットアドレス

type GetCapabilitiesResult = Record<`0x${string}`, <Record<string, any>>; // 16進数チェーンID
```

##### `wallet_getCapabilities` パラメータ例

```json
["0xd46e8dd67c5d32be8058bb8eb970870f07244567"]
```

##### `wallet_getCapabilities` 戻り値例

以下の機能は例示的なものです。

```json
{
  "0x2105": {
    "paymasterService": {
      "supported": true
    },
    "sessionKeys": {
      "supported": true
    }
  },
  "0x14A34": {
    "paymasterService": {
      "supported": true
    }
  }
}
```

### `atomicBatch` 機能

上記の例示的な例や将来のEIPで定義される他の機能と同様に、上記で定義されたメソッドを介して配信されたコールを単一のトランザクションで実行する機能は、ウォレットによってブール形式で証明できます。

この機能は各チェーンで個別に表現され、そのチェーン上のトランザクションのバッチに対してのみ保証として解釈されるべきです。複数のチェーンへのコールを含むバッチは、この機能とこの仕様の範囲外です。

ウォレットが呼び出しアプリケーションにこの`atomicBatch`機能を明示的に表明している場合、`wallet_sendCalls`で送信されたコールを単一のトランザクションの一部として送信しなければなりません（MUST）。

#### `atomicBatch` 機能仕様

```typescript
type AtomicBatchCapability = {
  supported: true;
};
```

この機能の唯一のメンバーである`supported`の有効なJSON-RPC値は`true`または`false`のみです。`supported`の返された値が文字列または数値として型付けされている場合、不正な形式と見なすべきです（SHOULD）。

ウォレットが複数のコールを原子的に送信できる各チェーンに対して、ウォレットは`supported`フィールドが`true`に等しい`atomicBatch`機能を含めるべきです（SHOULD）。

#### `atomicBatch`を含む`wallet_getCapabilities`戻り値例

```json
{
  "0x2105": {
    "atomicBatch": {
      "supported": true
    },
  },
  "0x14A34": {
    "atomicBatch": {
      "supported": true
    }
  }
}
```

## 根拠

### 命名について

これらの新しい機能をサポートするために`eth_sendTransaction`を変更することを検討しましたが、このメソッドは最終的にノードがウォレットとして使用されていた時代の遺物です。`wallet_`名前空間のメソッドに移行し、その用途をより適切に説明することが良いと判断しました。

また、メソッドを`wallet_sendTransaction`、`wallet_sendCalls`、または他の名前にするかどうかについても議論しました。最終的に`wallet_sendCalls`に落ち着いたのは、EOAウォレットの場合、`wallet_send*`メソッドが複数のトランザクションを送信する可能性があるためです。同様に、`wallet_sendTransactions`に反対したのは、他のウォレット実装（例：[ERC-4337](./eip-4337.md)）の場合、複数のコールが1つのトランザクションになる可能性があるためです。

### コール実行の原子性

`wallet_sendCalls`メソッドは`calls`の配列を受け入れます。しかし、この提案はこれらのコールが単一のトランザクションの一部として実行されることを要求していません。これにより、EOAウォレットも同じインターフェースを介して複数のコールを受け入れることができます。とはいえ、場合によってはアプリ開発者が、コールが原子的に実行される場合にのみバッチ処理されたコールを送信したいと考えることが予想されます。これにより、アプリ開発者が処理する必要のあるエラーケースの数が減少し、同時にウォレットタイプ間のインターフェースの統一に時間とともに貢献します。

当初は、複数のコールが原子的に実行されなければならないと提案しましたが、議論の末、これは過度に意見的であると判断しました。代わりに、`atomicBatch`機能の仕様を含めることにしました。これにより、EOAウォレットが複数のコールを受け入れることができ、開発者にもコールが原子的に実行される場合にのみバッチ処理されたコールを送信するオプションが与えられます。

### コールのガス制限

当初の提案では、`walletSendCalls`メソッドが受け入れる`calls`フィールドの各コールにオプションの`gas`フィールドを含めていました。しかし、[ERC-4337](./eip-4337.md)ウォレットの場合、コールごとにガス制限を指定することはできず、ユーザーオペレーションのすべてのコールに対して単一のガス制限しか指定できないため、これは誤解を招く可能性があることに気づきました。そこで、すべてのコールに適用される単一の`gas`値を提案しました。これは[ERC-4337](./eip-4337.md)ウォレットには機能しますが、EOAウォレットには機能しません。EOAウォレットが複数のコールを処理できるべきだと決定したとき、共通の`gas`フィールドはユースケース間で維持できなくなり、完全に削除しました。

## 後方互換性

ここで定義されたメソッドをサポートしないウォレットは、これらの新しいJSON-RPCメソッドが呼び出されたときにエラーレスポンスを返すべきです（SHOULD）。アプリは、これらのメソッドの呼び出しがウォレットのサポート不足で失敗した場合、同じコールのバッチを`eth_sendTransaction`を介して順次送信しようとすることができます（MAY）。または、ユーザーにウォレットがサポートされていないことと、リクエストが処理されなかったことを示すこともできます（MAY）。

## セキュリティに関する考慮事項

アプリ開発者は、バッチ内の各コールを独立したトランザクションであるかのように扱わなければなりません（MUST）。言い換えれば、バッチ内の任意のコール間に追加の信頼されないトランザクションがある可能性があります。バッチ内のコールは、別々の非連続なブロックに含まれる可能性もあります（MAY）。バッチ内のすべてのコールが含まれるまでにかかる時間に制約はありません。アプリは、今日のトランザクションと同様に、バンドルされたものも含めて、スマートコントラクトのコールにデッドラインとタイムアウト動作をエンコードしなければなりません（MUST）。ウォレットが機能宣言を通じてバッチ処理されたコールを原子的に送信できることをアプリケーションに明示的に示していない限り、アプリ開発者はすべてのコールが単一のトランザクションで送信されると仮定してはいけません（MUST NOT）。

### プライバシーに関する考慮事項

段階的な承認と段階的な同意のパラダイムは、現代のユーザーエクスペリエンスにとって重要であり、ユーザーエージェントの匿名性を保護するためにも重要です。これらのパターンを、より良いユーザーエクスペリエンスを可能にする機能発見のクロスインセンティブから保護するために、機能セマンティクスが使用され、機能サポートの欠如と機能許可の欠如の違いが、機能を問い合わせるための`wallet_` RPCの設計で明示的に隠蔽されています。

さらに、ウォレットは信頼されていない呼び出し元や必要以上の呼び出し元に機能を公開することを避けることが推奨されます。これは、「ユーザーエージェント」（つまりクライアントソフトウェア）が「フィンガープリント」を取られたり、確率的に識別されたりする可能性があるためです。これは、Webプラットフォームに固有の他の匿名化解除ベクトルと組み合わせると、個々のユーザーの匿名化解除や、特定のクライアントのすべてのユーザーの集計的な匿名化解除につながる可能性があります。同様に、アプリケーションが機能を過剰に問い合わせたり、機能の過剰共有（サードパーティの機能の過剰共有を含む）を奨励したりすることは、機能を発見するための機能交換の実装において避けるべきアンチパターンです。

## 著作権

Copyright and related rights waived via [CC0](../LICENSE.md).