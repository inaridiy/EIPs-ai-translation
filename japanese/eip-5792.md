---
original: ef2bfd3951967555276d75e8af3a8206a278c27601745823376d9a24374d3758
---

---
eip: 5792
title: ウォレット呼び出しAPI
description: ユーザーのウォレットから複数の呼び出しを送信し、その状態を確認するためのJSON-RPCメソッドを追加する
author: Moody Salem (@moodysalem)、Lukas Rosario (@lukasrosario)、Wilson Cusack (@wilsoncusack)、Dror Tirosh (@drortirosh)、Jake Moxey (@jxom)、Derek Rein (@arein)
discussions-to: https://ethereum-magicians.org/t/eip-5792-wallet-abstract-transaction-send-api/11374
status: レビュー
type: Standards Track
category: Interface
created: 2022-10-17
---

## 概要

アプリがウォレットに一連のオンチェーンの書き込み呼び出しを処理させ、それらの呼び出しの状態を確認できるようにする新しいJSON-RPCメソッドを定義します。
アプリは、ウォレットが以前に表明した特定の機能を利用して、これらのオンチェーンの呼び出しを実行することを指定できます。また、アプリがウォレットの機能を問い合わせるための新しいウォレットRPCも定義されています。

## 動機

現在使用されている`eth_sendTransaction`と`eth_getTransactionReceipt`メソッドでは、ユーザーのウォレットから取引を送信し、その状態を確認することはできません。

現在使用されている`eth_sendTransaction`と`eth_getTransactionReceipt`メソッドは、現代の開発者のニーズを満たしておらず、新しい取引形式に対応できません。メソッド名自体も--`eth_sendTransaction`--は、ノードがウォレットとして機能していた時代の名残です。

今日の開発者は、単一のRPCコールでまとめて複数の呼び出しを送信したいと考えています。多くのスマートアカウントはこれらの呼び出しを1つの取引として原子的に実行できます。開発者はまた、[ERC-4337](./eip-4337.md)取引のペイマスターなど、新しい取引形式の機能を活用したいと考えています。`eth_sendTransaction`にはこれらを行う方法がありません。

新しい`wallet_`RPCセットに移行することで、ウォレットとアプリの関心事を明確に分離し、ペイマスターやバッチ取引の使用を可能にし、徐々に新しい機能を安全に追加する明確な方法を作ることが主な目的です。

## 仕様

4つの新しいJSON-RPCメソッドが追加されます。3つはオンチェーンの呼び出しのバッチ処理用で、1つはウォレットの機能を問い合わせるためのものです。
アプリは、これらの最初の3つのメソッドを即座に使い始めることができ、使用できない場合は`eth_sendTransaction`と`eth_getTransactionReceipt`にフォールバックすることができます。

また、4番目のメソッドで使用するための機能表現を1つ定義しています。これにより、最初の3つのメソッドで渡された呼び出しの実行の原子性を約束することができます。

### `wallet_sendCalls`

ウォレットにコールのバッチを送信するよう要求します。`from`と`chainId`はコール単位のプロパティではなく、トップレベルのプロパティです。これは、すべての呼び出しが同じ送信者から同じチェーン上で送信される必要があるためです。[EIP-155](./eip-155.md)で定義された16進数表記のチェーンIDを使用します。`calls`フィールドの項目は、すべての取引タイプに共通のものだけです。取引を送信するためにウォレットが必要とする他のフィールドは、ウォレットが処理する必要があります。

`capabilities`フィールドは、アプリがウォレットの機能について通信する方法です。例えば、ここでアプリは[ERC-4337](./eip-4337.md)ウォレットが`paymasterAndData`入力を要求できるペイマスターサービスのURLを指定できます。

ウォレットは:

* リクエストの順序どおりにこれらの呼び出しを送信しなければならない
* リクエストの`chainId`プロパティで識別されるチェーン上で呼び出しを送信しなければならない
* ユーザーがリクエストを拒否した場合、リクエストの呼び出しを一切送信してはならない
* 呼び出しが失敗した場合、すべての呼び出しを巻き戻すことができる
* 1つの取引または複数の取引の一部として、すべての関数呼び出しを送信することができる(ウォレットの機能による)
* 呼び出しが失敗した場合、呼び出しの実行を停止すべきである
* リクエストのチェーンIDが現在選択されているチェーンIDと一致しない場合、リクエストを拒否することができる
* リクエストの`from`アドレスが有効なアカウントと一致しない場合、リクエストを拒否することができる
* バッチ内の1つ以上の呼び出しが順次シミュレートされた場合に失敗すると予想される場合、リクエストを拒否することができる

#### `wallet_sendCalls` RPC仕様

```typescript
type SendCallsParams = {
  version: string;
  chainId: `0x${string}`; // 16進数のチェーンID
  from: `0x${string}`;
  calls: {
    to?: `0x${string}` | undefined;
    data?: `0x${string}` | undefined;
    value?: `0x${string}` | undefined; // 16進数の値
  }[];
  capabilities?: Record<string, any> | undefined;
};

type SendCallsResult = string;
```

##### `wallet_sendCalls` パラメーター例

```json
[
  {
    "version": "1.0",
    "chainId": "0x01",
    "from": "0xd46e8dd67c5d32be8058bb8eb970870f07244567",
    "calls": [
      {
        "to": "0xd46e8dd67c5d32be8058bb8eb970870f07244567",
        "value": "0x9184e72a",
        "data": "0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675"
      },
      {
        "to": "0xd46e8dd67c5d32be8058bb8eb970870f07244567",
        "value": "0x182183",
        "data": "0xfbadbaf01"
      }
    ],
    "capabilities": {
      // 例示的
      "paymasterService": {
        "url": "https://..."
      }
    }
  }
]
```

##### `wallet_sendCalls` 戻り値例

識別子は任意の文字列でかまいません。ユーザーが`wallet_getCallsStatus`でこの値を使ってコールバッチの状態を取得できることが重要です。

```json
"0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331"
```

### `wallet_getCallsStatus`

`wallet_sendCalls`で送信されたコールバッチの状態を返します。取引の識別子は`wallet_sendCalls`RPCから返された値です。このメソッドは、ウォレットの実装によって異なる可能性のあるフィールドを除いて、`eth_getTransactionReceipt`が返すフィールドのサブセットのみを返します。

* ウォレットが複数の呼び出しを原子的に(つまり複数の取引で)実行しない場合、`receipts`フィールドの領収書は送信された呼び出しの順序に従わなければならない。
* ウォレットが複数の呼び出しを原子的に(つまり1つの取引で)実行する場合、`wallet_getCallsStatus`は1つの領収書を返さなければならない。それは呼び出しが含まれていた取引に対応するものです。
* 領収書オブジェクトの`logs`には、`wallet_sendCalls`で送信された呼び出しに関連するログのみを含める必要があります。例えば、[ERC-4337](./eip-4337.md)バンドラーによってオンチェーンで送信された取引の場合、ログにはユーザーオペレーションに関連するものだけを含める必要があります。つまり、同じバンドルに含まれる他の関連のないユーザーオペレーションのログは含めるべきではありません。

#### `wallet_getCallsStatus` RPC仕様

```typescript
type GetCallsParams = string;

type GetCallsResult = {
  status: 'PENDING' | 'CONFIRMED';
  receipts?: {
    logs: {
      address: `0x${string}`;
      data: `0x${string}`;
      topics: `0x${string}`[];
    }[];
    status: `0x${string}`; // 16進数の1または0で成功または失敗を表す
    blockHash: `0x${string}`;
    blockNumber: `0x${string}`;
    gasUsed: `0x${string}`;
    transactionHash: `0x${string}`;
  }[];
};
```

##### `wallet_getCallsStatus` パラメーター例

`wallet_sendCalls`の戻り値と同様、バッチ識別子は任意の文字列でかまいません。

```json
[
  "0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331"
]
```

##### `wallet_getCallsStatus` 戻り値例

```json
{
  "status": "CONFIRMED",
  "receipts": [
    {
      "logs": [
        {
          "address": "0xa922b54716264130634d6ff183747a8ead91a40b",
          "topics": [
            "0x5a2a90727cc9d000dd060b1132a5c977c9702bb3a52afe360c9c22f0e9451a68"
          ],
          "data": "0xabcd"
        }
      ],
      "status": "0x1",
      "blockHash": "0xf19bbafd9fd0124ec110b848e8de4ab4f62bf60c189524e54213285e7f540d4a",
      "blockNumber": "0xabcd",
      "gasUsed": "0xdef",
      "transactionHash": "0x9b7bb827c2e5e3c1a0a44dc53e573aa0b3af3bd1f9f5ed03071b100bb039eaff"
    }
  ]
}
```

### `wallet_showCallsStatus`

`wallet_sendCalls`で送信されたコールバンドルの情報を表示するよう要求します。このメソッドは何も返しません。

#### `wallet_showCallsStatus` RPC仕様

```typescript
type ShowCallsParams = string; // wallet_sendCallsで返された呼び出しバンドル識別子
```

##### `wallet_showCallsStatus` パラメーター例

このメソッドは、`wallet_sendCalls`呼び出しによって返されたコールバンドル識別子を受け取ります。

```json
[
  "0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331"
]
```

### `wallet_getCapabilities`

このRPCにより、アプリケーションはウォレットに機能(バッチ取引、ペイマスターとの通信など)を要求できます。これは、別個の発見とアクセス許可のリクエストを行わずに行えます。機能の要求と発見の違いについては、「プライバシーに関する考慮事項」セクションを参照してください。

このメソッドは、ユーザーがアプリケーションと要求されたアドレス間の接続を既に承認していない場合、エラーを返すべきです。

コミュニティが時間とともに別のERCで追加の機能の定義に合意することを期待しています。

アプリケーションが直接ウォレットに機能を問い合わせる代わりに、または追加で、同じ機能オブジェクトがアウトオブバンドで公開される可能性があることに注意してください。例えば、CAIP-25準拠のウォレットプロバイダインターフェイスの`sessionProperty.capabilities`オブジェクトに保存したり、[EIP-6963](./eip-6963.md)`rdns`識別子から派生したURLなどの既知の場所に公開したりすることができます。プロバイダの抽象化は、以前のリクエストから機能をキャッシュしたり、アウトオブバンドから注入したりして、よりよいユーザー体験を提供することもできます。
これらの補足的な機能表現のいずれかが、ライブのウォレットRPC応答で表現された機能と矛盾する場合、後者の値を正規の現在の機能表現として扱うべきです。

#### `wallet_getCapabilities` RPC仕様

機能はキー/値のペアで返され、キーは機能の名前を表し、値は該当する機能の定義に準拠します。これらは16進数表記の[EIP-155](./eip-155.md)`chainId`をキーとするオブジェクトにネストされます。
機能はチェーン単位でネストされているため、ウォレットは特定のセッションで承認された複数
のチェーンにわたって異なる機能をサポートできます。

```typescript
type GetCapabilitiesParams = [`0x${string}`]; // ウォレットアドレス

type GetCapabilitiesResult = Record<`0x${string}`, <Record<string, any>>; // 16進数のチェーンID
```

##### `wallet_getCapabilities` パラメーター例

```json
["0xd46e8dd67c5d32be8058bb8eb970870f07244567"]
```

##### `wallet_getCapabilities` 戻り値例

以下の機能は例示的なものです。

```json
{
  "0x2105": {
    "paymasterService": {
      "supported": true
    },
    "sessionKeys": {
      "supported": true
    }
  },
  "0x14A34": {
    "paymasterService": {
      "supported": true
    }
  }
}
```

### `atomicBatch` 機能

上記の例示的な例や今後のEIPで定義される他の機能と同様に、上記で定義されたメソッドで配信された呼び出しを1つの取引で実行する機能は、ブール値の形式でウォレットによって証明されることができます。

ウォレルが呼び出しアプリケーションにこの`atomicBatch`機能を明示的に表明している場合、`wallet_sendCalls`で送信された呼び出しを1つの取引の一部として送信しなければなりません。

#### `atomicBatch` 機能仕様

```typescript
type AtomicBatchCapability = {
  supported: true;
};
```

この機能の唯一のメンバー`supported`の有効なJSON-RPC値は`true`または`false`のみです。返された`supported`の値が文字列または数値としてタイプ付けされている場合、それは不正なものと見なされるべきです。

ウォレットが複数の呼び出しを原子的に送信できるチェーンごとに、ウォレットは`supported`フィールドが`true`に等しい`atomicBatch`機能を含める必要があります。

#### `wallet_getCapabilities` 例、`atomicBatch`を含む

```json
{
  "0x2105": {
    "atomicBatch": {
      "supported": true
    },
  },
  "0x14A34": {
    "atomicBatch": {
      "supported": true
    }
  }
}
```

## 根拠

### 命名について

`eth_sendTransaction`を変更してこれらの新しい機能をサポートすることを検討しましたが、このメソッドはノードがトランザクションに署名していた時代の名残です。ウォレットの目的をより良く説明する`wallet_`名前空間のメソッドに移行することが better だと判断しました。

`wallet_sendTransaction`、`wallet_sendCalls`、あるいは他の何かを呼ぶべきかについても議論しました。最終的に`wallet_sendCalls`に落ち着いたのは、EOAウォレットの場合、`wallet_send*`メソッドが複数の取引を送信する可能性があるためです。同様に、[ERC-4337](./eip-4337.md)などの他のウォレル実装の場合、複数の呼び出しが1つの取引になる可能性があるため、`wallet_sendTransactions`は適切ではないと判断しました。

### 呼び出しの実行の原子性

`wallet_sendCalls`メソッドは`calls`の配列を受け取りますが、この提案では、これらの呼び出しが単一の取引の一部として実行されることを要求していません。EOAウォレットも同じインターフェイスを使って複数の呼び出しを受け入れることができます。ただし、アプリ開発者が呼び出しがatomically実行される場合にのみバッチ呼び出しを送信したいと考えることが期待されます。これにより、アプリ開発者が処理する必要のあるエラーケースの数を減らすことができ、同時に、ウォレットタイプ間のインターフェイスの統一にも貢献します。

当初は複数の呼び出しを原子的に実行する必要があると提案しましたが、議論の末、これは過度に意見的であると判断しました。代わりに、`atomicBatch`機能の仕様を含めることにしました。これにより、EOAウォレットが複数の呼び出しを受け入れつつ、開発者がバッチ呼び出しを原子的に実行される場合にのみ送信するオプションを持つことができます。

### 呼び出しのガスリミット

当初の提案には、`wallet_sendCalls`メソッドの`calls`フィールドで各呼び出しに`gas`フィールドを含めるオプションがありました。しかし、[ERC-4337](./eip-4337.md)ウォレットの場合、呼び出しごとにガスリミットを指定することはできず、ユーザーオペレーション全体に単一のガスリミットしか指定できないことに気づきました。そこで、すべての呼び出しに適用される単一の`gas`値を提案しました。これは[ERC-4337](./eip-4337.md)ウォレットには適していますが、EOAウォレットには適していません。EOAウォレットも複数の呼び出しを処理できるようにすることを決めたとき、共通の`gas`フィールドはユースケース全体で成り立たなくなり、完全に削除することにしました。

## 下位互換性

これらの新しいJSON-RPCメソッドをサポートしないウォレットは、これらのメソッドが呼び出された場合にエラー応答を返す必要があります。アプリは、これらのメソッドの呼び出しが失敗した場合、`eth_sendTransaction`を使って同じバッチの呼び出しを逐次送信することができます。あるいは、ウォレットがサポートされていないことをユーザーに示し、リクエストが処理されなかったことを示すこともできます。

## セキュリティに関する考慮事項

アプリ開発者は、バッチ内の各呼び出しを、独立した取引として扱う必要があります。つまり、バッチ内の呼び出しの間に、信頼できない取引が含まれている可能性があります。バッチ内の呼び出しは、連続したブロックに含まれるとは限りません。バッチ内のすべての呼び出しが含まれるまでにかかる時間に制限はありません。アプリは、現在のトランザクションと同様に、期限と タイムアウトの動作をスマートコントラクトの呼び出しにエンコードする必要があります。ウォレットが明示的にアプリケーションに対して呼び出しのバッチを原子的に送信できることを示していない限り、アプリ開発者は全ての呼び出しが単一の取引で送信されると想定してはいけません。

### プライバシーに関する考慮事項

段階的な承認と段階的な同意のパラダイムは、現代のユーザー体験、およびユーザーエージェントの匿名性を維持するために重要です。これらのパターンを、より良いユーザー体験を可能にする機能発見のクロスインセンティブから保護するために、機能セマンティクスが使用され、機能サポートの欠如と機能アクセス許可の欠如の違いが、`wallet_`RPCの機能問い合わせの設計で明示的に隠蔽されています。

さらに、ウォレットは、信頼できない呼び出し元や必要以上の呼び出し元に機能を公開することを避けるべきです。これにより、その「ユーザーエージェント」(つまりクライアントソフトウェア)が「フィンガープリント」されたり、確率的に識別されたりする可能性があり、Webプラットフォームに固有の他の匿名性解除ベクトルと組み合わされると、個々のユーザーの匿名性の解除や、特定のクライアントを使用するすべてのユーザーの集合的な匿名性の解除につながる可能性があります。同様に、機能を過剰に問い合わせたり、機能の過剰な共有を奨励したりするアプリケーション(サードパーティの機能の過剰な共有を含む)は、機能交換の実装において避けるべきアンチパターンです。

## 著作権

著作権およびそれに関連する権利は[CC0](../LICENSE.md)で放棄されています。