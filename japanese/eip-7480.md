---
original: 6626d878f3707abfab2ce43b44ce2c5c78f961156ca6dcc93a437cf749c454f8
---

---
eip: 7480
title: EOF - データセクションアクセス命令
description: EOF コンテナのデータセクションを読み取るための命令
author: Andrei Maiboroda (@gumb0), Alex Beregszaszi (@axic), Paweł Bylica (@chfast)
discussions-to: https://ethereum-magicians.org/t/eip-7480-eof-data-instructions/15414
status: Review
type: Standards Track
category: Core
created: 2023-08-11
requires: 3540, 3670
---

## 概要

4つの新しい命令が導入されます。これらの命令により、EOF コンテナのデータセクションを読み取ることができます。`DATALOAD` は 32 バイトのワードをスタックにロードします。`DATALOADN` は静的な即値引数によってアドレス指定された 32 バイトのワードをスタックにロードします。`DATASIZE` はデータセクションのサイズをロードし、`DATACOPY` はデータセクションの一部をメモリにコピーします。

## 動機

コードとデータの明確な分離は、EOF1 の主要な機能の 1 つです。データセクションには、コンパイラのメタデータなどさまざまなものが含まれる可能性がありますが、スマートコントラクトで有用にするためには、EVM にデータセクションから読み取るための命令が必要です。以前から存在していたバイトコードの検査命令 (`CODECOPY`、`CODESIZE` など) は EOF1 では非推奨となり、この目的には使用できません。

`DATALOAD`、`DATASIZE`、`DATACOPY` の命令パターンは、他のデータ (リターンデータやコールデータ) の読み取りに使用されている既存の命令のデザインに従っています。

`DATALOADN` は `DATALOAD` の最適化版で、読み取るデータオフセットがコンパイル時に設定されるため、実行時に検証する必要がなく、より安価な命令になります。

## 仕様

[EIP-3540](./eip-3540.md) が有効になるのと同じブロック番号で、4つの新しい命令を導入します:

1. `DATALOAD` (0xd0)
2. `DATALOADN` (0xd1)
3. `DATASIZE` (0xd2)
4. `DATACOPY` (0xd3)

コードがレガシーのバイトコードの場合、これらの命令はすべて *例外的な停止* を引き起こします。(*注: これは動作の変更はありません。*)

コードが有効な EOF1 の場合、以下の実行ルールが適用されます:

### `DATALOAD`

1. スタックから 1 つの値 `offset` をポップします。
2. データセクションから `[offset:offset+32]` セグメントを読み取り、32 バイトの値としてスタックにプッシュします。
3. `offset + 32` がデータセクションのサイズを超える場合、データセクションの末尾以降のバイトは 0 に設定されます。
4. 4 gas を差し引きます。

### `DATALOADN`

1. 16 ビットの符号なし ビッグエンディアン値でエンコードされた即値引数 `offset` を持ちます。
2. スタックからは何もポップしません。
3. データセクションから `[offset:offset+32]` セグメントを読み取り、32 バイトの値としてスタックにプッシュします。
4. 3 gas を差し引きます。

`[offset:offset+32]` は[コード検証](#コード検証)によって、データの範囲内にあることが保証されます。

### `DATASIZE`

1. スタックからは何もポップしません。
2. アクティブなコンテナのデータセクションのサイズをスタックにプッシュします。
3. 2 gas を差し引きます。

### `DATACOPY`

1. スタックから 3 つの値 `mem_offset`、`offset`、`size` をポップします。
2. `mem_offset + size` までメモリを拡張し、メモリ拡張コストを差し引きます。
3. コピーに `3 + 3 * ((size + 31) // 32)` gas を差し引きます。
4. データセクションから `[offset:offset+size]` セグメントを読み取り、メモリの `mem_offset` オフセットから書き込みます。
5. `offset + size` がデータセクションのサイズを超える場合、データセクションの末尾以降のバイトはコピーされません。

### コード検証

[EIP-3670](./eip-3670.md) で定義されているコードセクションの検証ルールを拡張します。

1. `DATALOADN` の即値引数 `offset` が、コンテナヘッダーに示されるデータセクションのサイズを超える場合、コードセクションは無効とみなされます。
2. `RJUMP`、`RJUMPI`、`RJUMPV` の即値引数値 (ジャンプ先のリラティブオフセット) の検証: `DATALOADN` 命令の直後の 2 バイトを指すオフセットの場合、コードセクションは無効とみなされます。

## 根拠

### 範囲外アクセスでのゼロパディング

他の種類のデータを読み取る既存の命令は、暗黙的にゼロでパディングされますが、リターンデータのコピーが例外です。

例外的な失敗を避けることが有益です。なぜなら、コンパイラは、コピーされたデータにアクセスしないコードを削除するような最適化を行うことができますが、そのような最適化は命令に副作用がない場合にのみ可能だからです。

### `EXTDATACOPY` の欠如

`EXTCODECOPY` 命令は非推奨となり、EOF コントラクトでは拒否されており、レガシーでEOFコントラクトをターゲットとして呼び出されても、コントラクトコードをコピーしません。`EXTDATACOPY` の代替命令が検討されましたが、変更範囲を最小限に抑えるために却下されました。

以前 `EXTCODECOPY` に依存していたデータ専用のコントラクトは、推奨されなくなりますが、強い需要がある場合は、将来のアップグレードで `EXTDATACOPY` をサポートすることで簡単に対応できます。

## 下位互換性

この変更は下位互換性のリスクはありません。EOF1 コントラクトにのみ導入されるため、未定義の命令を展開することは許可されていません。したがって、これらの命令を使用している既存のコントラクトはありません。新しい命令はレガシーのバイトコード (EOF 形式ではないコード) には導入されません。

## セキュリティ上の考慮事項

TBA

## 著作権

著作権およびそれに関連する権利は [CC0](../LICENSE.md) によって放棄されています。