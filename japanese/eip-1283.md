---
original: a02bb20c8d58262cee8ce582eab76818e409175b69e2ef682e4f59b5ccdb0e1c
---

---
eip: 1283
title: SSTORE の汚れたマップなしでのネットガスメーターリング
author: Wei Tang (@sorpaas)
discussions-to: https://github.com/sorpaas/EIPs/issues/1
status: Final
type: Standards Track
category: Core
created: 2018-08-01
---

## 概要

このEIPは、`SSTORE`オペコードのネットガスメーターリングの変更を提案し、コントラクトストレージの新しい用途を可能にし、ほとんどの実装で動作するようにガス代を削減します。

これは、EIP-1087の代替案として機能し、ストレージ変更キャッシュの異なる最適化戦略を使用する実装に対してより使いやすいものになります。

## 動機

このEIPは、EIP-1087およびEIP-1153の代替案として、ほとんどの実装で利用可能な情報を使用し、実装構造の変更を最小限に抑えるSSTOREのガスメーターリングの方法を提案します。

* *ストレージスロットの元の値*
* *ストレージスロットの現在の値*
* リファンドカウンター

このEIPのガス削減スキームから恩恵を受けるユースケースには以下のようなものがあります:

* 同一呼び出しフレーム内での後続のストレージ書き込み操作。これには、再入ロック、同一コントラクトのマルチセンド等が含まれます。
* サブコールフレームと親コールフレーム間でのストレージ情報の交換。ただし、この情報はトランザクション外では永続化される必要はありません。これには、サブフレームのエラーコードやメッセージ受け渡しなどが含まれます。

## 仕様

用語の定義は以下の通りです:

* *ストレージスロットの元の値*: 現在のトランザクションでリバージョンが発生した場合のストレージの値。
* *ストレージスロットの現在の値*: SSTOREオペレーションが発生する前のストレージの値。
* *ストレージスロットの新しい値*: SSTOREオペレーション後のストレージの値。

SSTOREオペコードのガスコスト計算(リファンドを含む)を以下のロジックに置き換えます:

* *現在の値*が*新しい値*と等しい場合(これはno-opです)、200ガスが差し引かれます。
* *現在の値*が*新しい値*と等しくない場合
  * *元の値*が*現在の値*と等しい(このストレージスロットは現在の実行コンテキストで変更されていない)
    * *元の値*が0の場合、20000ガスが差し引かれます。
    * それ以外の場合、5000ガスが差し引かれます。*新しい値*が0の場合、リファンドカウンターに15000ガスを加算します。
  * *元の値*が*現在の値*と等しくない(このストレージスロットは汚れている)、200ガスが差し引かれます。以下の2つのクローズも適用されます。
    * *元の値*が0でない場合
      * *現在の値*が0(つまり*新しい値*も0でない)、リファンドカウンターから15000ガスを減算します。リファンドカウンターは0を下回ることはありません。
      * *新しい値*が0(つまり*現在の値*も0でない)、リファンドカウンターに15000ガスを加算します。
    * *元の値*が*新しい値*と等しい(このストレージスロットがリセットされた)
      * *元の値*が0の場合、リファンドカウンターに19800ガスを加算します。
      * それ以外の場合、リファンドカウンターに4800ガスを加算します。

リファンドカウンターは従来どおり機能しますが、消費ガスの半分までに制限されます。トランザクションレベルでは、リファンドカウンターは0を下回ることはありません。ただし、実装の詳細によっては以下の点に注意が必要です:

* 実装が「トランザクションレベル」のリファンドカウンター(各コールフレームでリファンドがチェックポイントされる)を使用する場合、リファンドカウンターは符号なしのままです。
* 実装が「実行フレームレベル」のリファンドカウンター(各コールフレームで新しいリファンドカウンターが作成され、呼び出し元に返されるときにマージされる)を使用する場合、リファンドカウンターは符号付きに変更される必要があります。内部呼び出しでは、子リファンドがマイナスになる可能性があります。

## 説明

`SSTORE`の新しいガスコストスキームは3つの異なるタイプに分かれています:

* **No-op**: 仮想マシンは何も行う必要がありません。*現在の値*が*新しい値*と等しい場合がこれに該当します。
* **Fresh**: このストレージスロットは変更されていないか、元の値にリセットされています。*現在の値*が*新しい値*と等しくない、かつ*元の値*が*現在の値*と等しい場合がこれに該当します。
* **Dirty**: このストレージスロットはすでに変更されています。*現在の値*が*新しい値*と等しくない、かつ*元の値*が*現在の値*と等しくない場合がこれに該当します。

上記の3つのタイプで、*元の値*、*現在の値*、*新しい値*のすべての可能な組み合わせがカバーされています。

**No-op**は trivial な操作です。以下では**Fresh**と**Dirty**のみを考慮します。

特定のストレージスロットに対する最初の(No-opでない)`SSTORE`は**Fresh**から始まります。その後、値が変更された場合は**Dirty**になります。**Fresh**から**Dirty**に移行する際は、現在のスキームと同じガスコストが課されます。**Dirty**のストレージスロットは、`SSTORE`オペコードによってリセットされ**Fresh**に戻ることができます。これによりリファンドが発生します。

ストレージスロットが**Dirty**のままの場合は、200ガスが課されます。この場合、`R_SCLEAR`リファンドも追跡する必要があります。リファンドが既に発行されていたが、もはや適用されない場合(*現在の値*が0)は、リファンドカウンターからこのリファンドを減算します。リファンドが発行されていなかったが、今適用される場合(*新しい値*が0)は、リファンドカウンターにこのリファンドを加算します。上記のケースで、リファンドが発行されていないのにリファンドを減算することはできません。なぜなら、すべてのストレージスロットは**Fresh**状態から始まるためです。

### 状態遷移

以下のグラフ([by @Arachnid](https://github.com/ethereum/EIPs/pull/1283#issuecomment-410229053))は、ガスコストの可能な状態遷移を示しています。trivialな**No-op**状態は無視しています:

![State Transition](../assets/eip-1283/state.png)

上記の図表形式は以下の通りです。縦は*新しい値*が設定されるものを、横は*元の値*と*現在の値*の状態を示しています。

*元の値*が0の場合:

|    | A (`current=orig=0`) | B (`current!=orig`)      |
|----|----------------------|--------------------------|
| ~0 | B; 20k gas           | B; 200 gas               |
| 0  | A; 200 gas           | A; 200 gas, 19.8k refund |

*元の値*が0でない場合:

|             | X (`current=orig!=0`) | Y (`current!=orig`)     | Z (`current=0`)           |
|-------------|-----------------------|-------------------------|---------------------------|
| `orig`      | X; 200 gas            | X; 200 gas, 4.8k refund | X; 200 gas, -10.2k refund |
| `~orig, ~0` | Y; 5k gas             | Y; 200 gas              | Y; 200 gas, -15k refund   |
| 0           | Z; 5k gas, 15k refund | Z; 200 gas, 15k refund  | Z; 200 gas                |

## 根拠

このEIPは主にEIP-1087とEIP-1153が目指す「一時的なストレージ」の機能を実現しますが、「汚れたマップ」や追加のストレージ構造の概念を導入する複雑さはありません。

* EIP-1087の最適化の制限から免れます。EIP-1087は、ストレージ変更の「汚れたマップ」を保持する必要があり、トランザクションの終わりにストレージ変更をストレージトライに確定的にコミットするという暗黙の仮定を行っています。これは一部の実装には適していますが、他の実装には適していません。EIP-658以降、効率的なストレージキャッシュ実装では、メモリ内のトライ(RLPエンコーディング/デコーディングなし)や不変のデータ構造を使用してストレージ変更を追跡し、ブロックの終わりにのみ変更をコミットする可能性があります。このような実装では、ストレージの元の値と現在の値を知ることはできますが、すべてのストレージ変更を反復することなく追跡することはできません。
* 現在のスキームと比べてガスコストが増加することはありません。
* 一時的なストレージのすべてのユースケースをカバーしています。EIP-1087を簡単に実装できるクライアントは、この仕様も簡単に実装できます。他のクライアントではこの仕様の実装にいくつかの追加の作業が必要かもしれませんが、実行時の追加のメモリやプロセッシングコストはありません。

`SSTORE`のガスコストとリファンドについては、付録で本EIPが満たす性質の証明を参照してください。

* *絶対ガス使用量*(つまり実際の*ガス使用量*からリファンドを引いたもの)については、EIP-1087と同等です。
* ある特定のケースで、ストレージスロットが変更され、元の値にリセットされ、再び変更された場合、EIP-1283ではEIP-1087よりもリファンドカウンターにより多くのガスが移動します。

EIP-1087の動機で提供された例を確認してください:

* 空のストレージを持つコントラクトがスロット0を1に設定し、その後0に戻す場合、`20000 + 200 - 19800 = 400`ガスが課されます。
* 空のストレージを持つコントラクトがスロット0を5回インクリメントする場合、`20000 + 5 * 200 = 21000`ガスが課されます。
* アカウントAからアカウントBへの残高転送に続いて、BからCへの転送を行う場合(すべてのアカウントの開始および終了残高が0でない)、`5000 * 3 + 200 - 4800 = 10400`ガスが課されます。

## 下位互換性

このEIPの実装にはハードフォークが必要です。ガスコストの増加は予想されず、多くのコントラクトでガス削減が見られるでしょう。

## テストケース

以下に17のテストケースを示します。15のケースは[by @chfast](https://github.com/ethereum/tests/issues/483)の連続する2つのSSTOREオペレーションに基づいています。3つのSSTOREオペレーションを持つ2つの追加のケースは、スロットがリセットされてから再設定される場合をテストするために使用されます。

| コード                               | 使用ガス | リファンド | 元の値 | 1回目 | 2回目 | 3回目 |
|------------------------------------|----------|--------|----------|-----|-----|-----|
| `0x60006000556000600055`           | 412      | 0      | 0        | 0   | 0   |     |
| `0x60006000556001600055`           | 20212    | 0      | 0        | 0   | 1   |     |
| `0x60016000556000600055`           | 20212    | 19800  | 0        | 1   | 0   |     |
| `0x60016000556002600055`           | 20212    | 0      | 0        | 1   | 2   |     |
| `0x60016000556001600055`           | 20212    | 0      | 0        | 1   | 1   |     |
| `0x60006000556000600055`           | 5212     | 15000  | 1        | 0   | 0   |     |
| `0x60006000556001600055`           | 5212     | 4800   | 1        | 0   | 1   |     |
| `0x60006000556002600055`           | 5212     | 0      | 1        | 0   | 2   |     |
| `0x60026000556000600055`           | 5212     | 15000  | 1        | 2   | 0   |     |

| `0x60026000556003600055`           | 5212     | 0      | 1        | 2   | 3   |     |
| `0x60026000556001600055`           | 5212     | 4800   | 1        | 2   | 1   |     |
| `0x60026000556002600055`           | 5212     | 0      | 1        | 2   | 2   |     |
| `0x60016000556000600055`           | 5212     | 15000  | 1        | 1   | 0   |     |
| `0x60016000556002600055`           | 5212     | 0      | 1        | 1   | 2   |     |
| `0x60016000556001600055`           | 412      | 0      | 1        | 1   | 1   |     |
| `0x600160005560006000556001600055` | 40218    | 19800  | 0        | 1   | 0   | 1   |
| `0x600060005560016000556000600055` | 10218    | 19800  | 1        | 0   | 1   | 0   |

## 付録: 証明

*ストレージスロットの元の値*は、*現在のトランザクション*でリバージョンが発生したときの値と定義されているため、コールフレームがSSTOREのガス計算に影響を与えないことは明らかです。したがって、以下の証明はコールフレームなしで議論されていますが、コールフレームのある状況にも適用されます。*元の値*が0の場合と0でない場合を別々に議論し、*帰納法*を使ってSSTOREのガスコストの一部の性質を証明します。

*最終値*は、トランザクション終了時の特定のストレージスロットの値です。*絶対ガス使用量*は、*ガス使用量*からリファンドを引いた絶対値です。Nは、あるストレージスロットに対する SSTORE 操作の総数を表します。以下で議論される状態については、*説明*セクションの*状態遷移*を参照してください。

### 元の値が0の場合

*元の値*が0の場合、以下を証明したいと思います:

* **ケースI**: *最終値*が0のままの場合、`200 * N`ガスを課金したい。ディスクへの書き込みは不要だからです。
* **ケースII**: *最終値*が0以外の値になった場合、`20000 + 200 * (N-1)`ガスを課金したい。このスロットをディスクに書き込む必要があるためです。
  
#### ベースケース

常に状態Aから始まります。最初のSSTOREは以下のようになります:

* 状態Aに移行: 200ガスが差し引かれます。*ケースI*を満たします。なぜなら`200 * N == 200 * 1`だからです。
* 状態Bに移行: 20000ガスが差し引かれます。*ケースII*を満たします。なぜなら`20000 + 200 * (N-1) == 20000 + 200 * 0`だからです。
  
#### 帰納ステップ

* AからA. 前のガスコストは`200 * (N-1)`です。現在のガスコストは`200 + 200 * (N-1)`です。*ケースI*を満たします。
* AからB. 前のガスコストは`200 * (N-1)`です。現在のガスコストは`20000 + 200 * (N-1)`です。*ケースII*を満たします。
* BからB. 前のガスコストは`20000 + 200 * (N-2)`です。現在のガスコストは`200 + 20000 + 200 * (N-2)`です。*ケースII*を満たします。
* BからA. 前のガスコストは`20000 + 200 * (N-2)`です。現在の絶対ガスコストは`200 - 19800 + 20000 + 200 * (N-2)`です。*ケースI*を満たします。
  
### 元の値が0でない場合

*元の値*が0でない場合、以下を証明したいと思います:

* **ケースI**: *最終値*が変わらない場合、`200 * N`ガスを課金したい。ディスクへの書き込みは不要だからです。
* **ケースII**: *最終値*が0になった場合、`5000 - 15000 + 200 * (N-1)`ガスを課金したい。実際の定義では`15000`がリファンドです。
* **ケースIII**: *最終値*が0以外の変更された値になった場合、`5000 + 200 * (N-1)`ガスを課金したい。
  
#### ベースケース

常に状態Xから始まります。最初のSSTOREは以下のようになります:

* 状態Xに移行: 200ガスが差し引かれます。*ケースI*を満たします。なぜなら`200 * N == 200 * 1`だからです。
* 状態Yに移行: 5000ガスが差し引かれます。*ケースIII*を満たします。なぜなら`5000 + 200 * (N-1) == 5000 + 200 * 0`だからです。
* 状態Zに移行: 絶対ガスコストは`5000 - 15000`です。ここで15000がリファンドです。*ケースII*を満たします。なぜなら`5000 - 15000 + 200 * (N-1) == 5000 - 15000 + 200 * 0`だからです。
  
#### 帰納ステップ

* XからX. 前のガスコストは`200 * (N-1)`です。現在のガスコストは`200 + 200 * (N-1)`です。*ケースI*を満たします。
* XからY. 前のガスコストは`200 * (N-1)`です。現在のガスコストは`5000 + 200 * (N-1)`です。*ケースIII*を満たします。
* XからZ. 前のガスコストは`200 * (N-1)`です。現在の絶対ガスコストは`5000 - 15000 + 200 * (N-1)`です。*ケースII*を満たします。
* YからX. 前のガスコストは`5000 + 200 * (N-2)`です。現在の絶対ガスコストは`200 - 4800 + 5000 + 200 * (N-2)`です。*ケースI*を満たします。
* YからY. 前のガスコストは`5000 + 200 * (N-2)`です。現在のガスコストは`200 + 5000 + 200 * (N-2)`です。*ケースIII*を満たします。
* YからZ. 前のガスコストは`5000 + 200 * (N-2)`です。現在の絶対ガスコストは`200 - 15000 + 5000 + 200 * (N-2)`です。*ケースII*を満たします。
* ZからX. 前のガスコストは`5000 - 15000 + 200 * (N-2)`です。現在の絶対ガスコストは`200 + 10200 + 5000 - 15000 + 200 * (N-2)`です。*ケースI*を満たします。
* ZからY. 前のガスコストは`5000 - 15000 + 200 * (N-2)`です。現在の絶対ガスコストは`200 + 15000 + 5000 - 15000 + 200 * (N-2)`です。*ケースIII*を満たします。
* ZからZ. 前のガスコストは`5000 - 15000 + 200 * (N-2)`です。現在の絶対ガスコストは`200 + 5000 - 15000 + 200 * (N-2)`です。*ケースII*を満たします。

## 著作権

著作権およびその関連権利は[CC0](../LICENSE.md)で放棄されています。