---
original: 8cd9e92d5befc2227e6ca55d50eabe392665ae01d094389240ebcca4c537e1f2
---

---
eip: 663
title: SWAPN、DUPN、EXCHANGE命令
description: スタックの深い部分にアクセスできるようにする追加の命令を導入する
author: Alex Beregszaszi (@axic)、Charles Cooper (@charles-cooper)、Danno Ferrin (@shemnon)
discussions-to: https://ethereum-magicians.org/t/eip-663-unlimited-swap-and-dup-instructions/3346
status: Review
type: Standards Track
category: Core
created: 2017-07-03
requires: 3540, 5450
---

## 概要

現在、`SWAP*`と`DUP*`命令はスタックの深さが16に制限されています。`SWAPN`、`DUPN`、`EXCHANGE`の3つの新しい命令を導入し、この制限を解除し、スタックの深い部分にアクセスできるようにします。

## 動機

スタックの深さは1024項目ですが、上位16項目にしかアクセスできません。メモリ内に変数を保持したり、コンパイラによる「スタックからメモリへの昇格」を行うことで、より多くのローカル変数をサポートできます。しかし、これにより複雑で非効率なコードになる可能性があります。

さらに、EVM上で高レベルな構造体(関数など)を実装する場合、入力パラメータ、出力パラメータ、および戻り命令オフセットのリストが必要になります。これらの引数(またはスタック項目)の数は容易に16を超えてしまい、コンパイラがそれらすべてにアクセスできるように配置する必要があります。

最後に、1番目と最後の項目以外のスタック項目を交換することは、スタック割り当てアルゴリズム(スタックマシンのレジスタ割り当ての類似物)を実装するコンパイラにとって非常に重要です。これらのアルゴリズムは、変数の使用分析に基づいてスタックトラフィックを最小限に抑えることを試みます。

`SWAPN`、`DUPN`、`EXCHANGE`を導入することで、コンパイラがスタックの深い項目にアクセスするのを簡単にすることができます。

## 仕様

2つの新しい命令を導入します:

1. `DUPN` (`0xe6`)
2. `SWAPN` (`0xe7`)
3. `EXCHANGE` (`0xe8`)

レガシーバイトコードの場合、これらの命令はすべて*例外的な停止*を引き起こします。(*注:動作に変更はありません。*)

EOF1の場合、以下のルールが適用されます:

1. 命令の後に8ビットの即値値が続き、これを`imm`と呼びます。`imm`の値は0から255の範囲です。
   1. `DUPN`と`SWAPN`の場合、`n`変数は`imm + 1`に等しくなります。
   2. `EXCHANGE`の場合、`n`変数は`imm >> 4 + 1`に、`m`変数は`imm & 0x0F + 1`に等しくなります(つまり、`imm`の上位4ビットと下位4ビットを1インデックスに変換したもの)。
2. コード検証が拡張され、相対ジャンプ命令(`RJUMP`/`RJUMPI`/`RJUMPV`)が`DUPN`、`SWAPN`、`EXCHANGE`の即値をターゲットにしないことを確認します。
3. [EIP-5450](./eip-5450.md)のスタック検証アルゴリズムが拡張されます:
   1. `DUPN`の前に現在のスタックの高さが`n`未満の場合、コードは無効となります。`DUPN`の後、スタックの高さが1つ増加します。
   2. `SWAPN`の前に現在のスタックの高さが`n + 1`未満の場合、コードは無効となります。`SWAPN`の後、スタックの高さは変わりません。
   3. `EXCHANGE`の前に現在のスタックの高さが`n + m + 1`未満の場合、コードは無効となります。`EXCHANGE`の後、スタックの高さは変わりません。
4. 実行ルール:
   1. `DUPN`: `n`番目のスタック項目がスタックの先頭にコピーされます。(*注:ここでは1インデックスを使用しています。*)
   2. `SWAPN`: `n + 1`番目のスタック項目がスタックの先頭と交換されます。
   3. `EXCHANGE`: `n + 1`番目のスタック項目が`n + m + 1`番目のスタック項目と交換されます。

3つの命令すべての gas コストは3に設定されます。

## 根拠

### EOF専用

この命令は即値引数エンコーディングに依存するため、EOF内でのみ有効化できます。レガシーバイトコードではそのエンコーディングがjumpdest解析と矛盾する可能性があります。

### 即値引数のサイズ

`DUPN`と`SWAPN`では、1024項目のフルスタック領域に対応するために16ビットサイズが検討されましたが:

1. `n < 1024`という追加の制限/チェックが必要になる
2. 256の深さは現在の16に比べて大幅な改善であり、1バイトの追加オーバーヘッドはあまり有用ではない

同様に`EXCHANGE`では、提案されたスキームにより32項目にアクセスできます。

### gas コスト

これらの操作のgas コストは既存の`DUP*`および`SWAP*`命令と同じです。ポインタスワップとして実装されるためです。

### `EXCHANGE`vs `SWAPN`

前述のように、コンパイラがスタック割り当てアルゴリズムを実装する際、`EXCHANGE`は重要です。特に、スタック項目がスタックの深い部分にスケジュールされている場合(例えば、スタックの3番目の項目を2番目の位置に移動して次の操作で使用する必要がある場合)、現在は3つの命令`SWAP2 SWAP3 SWAP2`が必要です。しかし、EVMの実装では、ポインタスワップとして実装できるため、実行時のクライアントコストは追加されません。

## 下位互換性

以前オペコードが割り当てられていなかったため、この変更は下位互換性に影響しません。この機能はEOF内でのみ有効化されます。

## テストケース

`stack[]`が0ベースのデータ構造であり、`n`、`m`、`imm`が仕様に従って定義されているとします:

- `DUPN imm`は、`stack_height < n`の場合、検証に失敗します。
- `SWAPN imm`は、`stack_height < n + 1`の場合、検証に失敗します。
- `EXCHANGE imm`は、`stack_height < n + m + 1`の場合、検証に失敗します。
- `DUPN imm`は、関数の最大スタック高さを増加させます。最大スタック高さが1023を超える場合、検証に失敗します。
- `DUPN imm`、`SWAPN imm`、`EXCHANGE imm`は、利用可能なガスが3未満の場合、実行時に失敗します。
- `DUPN imm`は、`stack[n - 1]`項目をコピーしてスタックの先頭に push する必要があります。
- `SWAPN imm`は、`stack[n]`と`stack[stack.top()]`を交換する必要があります。
- `EXCHANGE imm`は、`stack[n]`と`stack[n + m]`を交換する必要があります。

## セキュリティ上の考慮事項

著者は、ここで導入される追加のリスクは認識していません。EVMスタックは1024項目に固定されており、ほとんどの実装ではそれをメモリ内に保持しています。この変更により、単一の命令でアクセスできるスタック項目の数が増加します。

## 著作権

著作権およびそれに関連する権利は[CC0](../LICENSE.md)で放棄されています。