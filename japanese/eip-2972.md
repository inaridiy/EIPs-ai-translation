---
original: 43383c568ae18054a2cc6ed4caac87c17149041b03c779def09a39d5eaf95045
---

---
eip: 2972
title: 旧式トランザクションのラッピング
author: Micah Zoltu (@MicahZoltu)
discussions-to: https://ethereum-magicians.org/t/eip-2972-wrapped-legacy-transactions/4604
status: 取り下げられた
type: Standards Track
category: Core
created: 2020-09-12
requires: 155, 2718
---

## 簡単な要約
チェーンIDを持つ/持たない旧式トランザクションをラップする2つの新しいトランザクションタイプ。

## 概要
[EIP-2718](./eip-2718.md)トランザクションと署名互換性のある2つの新しいトランザクションタイプを導入します。
クライアントによって自動的にアップグレードできます。

* `0x00 || ssz.serialize(yParity, r, s, rlp([nonce, gasPrice, gasLimit, to, value, data]))`
* `0x01 || ssz.serialize(yParity, r, s, rlp([nonce, gasPrice, gasLimit, to, value, data, chainId, 0, 0]))`

## 動機
最終的には旧式トランザクションを非推奨化したいと考えています。
ネットワーキングやサイン層でそれらを扱うコードを保持する必要がなくなるためです。
しかし、非推奨化の前に生成されたトランザクションの署名が引き続き有効であり、新しいスタイルのトランザクションに署名できないために資金が凍結されないようにしたいと考えています。
このEIPは、[EIP-2718](./eip-2718.md)互換でありながら、旧式トランザクションの署名互換性を維持するメカニズムを提供します。

## 仕様
### 定義
* `||`はバイト/バイト配列の連結演算子です。
* `yParity`はsecp256k1署名プロセスでrが`x`値である曲線点の`y`値の偶奇性(0は偶数、1は奇数)です。

### トランザクション
`FORK_BLOCK_NUMBER`以降、`0x00 || ssz.serialize(yParity, r, s, rlp([nonce, gasPrice, gasLimit, to, value, data]))`は有効なトランザクションとなります。
* RLPエンコードされたトランザクション部分は、最終的なエンコーディングを除いて、旧式トランザクションと同じ方法で署名/処理/処理されます。
* TODO: ブロックトランザクションルートのハッシュ化またはマークル化

`FORK_BLOCK_NUMBER`以降、`0x01 || ssz.serialize(yParity, r, s, rlp([nonce, gasPrice, gasLimit, to, value, data, chainId, 0, 0]))`は有効なトランザクションとなります。
* RLPエンコードされたトランザクション部分は、最終的なエンコーディングを除いて、旧式トランザクションと同じ方法で署名/処理/処理されます。
* TODO: ブロックトランザクションルートのハッシュ化またはマークル化

両方のトランザクションタイプのSSZスキーマは以下の通りです:
  ```
  Transaction[
    yParity: boolean,
    r: bytes32,
    s: bytes32,
    signedData: bytes,
  ]
  ```

注: `sszencode(yParity, r, s, rlp(...))` は `yParity || r || s || 0x45000000 || rlp(...)` と同じです。

`FORK_BLOCK_NUMBER`以降、`rlp(nonce, gasPrice, gasLimit, to, value, data, v, r, s)`はブロック内の有効なトランザクションではなくなります。

### レシート
`FORK_BLOCK_NUMBER`以降、`0 || ssz.serialize(status, cumulativeGasUsed, logsBloom, logs)`は有効なレシートとなります。
* `ReceiptPayload`は、エンコーディングを除いて、旧式レシートと同じ方法で生成/処理/処理されます。
* TODO: ブロックレシートルートのハッシュ化またはマークル化

`FORK_BLOCK_NUMBER`以降、`1 || ssz.serialize(status, cumulativeGasUsed, logsBloom, logs)`は有効なレシートとなります。
* `ReceiptPayload`は、エンコーディングを除いて、旧式レシートと同じ方法で生成/処理/処理されます。
* TODO: ブロックレシートルートのハッシュ化またはマークル化

両方のレシートタイプのSSZスキーマは以下の通りです:
```
Log[
  address: bytes20,
  topics: List[bytes32, 4],
  data: List[uint8, 0xffffff],
]
Receipt[
  status: uint8,
  cumulativeGasUsed: uint64,
  logsBloom: BitVector[2048],
  logs: List[Log, 0xffffff],
]
```

`FORK_BLOCK_NUMBER`以降、`rlp(status, cumulativeGasUsed, logsBloom, logs)`はブロック内の有効なレシートではなくなります。

## 根拠
### 署名にはトランザクションタイプが含まれていない
これらのトランザクションタイプは明示的に旧式トランザクションと署名互換性を持つように設計されているため、署名されるデータを変更することはできません。
詳細はセキュリティ上の考慮事項のセクションを参照してください。
### 1つではなく2つのトランザクションタイプ
タイプ付きトランザクションの導入により、署名の形状を変更することなく、ビットパッキングを行う必要がなくなりました。
旧式トランザクションでは[EIP-155](./eip-155.md)でチェーンIDが導入され、トランザクション配列の長さを変更したくなかったため、署名の`v`値にチェーンIDをビットパックしていました。
トランザクションタイプ間でペイロードの長さを一致させる必要がなくなったため、明確なフィールドを持つ2つのトランザクションタイプを選択しました。
### 署名と署名データの分離
署名を検証するには、まず署名データから署名を分離し、署名データに対して署名を検証する必要があります。
旧式トランザクションの場合、これはやや面倒でした。トランザクションをRLPデコードし、署名を抽出し、トランザクションのサブセットをRLPエンコードする必要があったためです。
EIP-155ではこのプロセスがさらに悪化し、検証者が`v`署名値をさらにデコードして、署名データペイロードにチェーンIDを含める必要がありました。
署名データを署名されたものと正確に同じようにエンコードすることで、事前にデコーダを使用することなく、トランザクションの署名を検証できるようになりました。
署名をSSZでエンコードすることで、デコーダを使用せずに署名を簡単に抽出できます。
### シリアル化にSSZを使用
RLPは、ストリーミングできないことから、ハッシュ化されたデータに適していないという弱い合意があります。
SSZはおそらく近い将来Ethereumに組み込まれるため、クライアントはSSZデコーダにアクセスできるはずです。
この特定のケースでは、完全なSSZデコーダを使用せずに手動でデコードするのは複雑ではありませんが、`logs`が可変長アイテムの配列であるため、少し「ポインタ演算」を行う必要があります。
### 旧式トランザクションの非推奨化
旧式トランザクションを非推奨化することで、クライアントにとってより簡単になります。ブロック内のタイプ付きトランザクションのみを処理すればよいためです。
### ログと ログデータの最大長
[EIP-706](./eip-706.md)はdevp2pメッセージを24ビットの長さに制限しているため、現時点では単一のトランザクションに対してそれ以上の実用的な上限があると考えられます。
この数値は、近い将来に合理的なものを大幅に超えているため、妥当な上限と考えられます。

## 下位互換性
新しいトランザクションは旧式トランザクションと署名互換性があります。
旧式トランザクションをデコードし、タイプ0またはタイプ1のトランザクションとしてエンコードできます。
このEIPでは旧式エンコードトランザクションの非推奨化プロセスは導入していませんが、合理的な時期にクライアント開発者に旧式エンコードトランザクションをタイプ付きトランザクションにアップグレードすることを推奨しています。

署名の互換性により、同じトランザクションが両方の方法でエンコードされている可能性があります。
このような場合、クライアントはどちらを保持するかを選択できますが、旧式エンコードトランザクションではなくタイプ付きトランザクションを保持することが推奨されます。
2つのトランザクションはノンスを共有するため、チェーン上で同時に有効になることはありません。

## テストケース
TBD

## 実装
TBD

## セキュリティ上の考慮事項
[EIP-2718](./eip-2718.md)では、署名データの最初のバイトとしてトランザクションタイプを含めることを強く推奨していますが、この場合は旧式トランザクションとの署名互換性を維持する必要があるため、それを実現することはできません。
幸いなことに、[EIP-2718](./eip-2718.md)は`0xc0`から`0xfe`までのトランザクションタイプを有効なトランザクションタイプから除外しているため、この場合の署名の最初のバイトはその範囲内にあり、将来のトランザクションタイプと競合しないことが確実です。

これらのトランザクションタイプの署名は**旧式トランザクションと衝突**しますが、トランザクションは同じ方法で処理されるため、トランザクションが旧式トランザクションまたはタイプ付きトランザクションとして含まれていても問題ありません。

## 著作権
著作権およびそれに関連する権利は[CC0](../LICENSE.md)で放棄されています。