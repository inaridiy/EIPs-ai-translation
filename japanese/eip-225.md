---
original: a11fd7c43ea9fa475e6004762b94a30f5f21ed689a1d0bf02b4dc53d85505e35
---

---
eip: 225
title: Cliqueプルーフオブオーソリティコンセンサスプロトコル
author: Péter Szilágyi <peterke@gmail.com>
discussions-to: https://github.com/ethereum/EIPs/issues/225
status: Final
type: Standards Track
category: Core
created: 2017-03-06
---

## 概要

Cliqueはプルーフオブオーソリティコンセンサスプロトコルです。Ethereumメインネットのデザインを踏襲しているため、最小限の労力でクライアントに組み込むことができます。

## 動機

Ethereumの最初の公式テストネットはMordenでした。2015年7月から2016年11月頃まで稼働していましたが、蓄積されたゴミやGethとParityの間のテストネットコンセンサスの問題により、最終的にリブートのためにシャットダウンされました。

そして、Ropstenが誕生し、すべてのゴミを一掃して新しい状態から始まりました。2017年2月末まで順調に稼働していましたが、その後、悪意のある攻撃者が低いPoWを悪用し、ブロックガスリミットを徐々に90億(通常の470万から)まで膨らませ、巨大なトランザクションを送信してネットワーク全体を麻痺させました。それ以前にも、攻撃者は極端に長い再編成を試み、クライアント間やバージョン間でネットワークの分断を引き起こしていました。

これらの攻撃の根本原因は、PoWネットワークのセキュリティが支えられる計算能力に依存しているということです。新しいテストネットを0から再起動しても、攻撃者は同じ攻撃を繰り返すことができます。Parityチームは、多数のブロックを巻き戻し、ガスリミットを一定の閾値以下に制限するソフトフォークルールを導入するという緊急対応策を講じました。

この対応策は短期的には機能するかもしれませんが:

* 優雅ではありません: Ethereumは動的なブロックリミットを持つはずです
* 移植性がありません: 他のクライアントも新しいフォークロジックを実装する必要があります
* 同期モードと互換性がありません: 高速同期とライトクライアントの両方が影響を受けます
* 攻撃を長期化しているだけです: ゴミは無限に押し込まれ続けることができます

Parityの対応策は完璧ではありませんが、機能するものです。より長期的な代替案として、より複雑ですが合理的な時間内に実装できるソリューションを提案したいと思います。

### 標準化されたプルーフオブオーソリティ

上述のように、価値のないネットワークでPoWは安全に機能しません。Ethereumには長期的にCasperベースのプルーフオブステークが目標としてありますが、それは重要な研究課題であり、今すぐの問題を解決するためには頼れません。しかし、簡単に実装でき、テストネットの問題を適切に解決できる解決策があります。それがプルーフオブオーソリティスキームです。

ここで説明するPoAプロトコルの主な設計目標は、既存のEthereumクライアントに簡単に実装・組み込めるようにすること、そして高速、ライト、warp同期などの既存の同期技術を使えるようにすることです。クライアント開発者が重要なソフトウェアにカスタムロジックを追加する必要がないようにすることです。

## 設計制約

ブロックチェーンの同期には2つの一般的なアプローチがあります:

 * 古典的なアプローチは、ジェネシスブロックから始めて1つずつトランザクションを処理していくというものです。これは確立された手法ですが、Ethereumのような複雑なネットワークでは計算コストが非常に高くなります。
 * もう1つは、ブロックヘッダーのチェーンをダウンロードし、その有効性を検証した後、ネットワークから任意の最新の状態をダウンロードしてヘッダーと照合するというものです。

PoAスキームは、信頼された署名者だけがブロックを生成できるという考えに基づいています。したがって、クライアントが見るすべてのブロック(またはヘッダー)を、信頼された署名者のリストと照合できます。ここで問題となるのは、時間とともに変化する署名者のリストをどのように維持するかということです。明らかな答え(Ethereumコントラクトに保存する)は間違っています。高速、ライト、warp同期では、同期中にステートにアクセスできません。

**署名者のリストを維持するプロトコルは、ブロックヘッダー内に完全に含まれていなければなりません。**

次の明らかなアイデアは、PoWの概念を削除し、投票メカニズムに対応する新しいフィールドを導入するようにブロックヘッダーの構造を変更することです。これも間違った答えです。そのようなコアデータ構造を複数の実装で変更するのは、開発、メンテナンス、セキュリティの面で悪夢になるでしょう。

**署名者のリストを維持するプロトコルは、現在のデータモデルに完全に収まっていなければなりません。**

以上のことから、投票にEVMを使うことはできず、ヘッダーに頼らざるを得ません。そしてヘッダーフィールドを変更することもできません。余地はほとんどありません。

### ヘッダーフィールドの署名と投票への流用

現在、単なる"メタデータ"としてのみ使われている最も明らかなフィールドは、ブロックヘッダーの32バイトの**extraData**セクションです。マイナーは通常クライアントとバージョンをそこに置きますが、一部は代替の"メッセージ"で埋めています。このプロトコルでは、この領域を65バイトに拡張し、secp256k1マイナー署名の目的で使用します。これにより、ブロックを取得した誰もが、認可された署名者のリストに対してそれを検証できるようになります。また、ブロックヘッダーの**miner**セクションも不要になります(アドレスは署名から導出できるため)。

*注意: ヘッダーフィールドの長さを変更するのは、RLPエンコーディング、ハッシュなどのすべてのコードがそれに依存しないため、非侵襲的な操作です。クライアントにカスタムロジックを追加する必要はありません。*

上記は、チェーンを検証するのに十分ですが、動的な署名者リストをどのように更新するかという問題があります。新しく不要になった**miner**フィールドと**nonce**フィールドを使って、投票プロトコルを作ることができます:

 * 通常のブロックでは、これらのフィールドはゼロに設定されます。
 * 署名者が署名者リストの変更を行いたい場合は:
   * **miner**フィールドに投票対象の署名者アドレスを設定します
   * **nonce**フィールドを`0`または`0xff...f`に設定して、追加または削除に投票します

ブロック処理中に、クライアントはこれらの投票を"集計"し、多数決に基づいて動的に署名者リストを維持できます。

投票ウィンドウを無限に広げないようにし、定期的に古い提案をフラッシュできるようにするために、ethashのエポックの概念を再利用できます。これらのエポック遷移では、ヘッダーのextraDataセクションに現在の認可された署名者のリストを含めることで、それ以前の投票履歴を再生することなく、チェックポイントハッシュのみに基づいてクライアントが同期できるようになります。また、ジェネシスヘッダーにも初期の署名者リストを完全に定義できるようになります。

### 攻撃ベクトル: 悪意のある署名者

署名者リストに悪意のあるユーザーが追加されたり、署名者の鍵/マシンが侵害された場合、プロトコルは再編成やスパミングに対して自己防衛できる必要があります。提案されているソリューションは、N人の認可された署名者がいる場合、各署名者は K ブロックに1ブロックしか生成できないというものです。これにより被害が制限され、残りの署名者が悪意のある署名者を投票で排除できるようになります。

### 攻撃ベクトル: 検閲する署名者

もう1つの興味深い攻撃ベクトルは、署名者(または署名者のグループ)が署名者リストからの削除に投票するブロックを検閲しようとすることです。これに対処するために、署名者の許可された生成頻度を N/2 に制限します。これにより、悪意のある署名者が少なくとも51%の署名アカウントを支配する必要があり、その場合ゲームオーバーです。

### 攻撃ベクトル: スパムする署名者

最後の小さな攻撃ベクトルは、悪意のある署名者が生成するすべてのブロックに新しい投票提案を挿入することです。ノードは実際の署名者リストを作成するために、時間の経過とともにすべての投票を集計する必要があります。投票ウィンドウに制限がないと、ゆっくりではあるが無制限に成長する可能性があります。解決策は、W ブロックの移動ウィンドウの後に投票が古くなるとみなすことです。適切なウィンドウサイズは1-2エポックくらいでしょう。

### 攻撃ベクトル: 同時ブロック

認可された署名者がN人いて、各署名者がK ブロックに1ブロックしか生成できないとすると、任意の時点でN-K+1人の署名者が生成できます。これらの署名者が競争しないように、各署名者は新しいブロックをリリースする最適な時間に小さなランダムな"オフセット"を追加します。これにより、小さなフォークは稀ですが時折発生します(メインネットと同様)。署名者が権限を乱用し、混乱を引き起こすことが判明した場合は、投票で排除できます。

## 仕様

以下の定数を定義します:

 * **`EPOCH_LENGTH`**: チェックポイントを作成し、保留中の投票をリセットするブロック数。
   * テストネットでは30000を提案し、メインネットのethashエポックと同様にします。
 * **`BLOCK_PERIOD`**: 2つの連続するブロックのタイムスタンプ間の最小差。
   * テストネットでは15秒を提案し、メインネットのethashターゲットと同様にします。
 * **`EXTRA_VANITY`**: 署名者の*バニティ*データ用に予約された固定長のextra-dataプレフィックスバイト数。
   * 現在のextra-dataの許容量や用途を維持するために32バイトを提案します。
 * **`EXTRA_SEAL`**: 署名者の署名用に予約された固定長のextra-dataサフィックスバイト数。
   * 標準的なsecp256k1曲線に基づく署名のため、65バイトに固定されます。
   * ジェネシスブロックではゼロで埋められます。
 * **`NONCE_AUTH`**: 新しい署名者の追加に投票するための特殊なnonce値`0xffffffffffffffff`。
 * **`NONCE_DROP`**: 署名者の削除に投票するための特殊なnonce値`0x0000000000000000`。
 * **`UNCLE_HASH`**: `Keccak256(RLP([]))`に固定され、PoW以外ではおじいさんは無意味です。
 * **`DIFF_NOTURN`**: 順番外の署名を含むブロックのスコア(難易度)。
   * 任意の基準定数1を提案します。
 * **`DIFF_INTURN`**: 順番内の署名を含むブロックのスコア(難易度)。
   * 順番外の署名よりも少し優先されるよう2を提案します。

また、以下のブロック単位の定数も定義します:

 * **`BLOCK_NUMBER`**: チェーン内のブロック高さ。ジェネシスブロックの高さは0です。
 * **`SIGNER_COUNT`**: ある時点で有効な認可された署名者の数。
 * **`SIGNER_INDEX`**: 現在の認可された署名者のソート済みリストにおける、ブロック署名者のゼロベースのインデックス。
 * **`SIGNER_LIMIT`**: 署名者が連続して署名できるブロック数。
   * チェーンに過半数のコンセンサスを強
制するため、`floor(SIGNER_COUNT / 2) + 1`でなければなりません。

ethashヘッダーフィールドを以下のように流用します:

 * **`beneficiary`** / **`miner`**: 署名者リストの変更を提案するアドレス。
   * 通常はゼロで埋める必要がありますが、投票時にのみ変更します。
   * 投票メカニクスの複雑さを避けるため、意味のないものでも任意の値を許可します。
   * チェックポイント(すなわちエポック遷移)ブロックでは**必ずゼロ**で埋める必要があります。
   * トランザクション実行では、実際のブロック署名者(see `extraData`)を`COINBASE`オペコードで使用し、トランザクション手数料は署名者アカウントに属するものとします。
 * **`nonce`**: `beneficiary`フィールドで定義されたアカウントに関する署名者の提案。
   * 既存の署名者を削除する提案の場合は**`NONCE_DROP`**にする必要があります。
   * 新しい署名者を認可する提案の場合は**`NONCE_AUTH`**にする必要があります。
   * チェックポイント(すなわちエポック遷移)ブロックでは**必ずゼロ**で埋める必要があります。
   * 上記2つの値以外は使用してはいけません(当面は)。
 * **`extraData`**: 署名者のバニティ、チェックポイント、署名を組み合わせたフィールド。
   * 最初の**`EXTRA_VANITY`**バイトは任意の署名者バニティデータを含みます。
   * 最後の**`EXTRA_SEAL`**バイトは、ヘッダーを密封する署名者の署名です。
   * チェックポイントブロックでは、その間に署名者のリスト(`N*20バイト`)が含まれ、それ以外では**省略**されます。
   * チェックポイントブロックのextra-dataセクションの署名者リストは、バイト順に昇順にソートされている必要があります。
 * **`mixHash`**: フォーク保護ロジックのために予約されており、DAOの際のextra-dataと同様に使用されます。
   * 通常の操作中は**必ずゼロ**で埋める必要があります。
 * **`ommersHash`**: PoW以外では無意味なおじいさんなので、**`UNCLE_HASH`**にする必要があります。
 * **`timestamp`**: 親のタイムスタンプ + **`BLOCK_PERIOD`**以上でなければなりません。
 * **`difficulty`**: ブロックの単独のスコアを含み、チェーンの品質を導出します。
   * `BLOCK_NUMBER % SIGNER_COUNT != SIGNER_INDEX`の場合は**`DIFF_NOTURN`**にする必要があります。
   * `BLOCK_NUMBER % SIGNER_COUNT == SIGNER_INDEX`の場合は**`DIFF_INTURN`**にする必要があります。

### ブロックの承認

ネットワークにブロックを承認するには、署名者がブロックのsighash(署名自体を除く)に署名する必要があります。つまり、このハッシュにはヘッダーのすべてのフィールド(`nonce`と`mixDigest`を含む)と、65バイトの署名サフィックスを除いた`extraData`が含まれます。フィールドは黄色い論文の定義順にハッシュ化されます。この sighash は最終的なブロックハッシュとは異なることに注意してください。

sighashは標準のsecp256k1曲線を使って署名され、その結果の65バイトの署名(`R`、`S`、`V`、ここで`V`は`0`または`1`)が`extraData`の最後65バイトに埋め込まれます。

悪意のある署名者(署名キーの紛失)による破壊を防ぐため、各署名者は**最大1つ**の**`SIGNER_LIMIT`**連続ブロックしか署名できません。順番は固定ではありませんが、順番通りの署名(`DIFF_INTURN`)の方が順番外(`DIFF_NOTURN`)よりも重みがあります。

#### 承認戦略

署名者が上記の仕様に準拠している限り、ブロックの承認と配布を自由に行うことができます。ただし、以下の提案する戦略は、ネットワークトラフィックと小さなフォークを減らすことができるため、推奨される機能です:

 * 署名者が署名できる(認可リストにおり、最近署名していない)場合
   * 次のブロックの最適な署名時間を計算する(親 + **`BLOCK_PERIOD`**)。
   * 署名者が順番通りの場合、正確な時間が到来するまで待ち、即座に署名して配信する。
   * 署名者が順番外の場合、`rand(SIGNER_COUNT * 500ms)`だけ署名を遅らせる。

この小さな戦略により、重みの大きい順番通りの署名者(ブロックの重みが大きい)が、順番外の署名者よりも少し有利に署名し、配信できるようになります。また、署名者の数が増えても少し拡張できます。

### 署名者への投票

すべてのエポック遷移(ジェネシスブロックを含む)は状態非依存のチェックポイントとして機能し、以前の状態を必要とせずにクライアントが同期できるようになります。つまり、エポックヘッダーには**投票を含めてはいけず**、未解決の投票はすべて破棄され、集計は最初から始まります。

エポック遷移以外のすべてのブロックについて:

 * 署名者は自身のブロックに1票投じて、承認リストの変更を提案できます。
 * 単一の署名者からの、同一の提案対象に対する最新の提案のみが保持されます。
 * 投票は、チェーンの進行に合わせて即座に集計されます(並行提案が許可されます)。
 * 過半数の`SIGNER_LIMIT`に達した提案は即座に有効になります。
 * クライアントの実装を単純にするため、無効な提案は**罰せられません**。

**提案が有効になると、その提案に対する保留中の投票(賛成・反対)をすべて破棄し、新しい状態から始めます。**

#### 連鎖投票

署名者の削除時に複雑な隅々ケースが発生する可能性があります。以前に認可された署名者が削除されると、提案を承認するために必要な署名者の数が1つ減る可能性があります。これにより、1つ以上の保留中の提案が過半数の承認を得る可能性があり、それらの実行が連鎖的に新しい提案の通過につながる可能性があります。

複数の矛盾する提案が同時に通過した場合(例: 新しい署名者の追加vs.既存の署名者の削除)、評価順序が最終的な承認リストの結果を大きく変える可能性があるため、この連鎖的な実行シナリオに対処するのは明らかではありません。署名者は自身の投票を毎ブロックで反転させることができるため、"最初の"提案がどれかも明らかではありません。

連鎖的な実行の落とし穴を避けるため、Cliqueの提案では連鎖効果を明示的に禁止しています。言い換えると、**現在のヘッダー/投票の`beneficiary`のみが承認リストに追加/削除されることができます。これにより他の提案が承認に達した場合、それらは`beneficiary`が再び"触れられた"ときに(その時点で過半数の承認が維持されていれば)実行されます。**

#### 投票戦略

ブロックチェーンには小さな再編成が発生する可能性があるため、"投票して忘れる"というナイーブな投票メカニズムは最適ではありません。単一の投票を含むブロックが最終チェーンに含まれない可能性があるためです。

単純ですが機能する戦略は、ユーザーが署名者に対する"提案"を設定できるようにすることです(例: "0x...を追加"、"0x...を削除")。署名コードは、毎ブロック署名する際にランダムな提案を選択し、それを挿入できます。これにより、並行する提案や再編成も最終的にチェーンに記録されるようになります。

このリストは一定数のブロック/エポック後に期限切れになる可能性がありますが、提案が通過したことを"見る"だけでは、それが再編成されないとは限らないことを認識しておく必要があります。提案が通過したら即座に削除してはいけません。

## テストケース

```go
// blockは特定のアカウントが署名した単一のブロックを表し、
// そのアカウントがClique投票を行ったかどうかを示します。
type block struct {
  signer     string   // このブロックに署名したアカウント
  voted      string   // 署名者が誰かに投票した場合のオプション値
  auth       bool     // 投票が承認(または非承認)するものかどうか
  checkpoint []string // このがエポックブロックの場合の、認可された署名者のリスト
}

// 様々な投票シナリオをテストするために定義
tests := []struct {
  epoch   uint64   // エポックのブロック数(未設定 = 30000)
  signers []string // ジェネシスの初期認可署名者リスト
  blocks  []block  // 署名者の承認に影響し得るブロックチェーン
  results []string // すべてのブロック後の最終的な認可署名者リスト
  failure error    // 何らかのブロックがルールに反する場合のエラー
}{
  {
    // 単一の署名者、投票なし
    signers: []string{"A"},
    blocks:  []block{
      {signer: "A"}
    },
    results: []string{"A"},
  }, {
    // 単一の署名者、2人の追加に投票(最初の1人のみ承認、2人目は2票必要)
    signers: []string{"A"},
    blocks:  []block{
      {signer: "A", voted: "B", auth: true},
      {signer: "B"},
      {signer: "A", voted: "C", auth: true},
    },
    results: []string{"A", "B"},
  }, {
    // 2人の署名者、3人の追加に投票(最初の2人のみ承認、3人目は3票必要)
    signers: []string{"A", "B"},
    blocks:  []block{
      {signer: "A", voted: "C", auth: true},
      {signer: "B", voted: "C", auth: true},
      {signer: "A", voted: "D", auth: true},
      {signer: "B", voted: "D", auth: true},
      {signer: "C"},
      {signer: "A", voted: "E", auth: true},
      {signer: "B", voted: "E", auth: true},
    },
    results: []string{"A", "B", "C", "D"},
  }, {
    // 単一の署名者、自身を削除(奇妙ですが、1つ少ないコーナーケースを明示的に許可)
    signers: []string{"A"},
    blocks:  []block{
      {signer: "A", voted: "A", auth: false},
    },
    results: []string{},
  }, {
    // 2人の署名者、実際には相互の同意が必要(満たされていない)
    signers: []string{"A", "B"},
    blocks:  []block{
      {signer: "A", voted: "B", auth: false},
    },
    results: []string{"A", "B"},
  }, {
    // 2人の署名者、実際には相互の同意が必要(満たされた)
    signers: []string{"A", "B"},
    blocks:  []block{
      {signer: "A", voted: "B", auth: false},
      {signer: "B", voted: "B", auth: false},
    },
    results: []string{"A"},
  }, {
    // 3人の署名者、2人が3人目を削除することを決める
    signers: []string{"A", "B", "C"},
    blocks:  []block{
      {signer: "A", voted: "C", auth: false},
      {signer: "B", voted: "C", auth: false},
    },
    results: []string{"A", "B"},
  }, {
    // 4人の署名者、2人の合意では誰も削除できない
    signers: []string{"A", "B", "C", "D"},
    blocks:  []block{
      {signer: "A", voted: "C", auth: false},
      {signer: "B", voted: "C", auth: false},
    },
    results: []string{"A", "B", "C", "D"},
  }, {
    // 4人の署名者、3人の合意で誰かを削除できる
    signers: []string{"A", "B", "C", "D"},
    blocks:  []block{
      {signer: "A", voted: "D", auth: false},
      {signer: "B", voted: "D", auth: false},
      {signer: "C", voted: "D", auth: false},
    },
    results: []string{"A", "B", "C
}, {
    // 承認は署名者ごとに1回だけカウントされる
    signers: []string{"A", "B"},
    blocks:  []block{
      {signer: "A", voted: "C", auth: true},
      {signer: "B"},
      {signer: "A", voted: "C", auth: true},
      {signer: "B"},
      {signer: "A", voted: "C", auth: true},
    },
    results: []string{"A", "B"},
  }, {
    // 複数のアカウントの承認は同時に許可される
    signers: []string{"A", "B"},
    blocks:  []block{
      {signer: "A", voted: "C", auth: true},
      {signer: "B"},
      {signer: "A", voted: "D", auth: true},
      {signer: "B"},
      {signer: "A"},
      {signer: "B", voted: "D", auth: true},
      {signer: "A"},
      {signer: "B", voted: "C", auth: true},
    },
    results: []string{"A", "B", "C", "D"},
  }, {
    // 非承認も署名者ごとに1回だけカウントされる
    signers: []string{"A", "B"},
    blocks:  []block{
      {signer: "A", voted: "B", auth: false},
      {signer: "B"},
      {signer: "A", voted: "B", auth: false},
      {signer: "B"},
      {signer: "A", voted: "B", auth: false},
    },
    results: []string{"A", "B"},
  }, {
    // 複数のアカウントの非承認も同時に許可される
    signers: []string{"A", "B", "C", "D"},
    blocks:  []block{
      {signer: "A", voted: "C", auth: false},
      {signer: "B"},
      {signer: "C"},
      {signer: "A", voted: "D", auth: false},
      {signer: "B"},
      {signer: "C"},
      {signer: "A"},
      {signer: "B", voted: "D", auth: false},
      {signer: "C", voted: "D", auth: false},
      {signer: "A"},
      {signer: "B", voted: "C", auth: false},
    },
    results: []string{"A", "B"},
  }, {
    // 非承認された署名者の投票は即座に破棄される(非承認投票)
    signers: []string{"A", "B", "C"},
    blocks:  []block{
      {signer: "C", voted: "B", auth: false},
      {signer: "A", voted: "C", auth: false},
      {signer: "B", voted: "C", auth: false},
      {signer: "A", voted: "B", auth: false},
    },
    results: []string{"A", "B"},
  }, {
    // 非承認された署名者の投票は即座に破棄される(承認投票)
    signers: []string{"A", "B", "C"},
    blocks:  []block{
      {signer: "C", voted: "D", auth: true},
      {signer: "A", voted: "C", auth: false},
      {signer: "B", voted: "C", auth: false},
      {signer: "A", voted: "D", auth: true},
    },
    results: []string{"A", "B"},
  }, {
    // 連鎖変更は許可されず、投票対象のアカウントのみが変更される
    signers: []string{"A", "B", "C", "D"},
    blocks:  []block{
      {signer: "A", voted: "C", auth: false},
      {signer: "B"},
      {signer: "C"},
      {signer: "A", voted: "D", auth: false},
      {signer: "B", voted: "C", auth: false},
      {signer: "C"},
      {signer: "A"},
      {signer: "B", voted: "D", auth: false},
      {signer: "C", voted: "D", auth: false},
    },
    results: []string{"A", "B", "C"},
  }, {
    // 非承認を通じて合意に達した変更は、触れられたときに実行される
    signers: []string{"A", "B", "C", "D"},
    blocks:  []block{
      {signer: "A", voted: "C", auth: false},
      {signer: "B"},
      {signer: "C"},
      {signer: "A", voted: "D", auth: false},
      {signer: "B", voted: "C", auth: false},
      {signer: "C"},
      {signer: "A"},
      {signer: "B", voted: "D", auth: false},
      {signer: "C", voted: "D", auth: false},
      {signer: "A"},
      {signer: "C", voted: "C", auth: true},
    },
    results: []string{"A", "B"},
  }, {
    // 非承認を通じて合意に達した変更は、最初の触れ時に合意を失う可能性がある
    signers: []string{"A", "B", "C", "D"},
    blocks:  []block{
      {signer: "A", voted: "C", auth: false},
      {signer: "B"},
      {signer: "C"},
      {signer: "A", voted: "D", auth: false},
      {signer: "B", voted: "C", auth: false},
      {signer: "C"},
      {signer: "A"},
      {signer: "B", voted: "D", auth: false},
      {signer: "C", voted: "D", auth: false},
      {signer: "A"},
      {signer: "B", voted: "C", auth: true},
    },
    results: []string{"A", "B", "C"},
  }, {
    // 承認ステータスの変化に伴う保留中の投票が残存しないことを確認する。
    // この隅々ケースは、署名者が素早く追加、削除、再追加(または逆)された場合にのみ発生する可能性があり、
    // その際に元の投票者の1人が削除された場合に、システムのどこかに過去の投票が残っていると、
    // 最終的な署名者の結果に干渉する可能性がある。
    signers: []string{"A", "B", "C", "D", "E"},
    blocks:  []block{
      {signer: "A", voted: "F", auth: true}, // Fを承認、3票必要
      {signer: "B", voted: "F", auth: true},
      {signer: "C", voted: "F", auth: true},
      {signer: "D", voted: "F", auth: false}, // Fを非承認、4票必要(Aの以前の投票を"変更しない")
      {signer: "E", voted: "F", auth: false},
      {signer: "B", voted: "F", auth: false},
      {signer: "C", voted: "F", auth: false},
      {signer: "D", voted: "F", auth: true}, // Fをほぼ承認、2/3票必要
      {signer: "E", voted: "F", auth: true},
      {signer: "B", voted: "A", auth: false}, // Aを非承認、3票必要
      {signer: "C", voted: "A", auth: false},
      {signer: "D", voted: "A", auth: false},
      {signer: "B", voted: "F", auth: true}, // Fの承認を完了、3/3票必要
    },
    results: []string{"B", "C", "D", "E", "F"},
  }, {
    // エポック遷移では、チェーンのチェックポイントを可能にするため、すべての投票がリセットされる
    epoch:   3,
    signers: []string{"A", "B"},
    blocks:  []block{
      {signer: "A", voted: "C", auth: true},
      {signer: "B"},
      {signer: "A", checkpoint: []string{"A", "B"}},
      {signer: "B", voted: "C", auth: true},
    },
    results: []string{"A", "B"},
  }, {
    // 非承認された署名者はブロックを署名できるべきではない
    signers: []string{"A"},
    blocks:  []block{
      {signer: "B"},
    },
    failure: errUnauthorizedSigner,
  }, {
    // 最近署名した承認された署名者は再び署名できるべきではない
    signers: []string{"A", "B"},
  blocks []block{
      {signer: "A"},
      {signer: "A"},
    },
    failure: errRecentlySigned,
  }, {
    // バッチでインポートされたチェックポイントブロックでも、最近の署名は
    // リセットされるべきではない
    epoch:   3,
    signers: []string{"A", "B", "C"},
    blocks:  []block{
      {signer: "A"},
      {signer: "B"},
      {signer: "A", checkpoint: []string{"A", "B", "C"}},
      {signer: "A"},
    },
    failure: errRecentlySigned,
  },,
}
```

## 実装

参考実装は[go-ethereum](https://github.com/ethereum/go-ethereum/tree/master/consensus/clique)の一部であり、2017年4月以来、[Rinkeby](https://www.rinkeby.io)テストネットのコンセンサスエンジンとして機能しています。
## 著作権
著作権およびその関連権利は[CC0](../LICENSE.md)で放棄されています。