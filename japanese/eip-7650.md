---
original: f0123feb9154e5ef3bae1fece4cc2842b7dfaaed40cd5a5b73810a73d2c69532
---

---
eip: 7650
title: プログラマブルアクセスリスト
description: アクセスリストをプログラム的に追加するプリコンパイルドコントラクトを追加する
author: Qi Zhou (@qizhou), Zhiqiang Xu (@zhiqiangxu)
discussions-to: https://ethereum-magicians.org/t/eip-7650-programmable-access-lists/19159
status: Draft
type: Standards Track
category: Core
created: 2024-03-10
requires: 2929, 2930
---

## 概要

`prefetch`と呼ばれる新しいプリコンパイルドコントラクトを導入します。このコントラクトは`accessList`を受け入れます。

`accessList`は、アドレスとローカルストレージキーのリストを指定します。これらのアドレスとローカルストレージキーは、[EIP-2929](./eip-2929.md)で導入された`accessed_addresses`と`accessed_storage_keys`のグローバルセットに追加されます。[EIP-2930](./eip-2930.md)と同様に、このプリコンパイルを介してデータをプリフェッチすると、ガス料金が課金されますが、リスト外のアクセスと比べて低減されます。

## 動機

このEIPの主な目的は、EIP-2930を拡張し、コントラクトがアクセスリストをプログラム的に追加できるようにすることです。コントラクト内にこのプリコンパイルを実装することの利点は、ほとんどのノードが持つ並行コンピューティングとIOを活用して、データアクセス操作のガス代を持続的に削減できることです。

## 仕様

この文書の「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、「OPTIONAL」のキーワードは、RFC 2119で説明されているように解釈されるものとします。

### パラメータ

| 定数                      | 値 |
| ----------------------------- | ----- |
| `FORK_BLOCK_NUMBER`                 | `TBD` |
| `PREFETCH_PRECOMPILE_ADDRESS` | `TBD` |
| `CONCURRENCY`                 | `TBD` |

`FORK_BLOCK_NUMBER`以降、新しいプリコンパイルが`PREFETCH_PRECOMPILE_ADDRESS`にデプロイされます。プリコンパイルの入力エンコーディングは次のようになります:

```text
[ローカルストレージキーの長さnの32バイト][n * 32バイトのローカルストレージキー][アドレスの長さmの32バイト][m * 32バイトのアドレス]
```

呼び出しの開始時に、`2100 * (N + CONCURRENCY - 1) // CONCURRENCY + 2600 * (M + CONCURRENCY - 1) // CONCURRENCY`をチャージします。ここで`//`は整数除算演算子、`N`は`accessed_storage_keys`グローバルセットにないローカルストレージキーの数、`M`は`accessed_addresses`グローバルセットにないアドレスの数です。クライアントは、キーとアドレスを並行して読み取り、`accessed_addresses`と`accessed_storage_keys`のグローバルセットにキーとアドレスを格納する必要があります。ストレージキーとアドレスの以降の読み取りコストは、[EIP-2929](./eip-2929.md)で定義された`WARM_STORAGE_READ_COST`に従います。

### 例

UniswapV2の`swap()`関数を例として使用します:

```
    // この低レベルの関数は、重要な安全性チェックを実行するコントラクトから呼び出される必要があります
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock {
        prefetch {
             token0.slot,
             token1.slot,
             reserve0.slot,
             price0CumulativeLast.slot,
             price1CumulativeLast.slot,
        } // `accessed_storage_keys`にストレージキーを追加する
        prefetch {
             token0,
             token1,
        } // `accessed_addresses`にtoken0とtoken1のコントラクトを追加する
        ...
    }
```

## 根拠

### アクセスリスト内のアクセスに対してより少ないチャージ

EIP-2930と同様に、ノードに一定の並行処理能力(例えば、いくつかのコアとIOバンド幅)があることを前提として、可能な限り`prefetch`プリコンパイルを使用することを奨励します。

### 重複を許可する

EIP-2930と同様に、簡単さを最大限に高めるために、リストの重複を許可します。

### 外部コントラクトのストレージキーはない

EIP-2930とは異なり、`prefetch`プリコンパイルはローカルストレージキーとアドレスのみを受け入れます。外部コントラクトのストレージキーのデータをプリフェッチすると、コントラクトが外部コントラクトのストレージレイアウトを知っている必要があり、これは良い慣行ではない可能性があります。ノードの並行性をより良く活用するために、プリコンパイルは外部コントラクトの静的呼び出しのリストとともにコールデータを受け入れる可能性があります。この作業は、将来のEIPで行われる可能性があります。

## 下位互換性

EIPがまだ実装されていない場合、プリコンパイルを呼び出すコントラクトは何も操作しないはずです。

## セキュリティ上の考慮事項

セキュリティ上の懸念は見つかりませんでした。

## 著作権

著作権およびそれに関連する権利は[CC0](../LICENSE.md)で放棄されています。