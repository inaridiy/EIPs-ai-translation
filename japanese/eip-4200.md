---
original: 2c1f5cb6926b0ebbe74d8306d601f5ce170acda70193744d76636c879a803133
---

---
eip: 4200
title: EOF - 静的相対ジャンプ
description: 符号付き即値でジャンプ先を表すRJUMP、RJUMPIおよびRJUMPV命令
author: Alex Beregszaszi (@axic)、Andrei Maiboroda (@gumb0)、Paweł Bylica (@chfast)
discussions-to: https://ethereum-magicians.org/t/eip-3920-static-relative-jumps/7108
status: Review
type: Standards Track
category: Core
created: 2021-07-16
requires: 3540, 3670
---

## 概要

(`RJUMP`、`RJUMPI`、`RJUMPV`)の3つの新しいEVMジャンプ命令が導入されます。これらは符号付き即値でジャンプ先を表します。大部分のユースケース(ただし全てではない)で有用であり、コストの削減も期待できます。

## 動機

EVMには動的ジャンプのメカニズムしかないという話題が繰り返し議論されてきました。これは非常に柔軟なアーキテクチャを実現していますが、コードの解析を複雑にし、`JUMPDEST`マーカーの必要性の一因にもなっています。

多くの場合、制御フローは実際には静的であり、動的な動作は必要ありません。ただし、すべてのユースケースを静的ジャンプで解決できるわけではありません。

動的ジャンプの必要性を減らす方法はいくつかあります。例えば:

1. ネイティブの関数/サブルーチンのサポート
2. "呼び出し元に戻る"命令
3. 動的インデックスを使った"switch-case"テーブル

本変更は これらの問題を解決するものではありませんが、コンパイラが各ユースケースに最適な選択ができるよう、最小限の機能セットを導入します。コンパイラは`RJUMP`/`RJUMPI`をほぼ排他的に使用し、呼び出し元に戻る場合のみ`JUMP`を使用すると期待されます。

この機能は、EVMが後に他の形式の制御フローを導入することを妨げるものではありません。`RJUMP`/`RJUMPI`は、関数の宣言といった高レベルの制御フロー機構と効率的に共存できます。その場合、静的相対ジャンプは関数内部の制御フローに使用されます。

これらの命令の主な利点は、ガスコストの削減(デプロイ時と実行時の両方)と、より良い解析特性です。

## 仕様

[EIP-3540](./eip-3540.md)が有効になった同じブロック番号で、以下の3つの新しい命令を導入します:

1. `RJUMP` (0xe0) - 相対ジャンプ
2. `RJUMPI` (0xe1) - 条件付き相対ジャンプ
3. `RJUMPV` (0xe2) - ジャンプテーブルを使った相対ジャンプ

レガシーバイトコードの場合、これらの命令はすべて*例外的な停止*を引き起こします。(*注: これは動作の変更はありません。*)

EOF1の有効なコードの場合:

1. `RJUMP relative_offset`は`PC`を`PC_post_instruction + relative_offset`に設定します。
2. `RJUMPI relative_offset`はスタックからの値(`condition`)をポップし、`PC`を`PC_post_instruction + ((condition == 0) ? 0 : relative_offset)`に設定します。
3. `RJUMPV max_index relative_offset+`はスタックからの値(`case`)をポップし、`PC`を`PC_post_instruction + ((case > max_index) ? 0 : relative_offset[case])`に設定します。

即値引数`relative_offset`は16ビットの**符号付き**(2の補数)ビッグエンディアン値でエンコードされます。`PC_post_instruction`とは、即値全体の後の`PC`位置を意味します。

`RJUMPV`の即値エンコーディングはより特殊です。unsigned 8ビットの`max_index`値は、ジャンプテーブルの最大インデックスを決定します。その後に続く`relative_offset`値の数は`max_index+1`個です。これにより、最大256までのテーブルサイズをサポートできます。`RJUMPV`のエンコーディングには少なくとも1つの`relative_offset`が必要なため、最小で4バイトになります。さらに、`case > max_index`の条件がフォールスルーする場合、多くのユースケースでは`RJUMPV`命令の後に*デフォルト*パスを置くことになります。興味深い機能として、`RJUMPV 0 relative_offset`は反転`RJUMPI`であり、多くのケースで`ISZERO RJUMPI relative_offset`の代わりに使用できます。

また、[EIP-3670](./eip-3670.md)のバリデーションアルゴリズムを拡張して、各`RJUMP`/`RJUMPI`/`RJUMPV`が命令を指すように`relative_offset`を持つことを検証します。つまり、即値データ(`PUSHn`/`RJUMP`/`RJUMPI`/`RJUMPV`)を指すことはできません。コード範囲外を指すこともできません。`JUMPDEST`を指すことは許可されていますが、必須ではありません。

これらの命令の宛先が事前に検証されるため、動的な対応部分よりもコストが低くなります。`RJUMP`は2、`RJUMPI`と`RJUMPV`は4のコストになるはずです。

## 根拠

### 相対アドレッシング

リロケータブルなコードをサポートするため、相対アドレッシングを選択しました。これにより、コードスニペットを挿入することもできます。この目的を達成するために、この EIP 以前に使われていた手法は、`PUSHn PC ADD JUMPI`のようなコードを挿入することでした。

相対アドレッシングには大きな欠点はなく、`PC`命令の非推奨化も可能になります。

### 即値サイズ

符号付き16ビットの即値では、最大ジャンプ距離は32767です。`PC=0`からの`RJUMP`で始まるバイトコードの場合、`PC=32770`まで飛べます。

[EIP-170](./eip-170.md)の`MAX_CODE_SIZE = 24576`と[EIP-3860](./eip-3860.md)の`MAX_INITCODE_SIZE = 49152`を考えると、16ビットの即値は十分な大きさだと考えています。

8ビットの即値では、`PC`を125バイト後ろに、または127バイト前に移動できるだけです。多くのfor-loopには十分かもしれませんが、関数間ジャンプには不十分でしょう。一方、そのような場合の動的ジャンプには3バイト(`JUMP PUSH1 n`)が必要なので、命令数が少ないことが好ましいと考えています。

他のサイズ(8ビット、24ビット、32ビットなど)の即値エンコーディングが必要になった場合は、`PUSH`命令の複数形式のように、新しいオペコードを導入することができます。

### `PUSHn JUMP`シーケンス

絶対アドレッシングを選択した場合、`RJUMP`は`PUSHn JUMP`(そして`RJUMPI`は`PUSHn JUMPI`)と同様に見なすことができます。その場合、新しい命令を導入するのではなく、そのようなシーケンスにディスカウントを適用すべきだと主張できるかもしれません。

これは良い方向性ではないと考えています:

1. ガス計算の複雑なルールをさらに複雑化してしまう。
2. EVMの内部表現に関するコンセンサス定義が必要になるか、EVMの実装に最適化を強制することになる。

これらは両方とも危険です。さらに、EVMの実装は最適化を自由に選択できるべきであり、その節約分を必ずしも下位に伝える必要はないと考えています。

また、ストリーミングの1命令ずつの実行方式に依存する現在の実装に、大幅な変更が必要になる可能性があります。

### 動的ジャンプとの関係

目的は、現在のEVMの制御フローシステムを完全に置き換えることではなく、それを補完することでした。動的ジャンプは、呼び出し元に戻るなどの多くのケースで有用です。

有効なジャンプ先のテーブルを事前に定義し、そのテーブル内のインデックスを動的に供給することで、ある種の動的ジャンプを実現する新しいメカニズムを導入することも可能です。これは"switch-case"文を効率的にエンコーディングするのに非常に有用です。"呼び出し元に戻る"ケースにも使用できますが、効率的または使いやすいとは限りません。

### `JUMPDEST`の欠如

`JUMPDEST`には2つの目的があります:

1. コードを効率的に分割すること - これは、特定の*ブロック*(つまり`JUMPDEST`間の命令)のガス使用量を事前に計算したり、JIT/AOT変換に役立つ。
2. 有効な位置を明示的に示すこと - そうでなければ、データ以外のすべての場所が有効になる。

この機能は静的ジャンプには不要です。解析器は静的ジャンプの即値から、ジャンプ先を簡単に特定できるためです。

ここには2つの利点があります:

1. `JUMPDEST`バイトを無駄にしないことで、デプロイ時に各ジャンプ先で200ガスを節約できる。
2. ジャンプ時に`JUMPDEST`自体が1ガスかかるので、実行時に1ガスを節約できる。

### `RJUMPV`のフォールバックケース

`RJUMPV`命令の実行時に一致するものが見つからない(つまり*デフォルト*ケース)場合、分岐せずに実行を継続します。これにより、引数の間に隙間を設けたり、プログラマーの実装選択の自由度を高めることができます。代替案としては、一致するものがない場合に例外的な中断を行うことも考えられます。

## 後方互換性

この変更は[EIP-3540](./eip-3540.md)と同時に導入されるため、後方互換性のリスクはありません。新しい命令はレガシーバイトコード(EOF形式ではないコード)では導入されません。

## テストケース

### 検証

#### 有効なケース

- `JUMPDEST`をターゲットとする`RJUMP`/`RJUMPI`/`RJUMPV`
    - `relative_offset`が正/負/`0`
- `JUMPDEST`以外の命令をターゲットとする`RJUMP`/`RJUMPI`/`RJUMPV`
    - `relative_offset`が正/負/`0`
- 1から256までの様々な有効なテーブルサイズの`RJUMPV`
- コードセクションの最終命令としての`RJUMP`

#### 無効なケース

- 即値が切り捨てられた`RJUMP`/`RJUMPI`/`RJUMPV`
- コードセクションの最終命令としての`RJUMPI`/`RJUMPV`
- コード範囲外を指す`RJUMP`/`RJUMPI`/`RJUMPV`
- 即値データを指す`RJUMP`/`RJUMPI`/`RJUMPV`
- 別の`RJUMP`/`RJUMPI`/`RJUMPV`の即値引数を指す`RJUMP`/`RJUMPI`/`RJUMPV`

### 実行

- レガシーコードの`RJUMP`/`RJUMPI`/`RJUMPV`は実行を中断する
- `RJUMP`
    - `relative_offset`が正/負/`0`
- `RJUMPI`
    - `relative_offset`が正/負/`0`
        - `condition`が`0`
        - `condition`が`0`以外
- `RJUMPV 0 relative_offset`
    - `case`が`0`
    - `case`が`0`以外
- 正/負/`0`のオフセットを含むテーブルを持つ`RJUMPV`
    - `case`が`0`
    - `case`が`0`以外
    - `case`がテーブル範囲外(`case > max_index`, フォールバックケース)
    - `case`が255を超える

## セキュリティ上の考慮事項

TBA

## 著作権

著作権およびそれに関連する権利は[CC0](../LICENSE.md)で放棄されています。