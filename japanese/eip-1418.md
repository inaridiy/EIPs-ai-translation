---
original: bfd464e593d9e8aeffe9778e7cf751c93f3c41b38b3618878831e330921e296e
---

---
eip: 1418
title: ブロックチェーンストレージレント支払い
description: 各ブロックで、そのアカウントが使用するストレージ量に基づいて、すべてのアカウントから値を差し引きます。
author: William Entriken (@fulldecent)
discussions-to: https://ethereum-magicians.org/t/eip-1418-storage-rent/10737
status: 停滞
type: Standards Track
category: Core
created: 2018-09-16
requires: 1559
---

## 概要

各ブロックで、そのアカウントが使用するストレージ量に基づいて、すべてのアカウントから値("レント")を差し引きます。

## 動機

Ethereumは公共インフラであり、ストレージの長期コストを過小評価しています。ストレージコストは、およそバイト数×時間で近似的にモデル化できます。

## 仕様

**更新されたトランザクションタイプ**

新しいトランザクションタイプが導入されます。[EIP-1559](./eip-1559.md)がコントラクトの状態に対する温かいアクセスを導入したのに対し、この新しいタイプはコントラクトコードに対する温かいアクセスを導入します。

**新しい状態変数(アカウントごと)**

* **σ[a]_rent** -- Wei単位の値の量、符号付き値
* **σ[a]_storageWords** -- ストレージ内のワード数

**新しい定数**

* **`RENT_WORD_COST`** -- 1ワード-ブロックあたりのレント料金(Wei)
* **`RENT_ACCOUNT_COST`** -- 1アカウント-ブロックあたりのレント料金(Wei)
* **`FORK_BLOCK`** -- 実装開始時期

**新しいオペコード**

* **`RENTBALANCE(address)`** -- G_BALANCE -- `BALANCE`に似ています
  * これは論理的な`σ[a]_rent`値を返します。これは、毎ブロック毎アカウントの`σ[a]_rent`を格納・更新するのではなく、推奨される実装変数を使って計算することができます。
* **`SENDRENT(address, amount)`** -- G_BASE -- 値をレントに変換してアカウントに送信する
  1. `σ[account]_rent` += amount
  2. `σ[msg.sender]_balance` -= amount

**更新されたオペコード**

レントの支払いのための新しいサブルーチンが以下のように確立されます:

```pseudocode
PAYRENT(account)
    blocks_to_pay = NUMBER - σ[account]_rentLastPaid
    cost_per_block = RENT_ACCOUNT_COST + RENT_WORD_COST * (⌈∥σ[account]_code∥ / 32⌉ + * σ[a]_storageWords)
    rent_to_pay = blocks_to_pay * cost_per_block
    σ[account]_rent -= rent_to_pay
    if σ[account]_rent < 0
    		σ[account]_value += σ[account]_rent
    		σ[account]_rent = 0
    end
    if σ[account]_value < 0
    		σ[account]_rent = σ[account]_value
    		σ[account]_value = 0
    end
    σ[account]_rentLastPaid = NUMBER
    σ[account]_rentEvictBlock = NUMBER + ⌊σ[account]_rent / cost_per_block⌋
END PAYRENT
```

* **`SSTORE(account, key, value)`**
  * `PAYRENT(account)`を実行する
  * `account`が退出された場合(つまり`NUMBER` > `σ[account]_rentEvictBlock`)、新しいトランザクションタイプを使用し、古いストレージルートを検証し新しいルートを計算するための十分な証明が含まれていない限り、トランザクションは失敗する
  * 通常の`SSTORE`操作を行う
  * この[account, key]の古い値がゼロで新しい値が非ゼロの場合、`σ[account]_storageWords++`
  * この[account, key]の古い値が非ゼロで新しい値がゼロの場合、`σ[account]_storageWords--`、結果がマイナスの場合はゼロに設定する
* **`SLOAD(account, key)`**
  * `account`が退出された場合(つまり`NUMBER` > `σ[account]_rentEvictBlock`)、新しいトランザクションタイプを使用し、既存のストレージルートと既存のストレージ値を検証するための十分な証明が含まれていない限り、トランザクションは失敗する
  * 通常の`SLOAD`操作を行う
* **`CALL (and derivatives)`**
  * ターゲットブロックが退出された場合(つまり`NUMBER` > `σ[account]_rentEvictBlock`)、新しいトランザクションタイプを使用し、既存のコードを検証するための十分な証明が含まれていない限り、トランザクションは失敗する
  * 通常の`CALL`操作を行う
* **`CREATE`**
  * `σ[account]_rentLastPaid = NUMBER`を設定する
  * 通常の`CREATE`操作を行う
  * `σ[account]_storageWord = 0`
  * 注: ここに既存のレント残高がある可能性がある

**新しい組み込みコントラクト**

* `PAYRENT(address, amount)` -- `PAYRENT`オペコードを呼び出す
  * これは人間がEtherをアカウントから送金し、それをレントに変換するための便利なものです。単純なアカウント(CODESIZE == 0)は任意のオペコードを呼び出すことはできず、CREATE またはCALLのみ呼び出すことができます。
  * `PAYRENT`のガスコストは10,000以下になる予定です。

**既存のアカウントの`σ[account]_storageWord`の計算**

DRAFT...

フォークブロックでアーカイブノードのみが参加し、各アカウントの完全なストレージ量を知っている必要がある場合は、許容できるアップグレードではありません。

新しいトランザクション活動に基づいて`σ[account]_storageWord`を増分的に計算(または推定)できる場合は、許容できるアップグレードになります。

DRAFT: 偏りのない推定量を使ってそのような許容できるアップグレードを行うことができると思います

* レガシーアカウントの最初のキーアクセス時に、`SSTORE`ごとに1ビットのストレージを追加する
* 各トライレベルごとにlog(n)ビットを追加する
* ストレージキーがランダム変数であると仮定する

さらに検討が必要...

**現在のオペコードのガスコストに変更はありません。**

## 根拠

**呼び出しなし**

コントラクトはレントの受け取りを知ったり反応したりすることはできません。これは問題ありません。回避策: 契約がレント支払いの帰属を知る必要がある場合は、ABIに機能を作成して支払いを属性付けできます。`SELFDESTRUCT`を使用して、帰属なしで支払いを送信することは既に可能です。TRONなどの他のブロックチェーンでは、呼び出しを行わずにコントラクトに値を転送できます。

**退出の責任/遅延評価**

仕様では、退出の責任をコンセンサスクライアントに与えています。これが最も予測可能な動作です。なぜなら、退出は正確に必要なときに発生するからです。また、外部参加者(オフチェーン)がアカウントを監視し、削除を要求するためのインセンティブメカニズム(ガス払い戻し、バウンティ)は必要ありません。

1ブロックで任意の数のアカウントが退出される可能性があります。それは問題ありません。クライアントの実装では、どのアカウントが退出されたかを追跡する必要はありません。アカウントが退出される条件に合意さえすれば、コンセンサスが達成されます。

**レントを価値に変換しない**

Etherをレントに変換することはできませんが、逆はできません。ギフトカードについて知っている会計の人なら、これが良いアイデアだと言うでしょう。これにより、システムの推論が容易になります。

**アカウントがレントを支払う**

はい、アカウントがレントを支払います。残高を管理するのにリソースがかかるので、レントを課金します。

**なぜ別のレントアカウントが必要ですか?**

誰でも/誰もがレントアカウントに貢献できるからです。契約に依存している場合は、そのレントに貢献する必要があります。

しかし、契約はすべての価値を使い果たすことができます。

レントと価値の残高を別々に管理することで、契約の存続を可能にするためにレントに貢献できるという確信を持つことができます。

注: クローン作成。このEIPにより、ストレージのクローンを許可することが実現可能になるかもしれません。はい、本当です。新しいクローンがレントを支払うからです。他のEIP(Augurチームが作成したと思われるもの)を参照してください。

### 経済性と定数

2015年に実行された`SSTORE`は20,000ガスを消費し、約600万ブロック生き残っています。ガス価格は1 ~ 50 Gweiの範囲にありました。つまり、これまでのところ1ワードあたり4,000 Weiほどです。アカウントを保存するのは単語を保存するよりも10倍集約的かもしれません。しかし実際、`G_transaction`は21,000で`G_sstore`は20,000なので、これらはよく似ており、どちらも新しいアカウント/ワードを作成できます。

では、以下のようにしてはどうでしょうか:

* `RENT_WORD_COST` -- 4,000 Wei
* `RENT_ACCOUNT_COST` -- 4,000 Wei
* `FORK_BLOCK` – 実装開始時期

レントは冷たい硬貨のEtherで価格付けされます。クライアントによって交渉されるものではなく、動的ではありません。

将来のEIPでは、この価格設定を動的にする可能性があります。例えば、ブロックを認証するためには、ノータリーが現在のストレージデータセット(退出を除く)を持っていることを証明する必要があるかもしれません。さらに、追加の料金を稼ぐために、退出されたアカウントのストレージと他のアカウントのストレージの相対的な量、および追加の料金の価値を使って、ストレージの市場価格を設定するフィードバックメカニズムを使うこともできます。

参考までに、Ethereumメインネットのデータセットには約150億ワード、総発行量は約1億Etherです。つまり、すべてのEtherがこの提案の現在の価格でストレージに使われた場合、400テラバイト-年分のストレージになります。これがどの程度有用かはわかりません。

## 下位互換性

EIP-1559は、ノードがネットワーク全体の状態を記録せずに参加したり、クライアントがタイプ2トランザクションでストレージデータをウォームキャッシュしたりする仕組みを既に導入しています。

ユーザーの教育が必要です。

多くのスマートコントラクトでは、誰でも任意の量のストレージを使うことができます。これにより、既存のチェーンでこの提案を展開する有用性が制限される可能性があります。

**推奨される実装変数(アカウントごと)**

* **σ[a]_rentLastPaid** -- 以下の場合に設定されるブロック番号:
  * アカウントに値が転送された(`CREATE`、`CALL`、`SELFDESTRUCT`)
  * アカウントのコードが設定された(`CREATE`)
  * アカウントのストレージが更新された(`SSTORE`)
  * すべてのアカウントの初期値は`FORK_BLOCK`

* **σ[a]_rentEvictBlock** -- このアカウントが退出されるブロック番号

**ストレージに関する注意**

退出されたすべてのアカウントについて、クライアントはそのストレージをディスクから削除することを選択できます。将来のEIPでは、この追加データを料金で保持するインセンティブが設けられる可能性があります。また、クライアント間でこれらのストレージ状態を交換するメカニズムが作られる可能性もあります。

## セキュリティ上の考慮事項

多くのスマートコントラクトでは、誰でも任意の量のストレージを使うことができます。

## 著作権

著作権およびそれに関連する権利はCC0で放棄されています。

<!--

 ## TODO

 議論すべき事項:

 - 過去のレント未払いを支払うことで、退出されたアカウントを再度有効化することはできる/すべきか?
   -->