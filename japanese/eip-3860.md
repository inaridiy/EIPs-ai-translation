---
original: 45711cd275e89913f2225b5d118162d6eed9d011ec1b3f0c3fe9fede28bbe8ad
---

---
eip: 3860
title: initcodeの制限とメーター
description: initcodeの最大サイズを49152に制限し、initcodeの32バイトチャンクごとに2ガスの追加コストを適用する
author: Martin Holst Swende (@holiman), Paweł Bylica (@chfast), Alex Beregszaszi (@axic), Andrei Maiboroda (@gumb0)
discussions-to: https://ethereum-magicians.org/t/eip-3860-limit-and-meter-initcode/7018
status: Final
type: Standards Track
category: Core
created: 2021-07-16
requires: 170
---

## 概要

[EIP-170](./eip-170.md)を拡張し、`initcode`の最大サイズ制限(`MAX_INITCODE_SIZE = 2 * MAX_CODE_SIZE = 49152`)を導入します。

さらに、jumpdest解析のコストを表すために、`initcode`の32バイトチャンクごとに`2`ガスの課金を導入します。

最後に、サイズ制限により、EVMコードサイズ、コードオフセット(`PC`)、ジャンプオフセットが16ビット値に収まるという便利な特性が得られます。

## 動機

コントラクト作成時、クライアントは`initcode`に対してjumpdest解析を実行する必要があります。この処理の負荷は`initcode`のサイズに比例して増加します。現在、この処理のコストは計測されておらず、プロトコルレベルでの上限もありません。

現在、以下の3つのコストが課金されています:

1. `initcode`のデータコスト: ゼロの場合4ガス、それ以外の場合16ガス。
2. 展開されたコードのコスト: 1バイトあたり200ガス。
3. `CREATE2`の場合のアドレス計算(コードのハッシング)コスト: 1ワードあたり6ガス。

1つ目のコストのみが`initcode`に適用されますが、それも契約作成トランザクションの場合のみです。`CREATE`/`CREATE2`の場合、そのようなコストはなく、`initcode`の変形を安価に生成することができます。2017年にgeth 1.6.5で修正された脆弱性により、以前は悪意のある`initcode`を作成することができました。

さらに、上限がないことで、一部のEVMの提案に関する長い議論が引き起こされ、設計に影響を与えたり、機能の遅延や中止を招いたりしてきました。

私たちには以下の3つの動機があります:

1. `initcode`に対して適切な課金を行い(特に長さに比例したコスト)、将来のリスクを最小限に抑えること。
2. 将来的に拡張可能なコストシステムを持つこと。
3. コードサイズ、コードオフセット(`PC`)、ジャンプオフセットが16ビットに収まるという明示的な制限によって、EVMエンジンを簡素化すること。

## 仕様

### パラメータ

| 定数                | 値                  |
| -------------------- | ------------------- |
| `INITCODE_WORD_COST` | `2`                 |
| `MAX_INITCODE_SIZE`  | `2 * MAX_CODE_SIZE` |

ここで、`MAX_CODE_SIZE`は[EIP-170](./eip-170.md)で定義されている`24576`です。

`initcode_cost(initcode)`を`INITCODE_WORD_COST * ceil(len(initcode) / 32)`と定義します。

### ルール

1. 作成トランザクションのデータ(`initcode`)の長さが`MAX_INITCODE_SIZE`を超える場合、そのトランザクションは無効となります。(*これは、内部ガスコスト要件を満たさないトランザクションが無効とみなされるのと同様です。*)
2. 作成トランザクションについて、トランザクションデータコストの計算式に`initcode_cost(initcode)`を含めます。(*これは、トランザクション固有のコストに含まれるため、initcodeコストをカバーするガスが不足している場合、トランザクションは無効となります。*)
3. `CREATE`または`CREATE2`命令の`initcode`の長さが`MAX_INITCODE_SIZE`を超える場合、命令の実行が例外的に中止されます(ガス切れと同様)。
4. `CREATE`および`CREATE2`命令に対して、`initcode_cost(initcode)`に相当するガスコストを追加で課金します。この費用は、結果のコントラクトアドレスの計算と`initcode`の実行の前に差し引かれます。(*これは、`CREATE2`でハッシングコストが適用される前または同時に行われることを意味します。*)

## 根拠

### ガスコスト定数

`INITCODE_WORD_COST`の値は、各実装の最悪ケースのベンチマーク結果に基づいて選択されています。ベースラインは、geth 1.10.9の`KECCAK256`ハッシングのパフォーマンスで、4.0 GHz x86_64 CPUで70 Mgas/sのガス制限目標に一致します。

| EVM             | version | MB/s | B/CPUcycle | CPUcycle/B | cost of 1 B | cost of 32 B |
| --------------- | ------- | ---- | ---- | ---- | ---- | ---- |
| geth/KECCAK256  | 1.10.9  |  357 |  1.8 |  0.6 |  0.2 |  6.0 |
| geth            | 1.10.9  | 1091 |  5.5 |  0.2 |  0.1 |  2.0 |
| evmone/Baseline | 0.8.2   |  727 |  3.7 |  0.3 |  0.1 |  2.9 |
| evmone/Advanced | 0.8.2   |  155 |  0.8 |  1.3 |  0.4 | 13.8 |

### 1ワード(32バイトチャンク)あたりのガスコスト

gethの実装と`KECCAK256`のパフォーマンスを比較して、1ワードあたり2ガスのコストを選択しました。これは、1バイトあたりのコストが`0.0625`になります。EVMでは小数のガスコストは許可されていませんが、1ワードごとに課金することで近似できます。

さらに、1ワードごとのガス計算は、[EIP-1014](./eip-1014.md)の`CREATE2`の*ハッシュコスト*の計算と互換性があります。したがって、同じ実装を`CREATE`と`CREATE2`で使用できますが、コスト定数が異なります: 適用前は`CREATE`が`0`、`CREATE2`が`6`、適用後は`CREATE`が`2`、`CREATE2`が`6 + 2`となります。

### initcodeのサイズ制限の理由

最悪のシナリオを推定および作成するには、1つのパラメータが大幅に減少するため、上限があると容易になります。上限がない場合、未知の要因を考慮して、より保守的なコストを設定する必要があります。(*TODO: メインネットで見られる最大initcodeサイズの結果を記載する*)ほとんどの場合、提案された制限を超えないため、契約に過度に保守的なコストを課すのは不要と思われます。

### initcodeのサイズ制限の影響

ほとんどの場合、新しいコントラクトが作成される際、実行時コードはinitcode自体からコピーされます。基本的なケースでは、`2 * MAX_CODE_SIZE`の制限により、実行時コードに`MAX_CODE_SIZE`、コントラクトのコンストラクターコードにもう`MAX_CODE_SIZE`を使用できます。ただし、単一の作成トランザクションで複数のコントラクトをデプロイする場合、この制限に実際の影響がある可能性があります。

### 作成トランザクションのinitcodeコスト

作成トランザクションデータのinitcodeコスト(1バイトあたり0.0625ガス)は、トランザクションデータコスト(1バイトあたり4または16ガス)に比べて微々たるものです。それにもかかわらず、一貫性と、より重要な将来の拡張性のために、仕様に含めることにしました。

### initcode制限違反の報告方法

`CREATE`/`CREATE2`でのinitcode制限違反は、実行の例外的な中止につながると指定しました。これにより、スタックアンダーフロー、メモリ拡張、静的呼び出し違反、initcodeハッシングコスト、およびこのEIPで導入されたinitcodeコストなどの早期のガス切れチェックと同じグループに属することになります。これらは、後の「軽量」チェック(呼び出し深さとバランス)に先行します。この選択により、チェックの順序の一貫性が保たれ、実装の複雑さが低減されます(ガス切れチェックは任意の順序で実行できます)。

## 下位互換性

このEIPは「ネットワークアップグレード」を必要とするため、コンセンサスルールを変更します。

すでにデプロイされているコントラクトには影響はありませんが、(提案された制限を超える`initcode`を持つ)特定のトランザクションは、ブロックに含めることができますが、例外的に中止されます。

## テストケース

以下のようなテストケースを含める必要があります:

- initcodeコストをカバーするガス制限が十分なコントラクト作成トランザクション
- initcodeコストを除く固有コストをカバーするガス制限が十分なコントラクト作成トランザクション
- `len(initcode)`が`MAX_INITCODE_SIZE`の`CREATE`/`CREATE2`/作成トランザクション
- `len(initcode)`が`MAX_INITCODE_SIZE+1`の`CREATE`/`CREATE2`/作成トランザクション

## セキュリティ上の考慮事項

クライアント実装については、このEIPによりjumpdest解析に基づく攻撃が問題になりにくくなるため、クライアントの堅牢性が向上します。

レイヤー2については、このEIPにより、以前はなかった障害モードが導入されます。複数レベルのコントラクト階層を展開するファクトリーコントラクトが存在する可能性があり、その場合、最初のコントラクトのinitcodeに複数のコントラクトのコードが含まれることがあります。本EIPの著者(ら)はそのようなコントラクトを認識していません。

現在のLondonでは、`30M`ガス制限で、合計`~1.3GB`のinitcodeのjumpdest解析を引き起こすことができます。このEIPにより、そのような攻撃のコストは約`80M`ガス増加します。

## 著作権

著作権およびその関連権利は[CC0](../LICENSE.md)で放棄されています。