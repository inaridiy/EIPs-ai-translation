---
original: b40b44136f6b823cb19663b19f44b62b05d2c7551e8c51550ddef0fdba5e4a2a
---

---
eip: 2330
title: EXTSLOAD オペコード
description: 外部コントラクトのストレージデータを読み取るための新しいEVMオペコード。
author: Dominic Letz (@dominicletz)、Santiago Palladino (@spalladino)
discussions-to: https://ethereum-magicians.org/t/eip-2330-extsload-and-abi-for-lower-gas-cost-and-off-chain-apps/3733
status: 停滞
type: Standards Track
category: Core
created: 2019-10-29
requires: 2929
---

## 概要

このプロポーザルは、`0x5c`に新しいオペコード`EXTSLOAD`を追加します。このオペコードはスタックから2つのアイテム、`<アカウントアドレス> <ストレージキー>`をポップし、1つのアイテム`<ストレージ値>`をプッシュします。ガスコストは、[EIP-2929](./eip-2929.md) アクセスリストに基づいたアカウントアクセスコストとストレージ読み取りコストの合計です。

## 動機

オフチェーンアプリケーションはすべてのコントラクトのすべてのコントラクトストレージデータを読み取ることができますが、デプロイされたスマートコントラクト自体ではこれは不可能です。これらは、他のコントラクトからデータを読み取るための任意の相互作用を含む、コントラクトコールを使用する必要があります。このEIPは、EVM オペコードを追加して、外部コントラクトストレージを直接読み取ることができます。

[EIP-20](./eip-20.md)、ENS、およびその他のデータコントラクトなどのレジストリスタイルのコントラクトからの読み取りのガスコストは非常に高くなります。これは、クロスコントラクトコールコスト、ABIエンコーディング、デコーディング、ディスパッチのコスト、最後にデータの読み取りのコストが発生するためです。多くの場合、照会されているストレージは単純なマッピングにすぎません。さらに、ビュー関数は呼び出し側が関心のない他の多くのスロットをSLOADする可能性があり、これによりガスコストがさらに増加します。これらのケースでは、マッピングに直接アクセスする新しい`EXTSLOAD`呼び出しを使用すると、相互作用のガスコストを10倍以上削減でき、さらに読み取りコントラクトのガスコストを予測可能にすることができます。

## 仕様

`SLOAD (0x54)`と同様に機能する新しいEVMインストラクション`EXTSLOAD (0x5c)`。ただし、読み取り元のコントラクトを表すパラメーターが追加されています。

```shell
EXTSLOAD (0x5c)
```

`EXTSLOAD`命令は、スタックから2つの値をポップします。最初の`contract`はコントラクトアドレス、2番目の`slot`はコントラクト内のストレージアドレスです。その結果、`EXTSLOAD`は`contract`コントラクトのストレージ`slot`アドレスの値をスタックにプッシュするか、`contract`アカウントが存在しない場合は`0`をプッシュします。

### Verkle 以前のガスコスト

Verkle Treeの変更前のガスコストは、`ACCOUNT_ACCESS_COST + STORAGE_READ_COST`として指定されます。ここで:

- `ACCOUNT_ACCESS_COST`は、アドレスが`accessed_addresses`セットにすでに存在する場合は`0`、それ以外の場合は`COLD_ACCOUNT_ACCESS_COST`です。
- `STORAGE_READ_COST`は、ストレージキーが`accessed_storage_keys`セットにすでに存在する場合は`WARM_STORAGE_READ_COST`、それ以外の場合は`COLD_STORAGE_READ_COST`です。

### Verkle 以降のガスコスト

Verkle Treeの変更後は、`ACCOUNT_ACCESS_COST`は不要になることに注意が必要です。なぜなら、単一のアカウントのストレージがグローバルトライ全体に分散されるためです。したがって、Verkle Treeの変更後のガスコストは、[Verkle 以前のガスコスト](#verkle-以前のガスコスト)で指定された`STORAGE_READ_COST`のみです。

## 根拠

- このEIPがなければ、コントラクトはSLOADして値を返す単純なメソッドを持つことで、自身の状態を完全に公開することができます([例](../assets/eip-2330/Extsload.sol))。ガスコストの複雑さは、`1`x CALL コスト + `N`x SLOAD コストとして見ることができます。したがって、アカウントに対して`EXTSLOAD`オペコードを`N`回使用する場合のコストが、`1`x `COLD_ACCOUNT_ACCESS_COST`と`N`x `STORAGE_READ_COST`であることが正当化されます。
- このEIPがなければ、コントラクトは他のコントラクトの内部状態を使用することができます。外部当事者は値とプルーフをコントラクトに供給し、コントラクトは`BLOCKHASH`を使用してそれを検証することができます。これは過去のブロックにのみ可能で、最新の状態(現在のブロックハッシュは実行前に決定できない)には適用できません。
- このオペコードは、他のコントラクトのストレージを読み取ることで、オブジェクト指向(OO)モデルを破る可能性があります。通常のシステムでOOを使用することは純粋な利点ですが、EVMでは明確なコストがあります(1 SLOAD あたり約 $0.2、20 gwei、ETHUSD 2000)。また、OOは開発者に誤った前提を与えており、スマートコントラクトの「プライベート」変数が何らかの方法で暗号化されていると誤解されることがあります。これにより、設計が悪化する可能性があります。したがって、このEIPはスマートコントラクトシステムをより効率的にし、誤解を防ぐ上で有益である可能性があります。

## 下位互換性

新しいインストラクションを追加するため、この変更は完全に下位互換性があります。

## セキュリティ上の考慮事項

- オペコードがSLOADと似ているため、さまざまなクライアントで簡単に実装できるはずです。
- このオペコードにより、呼び出し先の`A`がコール元の`B`に再入可能になり、`B`の状態を読み取ることができます。ただし、状態を変更しないため、セキュリティ上の問題にはならないはずです。一般的に、コントラクトは再入ガードを使用しますが、それは書き込みメソッドにのみ追加されます。したがち、現在でも`A`は`B`に再入可能で、`B`が公開するビューメソッドを使ってその状態を読み取ることができ、それが問題になったことはありません。

## 著作権

著作権およびそれに関連する権利は[CC0](../LICENSE.md)で放棄されています。