---
original: 36b285b8fdaf19e7ec25a851c43eb6e0722418f6df1b03d026afe0a6be8c1213
---

---
eip: 6206
title: EOF - JUMPF と非返却関数
description: 関数呼び出しをチェーンするための命令を導入します。
author: Andrei Maiboroda (@gumb0)、Alex Beregszaszi (@axic)、Paweł Bylica (@chfast)、Matt Garnett (@lightclient)
discussions-to: https://ethereum-magicians.org/t/eip-4750-eof-functions/8195
status: レビュー
type: Standards Track
category: Core
created: 2022-12-21
requires: 4750, 5450
---

## 概要

このEIPでは、新しい命令 `JUMPF` を導入することで、EOF関数([EIP-4750](./eip-4750.md))でテールコール最適化を可能にします。`JUMPF` は、新しい返却スタックフレームを追加することなくコードセクションにジャンプします。

さらに、型セクションのフォーマットを拡張して、セクションを非返却として宣言できるようにし、`JUMPF` に対するスタック検証を簡略化します。

## 動機

多くの関数では、ルーチンの最後にコールを行った後に返却します。`JUMPF` はこの動作を最適化し、返却スタックを更新する必要なく、コードセクションを変更できます。

検証時に関数が決して制御を返さないことがわかれば、そのような関数への `JUMPF` を終了命令と同様に扱うことができ、実行終了時に余分なアイテムをオペランドスタックに残すことができます。これにより、コンパイラは、コードサイズと消費ガスの両面で、より最適なコードを生成する機会が得られます。特に、`REVERT` で実行を終了するような小さなエラー処理ヘルパーに有効です。これらのヘルパーは複数のブランチで再利用されることが一般的で、`JUMPF` の前にスタックアイテムを取り除く必要がない場合、ヘルパー関数に抽出するのが効率的です。

## 仕様

### 型セクションの変更

制御を返すことのできないセクションを「非返却セクション」と定義します。

型セクションの `outputs` フィールドに `0x80` という特別な値が含まれている場合、対応するコードセクションが非返却であることを示します。[非返却ステータスの検証](#非返却ステータスの検証)を参照してください。

最初のコードセクションは、入力が0で、かつ非返却でなければなりません。

### 実行セマンティクス

新しい命令 `JUMPF (0xe5)` が導入されます。

1. `JUMPF` には1つの即値引数 `target_section_index` があり、これは16ビットの符号なし ビッグエンディアン値でエンコードされます。
2. オペランドスタックのサイズが `1024 - type[target_section_index].max_stack_height + type[target_section_index].inputs` を超える場合(つまり、呼び出された関数がグローバルスタックの高さ制限を超える可能性がある場合)、実行は例外的に停止します。これにより、ターゲット関数がグローバルスタックの高さ制限を超えないことが保証されます。
3. `JUMPF` は `current_section_index` を `target_section_index` に、`PC` を `0` に設定しますが、返却スタックは変更しません。実行はターゲットセクションで継続されます。
4. `JUMPF` のガスコストは5です。
5. `JUMPF` はオペランドスタックにプッシュもポップもしません。

### コード検証

`type[i]` の定義は [EIP-4750](./eip-4750.md) から継承し、`stack_height_min` と `stack_height_max` を命令フロー解析中の特定の命令におけるスタックの高さ境界として定義します。

* `JUMPF` の即値引数は、コードセクションの総数未満でなければなりません。
* 各 `JUMPF` 命令について:
  * `type[current_section_index].outputs` が `type[target_section_index].outputs` 以上であるか、
  * または `type[target_section_index].outputs` が `0x80` である必要があります。
* `JUMPF` のスタック高さ検証は、ターゲットセクションが非返却かどうかによって異なります:
  * 返却セクション(`type[target_section_index].outputs` が `0x80` ではない)への `JUMPF`: `stack_height_min` と `stack_height_max` は `type[current_section_index].outputs + type[target_section_index].inputs - type[target_section_index].outputs` に等しくなければなりません。つまり、ターゲットセクションは、現在のコードセクションが `type[current_section_index].outputs - type[target_section_index].outputs` 要素をスタックに残した場合、元のコードセクションが呼び出したトップ要素よりも少ないスタック要素を出力できます。
  * 非返却セクション(`type[target_section_index].outputs` が `0x80`)への `JUMPF`: `stack_height_min` は `type[target_section_index].inputs` 以上でなければなりません。
* `JUMPF` でのスタックオーバーフローチェック: `stack_height_max` は `1024 - types[target_section_index].max_stack_height + types[target_section_index].inputs` 以下でなければなりません。
* `JUMPF` は終了命令とみなされ、コード検証では後続命令を持たず、セクションの最終命令になる可能性があります。
* [EIP-4200](./eip-4200.md) で定義されたコード検証も、任意の `RJUMP*` オフセットが `JUMPF` 命令の直後の2バイトを指す場合に失敗します。

`CALLF` 命令の検証に以下のルールが追加されます:

* 任意の `CALLF` の即値引数 `target_section_index` がターゲットとする非返却セクション(つまり `type[target_section_index]` が `0x80` である)の場合、コードセクションは無効です。

#### 非返却ステータスの検証

セクションに `RETF` 命令も `JUMPF` 命令で返却セクションをターゲットにするものもない場合、そのセクションは非返却でなければなりません。
*注: これは、非返却セクションのみを対象とする `JUMPF` を含むセクションも、自身が非返却であることを意味します。*

## 根拠

### 出力が少ないセクションへの `JUMPF` を許可する

`JUMPF` が `type[current_section_index].outputs - type[target_section_index].outputs` のデルタスタック要素を準備すれば、`CALLF` で元々入った以上の出力を持つセクションに `JUMPF` できます。これにより、コンパイラがコード生成の際に、出力値に関係なく一般的に使用できるヘルパーを利用できるようになり、重複コードを削減できます。

## 下位互換性

この変更は下位互換性があります。EOF では未定義の命令の使用や展開を許可していないため、既存のコントラクトには影響がありません。

## セキュリティ上の考慮事項

議論が必要です。

## 著作権

著作権およびそれに関連する権利は [CC0](../LICENSE.md) で放棄されています。