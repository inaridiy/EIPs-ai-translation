---
original: 342b5bf0f3e1c541f7bf936b51d8d05004e8ea2575e29d317f609d0954c17ab1
---

---
eip: 2938
title: アカウントアブストラクション
author: Vitalik Buterin (@vbuterin), Ansgar Dietrichs (@adietrichs), Matt Garnett (@lightclient), Will Villanueva (@villanuevawill), Sam Wilson (@SamWilsn)
discussions-to: https://ethereum-magicians.org/t/eip-2938-account-abstraction/4630
status: 停滞
type: Standards Track
category: Core
created: 2020-09-04
requires: 2718
---

## 簡単な要約

アカウントアブストラクション(AA)では、コントラクトがトップレベルのアカウントとなり、手数料の支払いとトランザクション実行を行うことができます。

## 概要

**参照: [https://ethereum-magicians.org/t/implementing-account-abstraction-as-part-of-eth1-x/4020](https://ethereum-magicians.org/t/implementing-account-abstraction-as-part-of-eth1-x/4020) および関連リンク for 過去の取り組みと動機。**

Muir Glacierの時点でのトランザクションの有効性は、プロトコルによって厳密に定義されています: ECDSA署名、単純なnonce、およびアカウントの残高。アカウントアブストラクションでは、トランザクションの有効性条件に任意のEVMバイトコードの実行(アクセスできる状態に一定の制限がある)が追加されます。有効性のシグナルとして、新しいEVMオペコード `PAYGAS` を提案します。これはガス価格とガス制限も設定します。

アカウントアブストラクションを2つのティアに分けます: **シングルテナントAA**は、参加者が少ないウォレットやその他のユースケースをサポートすることを目的としており、**マルチテナントAA**は、参加者が多いアプリケーション(例: tornado.cash、Uniswap)をサポートすることを目的としています。

## 動機

現在の制限により、以下を含む重要な分野での革新が阻害されています:

1. ECDSA以外の署名検証(例: Schnorr、BLS、量子耐性...)を使用するスマートコントラクトウォレット
2. マルチシグ検証やソーシャルリカバリーなどの機能を含むスマートコントラクトウォレット、これにより資金が失われたり盗まれたりするリスクを大幅に軽減できる
3. [tornado.cash](http://tornado.cash)のようなプライバシー保護システム
4. DeFiプロトコルのガス効率を改善するための、条件を満たさないトランザクションがブロックに含まれないようにする試み(例: マッチングオーダーの存在)
5. ユーザーがETH以外のトークンでトランザクション手数料を支払えるようにする(例: トランザクション内でその他のトークンをリアルタイムでETHに変換する)

上記のほとんどすべてのユースケースは、[Gas Station Network](https://www.opengsn.org/)やアプリケーション固有の代替手段を使用することで現在可能です。これらの実装は(i)リレーヤーに支払う21,000ガスの追加コストにより技術的に非効率であり、(ii)リレーヤーが手数料の上に利益を上乗せする必要があるため経済的に非効率です。さらに、仲介プロトコルを使用することで、これらのアプリケーションはEthereumのベースインフラストラクチャーに単純に依存できず、より小さなユーザーベースとより高いリスクを持つ追加のプロトコルに依存する必要があります。

上記の5つのユースケースのうち、シングルテナントAAは(1)と(2)をおおよそサポートし、マルチテナントAAは(3)と(4)をおおよそサポートします。2つのティアの違いについては、以下の仕様と根拠のセクションで説明します。

## 仕様

### シングルテナント

`FORK_BLOCK`以降、プロトコルによって以下の変更が認識されます。

#### 定数

| 定数 | 値 |
| - | - |
| **`AA_ENTRY_POINT`** | `0xffffffffffffffffffffffffffffffffffffffff` |
| **`AA_TX_TYPE`** | `2` |
| **`FORK_BLOCK`** | 未定 |
| **`AA_BASE_GAS_COST`** | 15000 |

#### 新しいトランザクションタイプ

[EIP-2718](./eip-2718.md)に準拠した新しいトランザクションタイプ `AA_TX_TYPE` が導入されます。このタイプのトランザクションは「AAトランザクション」と呼ばれます。ペイロードは `rlp([nonce, target, data])` として解釈されます。

このトランザクションのベースガスコストは、ECDSA署名の「固有の」コストを反映して21,000ではなく `AA_BASE_GAS_COST` に設定されます。

nonceの処理は既存のトランザクションと同様に行われます(`tx.nonce == tx.target.nonce`を確認し、この条件を満たさない場合はトランザクションは無効、それ以外の場合は処理を続行し、即座に`tx.nonce += 1`を行います)。

このトランザクションタイプには固有のガス制限はありません。実行を開始する際、ガス制限は単にブロックの残りガス(つまり`block.gas_limit`から前のトランザクションで使用されたガスを引いたもの)に設定され、`PAYGAS`オペコード(下記参照)でガス制限を下方調整できます。

#### トランザクション全体のグローバル変数

新しいトランザクション全体のグローバル変数を導入します。これらの変数は、特に(SSTORE refunds counterと同様の)リバージョンロジックが似ています。

| 変数 | 型 | 初期値 |
| - | - | - |
| `globals.transaction_fee_paid` | `bool` | `type(tx) == AA_TX_TYPE の場合はFalse、それ以外はTrue` |
| `globals.gas_price` | `int` | `type(tx) == AA_TX_TYPE の場合は0、それ以外はtx.gas_price` |
| `globals.gas_limit` | `int` | `type(tx) == AA_TX_TYPE の場合は0、それ以外はtx.gas_limit` |

#### `NONCE (0x48)` オペコード

新しいオペコード `NONCE (0x48)` が導入されます。ガスコストは `G_base` で、呼び出し先のnonceをスタックにプッシュします。

#### `PAYGAS (0x49)` オペコード

新しいオペコード `PAYGAS (0x49)` が導入されます。ガスコストは `G_base` です。スタックから2つの引数を取ります: (トップ) `version_number`、(2番目) `memory_start`。初期実装では、`version_number == 0`をアサートし、以下を読み取ります:

* `gas_price = bytes_to_int(vm.memory[memory_start: memory_start + 32])`
* `gas_limit = bytes_to_int(vm.memory[memory_start + 32: memory_start + 64])`

両方の読み取りは、MLOADとCALLと同様のメカニズムを使用します。必要に応じてメモリが拡張されます。

将来のハードフォークでは、異なるバージョン番号をサポートする可能性があり、その場合オペコードは異なるサイズのメモリスライスを取り、それらを異なる方法で解釈する可能性があります。2つの特に有望な使用例は、[EIP 1559](https://notes.ethereum.org/@vbuterin/BkSQmQTS8)と[escalator mechanism](https://ethresear.ch/t/another-simple-gas-fee-model-the-escalator-algorithm-from-the-agoric-papers/6399)です。

このオペコードは以下のように動作します。上記のバージョン番号チェックに加えて、以下の3つの条件がすべて満たされる場合:

1. アカウントの残高が `>= gas_price * gas_limit` である
2. `globals.transaction_fee_paid == False` である
3. トップレベルのAA実行フレームにいる(つまり、現在実行中のEVM実行が終了またはリバートした場合、トランザクション全体のEVM実行が終了する)

以下を行います:

* `gas_price * gas_limit`をコントラクトの残高から減算
* `globals.transaction_fee_paid`を`True`に設定
* `globals.gas_price`を`gas_price`に、`globals.gas_limit`を`gas_limit`に設定
* 現在の実行コンテキストの残りガスを、`gas_limit`から既に消費されたガスを引いた値に設定

上記の3つの条件のいずれかが満たされない場合は、例外をスローします。

AAトランザクションの実行終了時に、必ず`globals.transaction_fee_paid == True`であることが義務付けられています。そうでない場合、トランザクションは無効となります。実行終了時、コントラクトには`globals.gas_price * remaining_gas`の残りガスが払い戻され、`(globals.gas_limit - remaining_gas) * globals.gas_price`がマイナーに送金されます。

`PAYGAS`はEVM実行の_チェックポイント_としても機能します。トップレベルの実行フレームが`PAYGAS`の呼び出し後にリバートした場合、実行はPAYGASの直後の地点までリバートし、そこで終了します。この場合、コントラクトは払い戻しを受けず、`globals.gas_limit * globals.gas_price`がマイナーに送金されます。

#### リプレイ保護

リプレイ攻撃を防ぐために、以下の2つのアプローチのいずれかを実装する必要があります。

##### `SET_INDESTRUCTIBLE`の要求

AAトランザクションのターゲットとなるコントラクトが[EIP-2937]の`SET_INDESTRUCTIBLE`オペコードで始まることを要求します。`SET_INDESTRUCTIBLE`で始まらないコントラクトをターゲットとするAAトランザクションは無効であり、ブロックに含めることはできません。

`AA_PREFIX`にこのオペコードを含める必要があります。

[EIP-2937]: ./eip-2937.md

##### `SELFDESTRUCT`時のnonceの保持

もう1つのオプションは、`SELFDESTRUCT`呼び出し時にコントラクトのnonceをゼロにするのではなく、保持することです。

#### その他

* `CALLER (0x33)` がAAトランザクションの最初のフレームで呼び出された場合、`AA_ENTRY_POINT`を返さなければなりません。
* `ORIGIN (0x32)` がAAトランザクションの任意のフレームで呼び出された場合、`AA_ENTRY_POINT`を返さなければなりません。
* `GASPRICE (0x3A)` オペコードは、`globals.gas_price`の値をプッシュするようになりました。

新しい `GASPRICE` の定義は、非AAトランザクションの動作には変更を加えません。なぜなら、`globals.gas_price`は`tx.gas_price`に初期化され、`PAYGAS`を呼び出すことで変更できないためです。

#### マイニングと再ブロードキャストの戦略

アカウントアブストラクションの複雑さの多くは、マイナーと検証ノードが、トランザクションを受け入れるかどうかを判断し、再ブロードキャストするかどうかを決定するために使用する戦略に由来します。マイナーは、[DoS攻撃](https://hackingdistributed.com/2016/06/28/ethereum-soft-fork-dos-vector/)を回避するために、わずかな処理後にトランザクションが実際に手数料を支払うかどうかを判断する必要があります。検証ノードも、ほぼ同じ検証を行う必要があり、トランザクションを再ブロードキャストするかどうかを決定します。

コンセンサスの変更を最小限に抑えることで、マイナーと検証ノードがAA mempool サポートを段階的に導入できるようになります。初期段階では、シンプルなシングルテナントのユースケースを可能にすることに焦点を当て、後の段階では、より複雑なマルチテナントのユースケースもサポートするようになります。初期段階は意図的により詳細に策定されています。後の段階については、実装が必要になるまでまだ時間があるためです。

##### 固定nonceのトランザクション

| 定数 | 値 |
| - | - |
| `VERIFICATION_GAS_MULTIPLIER` | `6` |
| `VERIFICATION_GAS_CAP` | `= VERIFICATION_GAS_MULTIPLIER * AA_BASE_GAS_COST = 90000` |
| `AA_PREFIX` | `if(msg.sender != shr(-1, 12)) { LOG1(msg.sender, msg.value); return }`; EVMへのコンパイル方法は未定 |

ノードがAAトランザクションを受信すると、現在のチェーンヘッドの事後状態に対してそれを処理(つまり実行しようとする)
(続き)

し、その有効性を判断します。以下のいずれかの事象が発生するまで実行を続けます:

* `target`のコードが`AA_PREFIX`で始まっていない場合、失敗で終了
* 以下のいずれかに達した場合、失敗で終了:
    * 環境オペコード(`BLOCKHASH`, `COINBASE`, `TIMESTAMP`, `NUMBER`, `DIFFICULTY`, `GASLIMIT`)
    * `BALANCE`(対象アカウントを含むすべてのアカウントの)
    * `callee`を`target`またはプリコンパイルアドレス以外のものに変更する外部呼び出し/作成(`CALL`, `CALLCODE`, `STATICCALL`, `CREATE`, `CREATE2`)
    * `target`以外のアドレスのコードを読み取る外部状態アクセス(`EXTCODESIZE`, `EXTCODEHASH`, `EXTCODECOPY`、および`CALLCODE`と`DELEGATECALL`)
* 消費ガスが`VERIFICATION_GAS_CAP`(上記で指定)を超えるか、ブロックで利用可能なガスを超える場合、失敗で終了
* `PAYGAS`に到達した場合、残高が十分であれば(例: `balance >= gas_price * gas_limit`)成功で、そうでなければ失敗で終了

ノードは、現在の有効nonceを超えるnonceを持つトランザクションをmempool に保持しません。mempoolにすでに有効nonceのトランザクションが存在する場合、同じアカウントに同じnonceの別のトランザクションが到着すると、ガス価格が十分に高ければ既存のものを置き換え、そうでなければ破棄されます。つまり、mempoolには同一アカウントあたり最大1つの保留中のトランザクションしか存在しません。

新しいブロックを処理する際、AAトランザクションのターゲットとなったアカウントを記録します(現在のブロックには12,500,000ガスがあり、AAトランザクションには15,000ガス以上かかるため、最大833個のターゲットアカウントがあります)。これらのアカウントをターゲットとするすべての保留中のトランザクションを破棄します。その他のトランザクションはmempoolに残ります。

### シングルテナント+

[不滅のコントラクトEIP](http://github.com/ethereum/EIPs/pull/2937)が追加された場合、シングルテナントAAは`DELEGATECALL`をトランザクション検証中に許可するように適応できます: 新しいAAトランザクションの実行中、`SET_INDESTRUCTIBLE`オペコードで始まるコントラクトのコードを読み取る外部状態アクセス(`EXTCODESIZE`, `EXTCODEHASH`, `EXTCODECOPY`, `CALLCODE`, `DELEGATECALL`)は禁止されなくなります。ただし、`target`またはプリコンパイル以外のものを`callee`に変更する呼び出し(つまり`CALLCODE`と`DELEGATECALL`以外の呼び出し)は依然として許可されません。

[IS_STATIC EIP](http://github.com/ethereum/EIPs/pull/2975)が追加された場合、許可されるプレフィックスのリストを拡張して、状態変更呼び出しは許可せずに、着信静的呼び出しを許可するプレフィックスを追加できます。

許可されるプレフィックスのリストは、他の無害なユースケース(例: 着金の記録)を有効にするために拡張することもできます。

AAアカウントへの外部呼び出しを許可することもできます。`RESERVE_GAS`オペコードを追加し、引数`N`を取り、単純な動作をします: 即座に`N`ガスを消却し、`N`ガスをrefundに追加します。その後、少なくとも`AA_BASE_GAS_COST * 2`ガスを予約するAA_PREFIXを追加します。これにより、refundが最大50%までしか戻せないため、少なくとも`AA_BASE_GAS_COST`ガスを費やす必要があり、そのアカウントをターゲットとするmempoolのトランザクションを無効化することができ、その不変条件を維持できます。

アカウントは、より高い`RESERVE_GAS`値を設定することで、より高い`VERIFICATION_GAS_CAP`を安全に持つこともできます。目標は、アカウントを編集するための最小ガスコスト(つまりその`RESERVE_GAS`の半分)と、そのアカウントに許可される`VERIFICATION_GAS_CAP`の比率を`VERIFICATION_GAS_MULTIPLIER`対1に維持することです。これにより、前のセクションで示唆された最大再検証ガス消費に関する不変条件も維持されます。

### マルチテナント & 先を見据えて

後の段階では、mempoolでアカウントあたり複数の保留中のトランザクションをサポートできるようになります。ここでの主な課題は、単一のトランザクションが、同じアカウントを対象とする他のすべてのトランザクションを無効化する状態変更を引き起こす可能性があることです。さらに、ガス価格を優先的に処理すると、最も高いガス価格を支払う意思のあるユーザーが、わずかな変更を加えた自分のトランザクションの複数のバージョンを公開し、他のすべてのトランザクションをmempoolから押し出すという攻撃ベクトルが存在します。

この問題を軽減する戦略の概要は以下の通りです。着信トランザクションに[EIP-2930](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-2930.md)スタイルのアクセスリストを含めることを要求し、それを拘束力のあるものにします。つまり、アクセスリスト外のアクセスは無効となります。トランザクションは、そのアクセスリストがmempoolの他のトランザクションのアクセスリストと重複していない場合(またはガス価格が高い場合)にのみ、mempoolに含められます。別の見方をすると、単一のアカウントmempoolではなく、ストレージスロットごとのmempoolを持つことができます(必要に応じて例えば5つのストレージスロットに制限できます)。

また、マルチテナントAAでは、マイナーがトランザクションのnonceを編集してシーケンスに入れられるようにすることがほぼ確実に必要になります。その結果、公開時にトランザクションのハッシュを予測できなくなります。クライアントはこれに明示的に対処する必要があります。

これらのアイデアをさらに洗練させるには、さらなる調査が必要であり、これは後の作業に委ねられます。

## 根拠

アカウントアブストラクションのセットアップでの中心的な問題は常に、マイナーと
ネットワークノードが、含めようとしているトランザクションや再ブロードキャストしようとしているトランザクションが実際に手数料を支払うかどうかを迅速に検証できることです。現在は比較的単純で、署名とnonceが有効で、残高とガス価格が十分であれば、トランザクションを含めることができ、手数料も支払われます。これらのチェックは迅速に行うことができます。

アカウントアブストラクションのセットアップでは、アカウントが、トランザクションの有効性のためのより柔軟な条件を指定できるようにすることが目標ですが、この条件を迅速に検証でき、現在のセットアップと同じ安全性を持つ必要があります。

通常のトランザクションでは、トップレベルの呼び出しは`tx.sender`から`tx.to`に行われ、`tx.value`を伴います。AAトランザクションでは、トップレベルの呼び出しは_エントリポイントアドレス_(`0xFFFF...FF`)から`tx.target`に行われます。

トップレベルのコード実行は、**検証フェーズ**(`PAYGAS`の前)と**実行フェーズ**(`PAYGAS`の後)の2つのフェーズに分かれることが期待されます。検証フェーズ中に実行が例外をスローした場合、現在のシステムで無効な署名を持つトランザクションと同様に、トランザクションは無効となります。実行フェーズ後に例外がスローされた場合、手数料は支払われるため、マイナーはそれを含めることができます。

AAの異なるステージ間の遷移は、完全にマイナー戦略の変更によって行われます。最初のステージでは**シングルテナントAA**をサポートし、ユーザーアカウントを表すコントラクト(`tx.target`)がある場合にのみ簡単に実装できるユースケースがあります。後のステージでは、ログやライブラリのサポートを改善し、**マルチテナントAA**をサポートするように移行します。ここでの目標は、`tx.target`がマルチユーザーのアプリケーションを表す場合にもサポートできるようにすることです。

### シングルテナントAAでもnonceは堅持される

nonceは、シングルテナントAAでも強制されています。これは、シングルターゲットAAが、各トランザクション(したがって各トランザクションハッシュ)が1回しかチェーンに含められないという不変条件を壊さないようにするためです。シングルテナントAAでは任意の順序でのトランザクション含入に限定的な価値はありますが、その不変条件を壊すほどの価値はありません。

AAアカウントのnonceは、リプレイ保護と`CREATE`オペコードを使用したコントラクトアドレス生成の両方の目的を果たすことになります。これにより、単一のトランザクションで1つ以上nonceが増加する可能性があります。これは許容可能と見なされています。AAによって導入された他のメカニズスムにより、1つ以上のトランザクションを処理できることが既に不可能になっているためです。ただし、AAコントラクトでは`CREATE`ではなく`CREATE2`を使用することを強くお勧めします。

マルチテナントAAでは、上述のように、nonceは可変になると予想されており、マルチテナントAAシステムを使用するアプリケーションはこの管理を行う必要があります。

### nonceがEVMに公開される

これは、検証コードでnonceの署名チェックを行えるようにするためです。

### リプレイ保護

nonceを再利用できないようにするため、上記の2つのアプローチ(`SET_INDESTRUCTIBLE`の要求または`SELFDESTRUCT`動作の変更)のいずれかを実装する必要があります。これはコンセンサスの変更である必要があり、単に`AA_PREFIX`の一部ではありません。そうしないと、トランザクションハッシュの一意性が維持されません。

### マイナーは、PAYGASの前に外部データやターゲットの自身の残高にアクセスするトランザクションを拒否する

従来のトランザクションの重要な特性の1つは、X以外のアカウントから発信されたトランザクションの活動が、Xのトランザクションの有効性を無効化することはできないということです。外部トランザクションがXに課すことのできる唯一の状態変更は、Xの残高の増加であり、これはトランザクションを無効化することはできません。

AAコントラクトが`PAYGAS`の前(つまり検証フェーズ中)に外部データ(他のアカウントと環境変数(GASPRICE、DIFFICULTY など)の両方)にアクセスすることを許可すると、この不変条件が破られます。例えば、多数のAAトランザクションを送信し、それらが`if FOO.get_number() != 5: throw()`という外部呼び出しを行うようにする人がいるとします。`FOO.number`が5に設定されていたときにそれらのトランザクションが送信された可能性がありますが、`FOO`に対する単一のトランザクションで`number`を別の値に設定すると、_数千もの AAトランザクション_がすべて無効になってしまいます。これは深刻なDoS攻撃ベクトルになります。

唯一の例外は、不滅のコントラクト(つまり、[このEIP](https://hackmd.io/@HWeNw8hNRimMm2m2GH56Cw/SyNT3Cdmw)で定義された`SET_INDESTRUCTIBLE`オペコードで始まるコントラクト)です。これは安全な例外です。なぜなら、読み取られるデータは変更できないためです。

`BALANCE`の読み取りを禁止することで、より穏やかな攻撃ベクトルをブロックできます。攻撃者は、わずか6,700ガスのコストで(最悪の場合21,000ガスではなく15,000ガス)、トランザクションを再処理させることができます。

長期的には、AAでの外部データの読み取りを許可することができますが、必須のアクセスリストなどの保護が
(続き)

必要になります。

### AAトランザクションはプレフィックス付きのコントラクトを呼び出す必要がある

プレリュードは、AAトランザクションのみがそのコントラクトを呼び出せるようにするために使用されます。これは上述の不変条件を維持するための別の対策です。このチェックが行われないと、XというAAアカウントの外部から発信されたトランザクションがXに呼び出されて状態変更を行い、そのアカウントをターゲットとするトランザクションを5,000ガスの僅かなコストで再処理させることができてしまいます。

### マルチテナントAA

マルチテナントAAは、シングルテナントAAを拡張し、**同一のアカウントに対して調整されていない別々のユーザーがトランザクションを送信し、それらのトランザクションが干渉し合う可能性に対してより良く対処する**ことができます。

マルチテナントAAの価値を理解するには、2つの例として(i) [tornado.cash](http://tornado.cash)と(ii) [Uniswap](http://uniswap.exchange)を検討することが役立ちます。これらの場合、特定のユーザーではなくアプリケーション自体を表す単一の中央コントラクトが存在します。しかし、抽象化を使ってアプリケーション固有のトランザクション検証を行うことには重要な価値があります。

#### Tornado Cash

Tornado Cashのワークフローは以下の通りです:

1. ユーザーがTCコントラクトにトランザクションを送信し、一定量(例: 1 ETH)のコインを預金します。ユーザーの秘密鍵のハッシュを含む預金記録がメルクルツリーに追加され、ツリーのルートがTCコントラクトに保存されます。
2. ユーザーが後に出金する際は、自分の秘密鍵のハッシュがツリーの葉に含まれていることを証明するZK-SNARKを生成して送信します。TCコントラクトはZK-SNARKを検証し、また、nullifier値(秘密鍵から派生)がまだ使用されていないことも確認します。その後、1 ETHをユーザーの指定アドレスに送金し、ユーザーのnullifierが使用されたことを記録します。

TCが提供するプライバシーは、ユーザーが出金する際、自分の預金から来たことを証明できるが、他のユーザーにはどの預金からきたかがわからないことから生まれます。しかし、TCを単純に実装すると致命的な欠陥があります。ユーザーは通常、出金先のアドレスにETHを持っていないため、預金アドレスを使ってガス代を支払うと、預金アドレスと出金アドレスの間に on-chain のリンクが生まれてしまいます。

現在はこの問題をリレーヤーで解決しています。サードパーティのリレーヤーがZK-SNARKの検証と未使用のnullifierの確認を行い、自身のETHを使ってトランザクションを公開し、TCコントラクトからユーザーから手数料を回収します。

AAを使えば、リレーヤーなしで実現できます。ユーザーはTCコントラクトをターゲットとするAAトランザクションを送信し、ZK-SNARKの検証とnullifierのチェックを検証フェーズで行い、その後PAYGASを呼び出すことができます。これにより、出金先アドレスからガス代を直接支払え、リレーヤーや預金アドレスとの on-chain リンクを必要としません。

完全に実装するには、複数のユーザーが同時に出金トランザクションを送信できるようAA を構造化する必要があり(nonceを要求すると難しくなる)、単一のアカウントがAA トランザクション(出金)と外部から開始された呼び出し(預金)の両方をサポートできるようにする必要があります。

#### Uniswap

Uniswapの新しいバージョンは、ユーザーがUniswapコントラクトを直接ターゲットするトランザクションを送信できるように構築できます。ユーザーはあらかじめトークンをUniswapに預金し、Uniswapはそれらの残高と、それらの残高を使うトランザクションを検証できる公開鍵を保持します。AAで開始されたUniswapトレードは、これらの内部残高のみを使うことができます。

これは通常のトレーダーには無意味ですが、アービトラージャーには強力な恩恵となります。アービトラージャーはコインをUniswapに預金し、外部市場の条件が変化するたびにアービトラージを行うトランザクションを送信できます。検証フェーズで価格制限などのロジックを適用できるため、含まれないトランザクション(例えば別のアービトラージャーがトレードを先に行った場合)はオンチェーンに含まれず、アービトラージャーはガス代を支払う必要がなく、オンチェーンに含まれる「ゴミ」トランザクションの数も減少します。これにより、ブロックチェーンの実質的なスケーラビリティと市場効率の両方が大幅に向上する可能性があります。

ここでもUniswapは、AAトランザクションと外部から開始された呼び出しの両方をサポートする必要があります。

## 下位互換性

このAA実装は、既存のトランザクションタイプを維持します。`assert origin == caller`を使ってEOAを検証する方法は健全ですが、AAアカウントには拡張できません。AAトランザクションでは常に`origin == AA_ENTRY_POINT`になります。

設計の悪いシングルテナントAAコントラクトは、トランザクションの非悪用可能性の不変条件を破壊してしまいます。つまり、進行中のAAトランザクションを取り出して変更し、変更版でも有効なものにできてしまいます。AAアカウントコントラクトは、これを不可能にするように設計できますが、それは自身の責任です。マルチテナントAAはこの不変条件をさらに徹底的に破壊し、正当なアプリケーションでも(それ以前から存在していたものを除いて)トランザクションハッシュを予測不可能にします。

AAコントラクトは、明示的に組み込まない限り、リプレイ保護を持たない可能性があります。これは[EIP 1344](./eip-1344.md)で導入された`CHAINID (0x46)`オペコードを使って行えます。

## テストケース
参照: [https://github.com/quilt/tests/tree/account-abstraction](https://github.com/quilt/tests/tree/account-abstraction)

## 実装
参照: [https://github.com/quilt/go-ethereum/tree/account-abstraction](https://github.com/quilt/go-ethereum/tree/account-abstraction)

## セキュリティ上の考慮事項

[https://ethresear.ch/t/dos-vectors-in-account-abstraction-aa-or-validation-generalization-a-case-study-in-geth/7937](https://ethresear.ch/t/dos-vectors-in-account-abstraction-aa-or-validation-generalization-a-case-study-in-geth/7937)でDoS問題の分析を参照してください。

### 再検証

トランザクションがmempoolに入ると、クライアントはすぐにそのトランザクションの有効性を判断できます。これを判断すると、同じアカウントからのトランザクションによって無効化されない限り、有効なままであると確信できます。

ただし、攻撃者がトランザクションを公開して既存のトランザクションを無効化し、トランザクション自体の計算量以上の再計算を ネットワークに強いることができる場合があります。このEIPは、再計算が単一ブロックで理論的な最大6倍のブロックガス制限までに抑えられるよう維持しています。これは以前よりも若干高価ですが、それほど大きな違いではありません。

#### ピアのサービス拒否

サービス拒否攻撃は、ピアリストの中のサイボーグを特定することの難しさから、防御が困難です。いつでも攻撃を開始する(または賄賂を受け取る)ことができます。これはアカウントアブストラクションが導入する問題ではありません。現在のクライアントに対しても、無効な署名を持つトランザクションで攻撃を行うことができます。ただし、AAによって許可される検証作業の量が増えたため、無効なトランザクションでクライアントに計算を強要できる量を制限することが重要です。このため、マイナーは推奨される採掘戦略に従うことが最善です。

## 著作権
著作権およびその関連権利は[CC0](../LICENSE.md)で放棄されています。