---
original: 9d97750212fc6bbf366aacdfc3c3a1df6879da9693dfb7ad53472399beea8e32
---

---
eip: 2124
title: チェーン互換性チェックのためのフォーク識別子
author: Péter Szilágyi <peterke@gmail.com>、Felix Lange <fjl@ethereum.org>
discussions-to: https://github.com/ethereum/EIPs/issues/2125
status: 最終版
type: 標準トラック
category: ネットワーキング
created: 2019-05-03
---

## 簡単な要約

現在、Ethereumネットワークのノードは、Ethereumノード（パブリックネットワーク、プライベートネットワーク、テストネットワークなど）のように見える遠隔マシンへのランダムな接続を確立することで、お互いを見つけようとしています。これは時間とリソースの無駄になります。特に小規模なネットワークの場合はそうです。

このオーバーヘッドを避けるために、Ethereumには、できるだけ早期に、ノードが有用かどうかを正確に識別できるメカニズムが必要です。このようなメカニズムには、チェーン構成を要約する方法と、そのような要約をネットワーク内で配信する方法が必要です。

この提案は、そのような要約、つまり一般的に有用な*フォーク識別子*の定義と、その検証ルールに焦点を当てています。これにより、任意のネットワークプロトコル（[discovery ENRs](./eip-778.md)や `eth/6x` ハンドシェイクなど）に組み込むことができます。

## 概要

Ethereumには多くのパブリックおよびプライベートネットワークがありますが、ディスカバリープロトコルはそれらを区別しません。ピアが良いか悪いか（同じチェーンか否か）を確認する唯一の方法は、TCP/IPコネクションを確立し、それをRLPx暗号化で包み、`eth`ハンドシェイクを実行することです。これは、リモートピアが別のネットワークにいることが判明した場合、極端なコストがかかります。しかも、Ethereumとイーサリアムクラシックを区別するのにも十分ではありません。この問題は小規模なネットワークでより深刻で、良いノードを見つけるためにはより多くの試行錯誤が必要です。

ピアが**同じ**チェーンにいる場合でも、非論争的なコンセンサスアップグレードの際、すべてのノードが同時にアップデートされるわけではありません（開発者ノード、残留物など）。これらの古いノードは無意味な負荷をピアツーピアネットワークにかけます。なぜなら、良いノードにつなぎついているだけで、アップグレードされたブロックを受け入れないからです。これは、遺産が数か月にわたって残る可能性があるテストネットワークにとって深刻な問題です。

このEIPは、チェーンの現在の状態（ジェネシスおよび適用されたすべてのフォーク）を正確かつ簡潔に要約する新しいアイデンティティスキームを提案しています。簡潔さは、データグラムプロトコルでも有用にするために特に重要です。このEIPは以下の問題を解決します:

 * 2つのノードが異なるネットワーク上にある場合、決して接続を検討してはいけません。
 * ハードフォークが通過した場合、アップグレードされたノードは非アップグレードのものを拒否しますが、**それ以前は**拒否しません。
 * ジェネシスは同じですが、フォークが異なる（ETH / ETC）場合、お互いを拒否する必要があります。

このEIPは、3つのフォークの明確な分離を解決しようとしていません! 同じ将来のブロック番号で、ネットワークが3つ（非フォーク、フォークAおよびフォークB）に分割された場合、フォーカーを互いから分離するには個別の特別な処理が必要です。これを扱わないことで、提案は実用的で単純になり、メインネットからのフォークを容易にすることも避けられます。

範囲を限定するために、このEIPはアイデンティティスキームと検証ルールのみを定義しています。同じスキームとアルゴリズムを様々なネットワークプロトコルに組み込むことで、`eth/6x`ハンドシェイクをより正確に（Ethereumとイーサリアムクラシックの区別）、ディスカバリーをより有用に（互換性のないピアを接続せずに拒否）することができます。

## 動機

ピアツーピアネットワーキングは、ファイアウォールやネットワークアドレス変換(NAT)のために、煩雑で難しいです。一般的に、ノードの小さな割合しか公開ルーティングアドレスを持っておらず、P2Pネットワークは主にこれらを使ってすべての他のデータを転送しています。公開ノードの有用性を最大化するには、それらのリソースが無駄な作業に費やされないようにすることが最善の方法です。

互換性のないノードを互いから積極的に切り離すことで、公開ノードからより多くの価値を引き出すことができ、全体的なP2Pネットワークをより堅牢で信頼性の高いものにすることができます。ディスカバリー層でこのネットワークパーティショニングをサポートすることで、ストリーム接続を最初から確立するのに関連するコストの高い暗号化やレイテンシ/帯域幅のヒットを回避できます。

## 仕様

各ノードは以下の値を維持します:

- **`FORK_HASH`**: ジェネシスハッシュと既に通過したフォークブロック番号のIEEE CRC32チェックサム(`[4]byte`)。
  - フォークブロック番号は昇順でCRC32チェックサムに入力されます。
  - 同じブロック番号で複数のフォークが適用された場合、ブロック番号は1回だけチェックサムに入力されます。
  - ブロック番号は`uint64`整数として扱われ、チェックサムに入力する際はビッグエンディアン形式でエンコードされます。
  - チェーンがフロンティアルールセットではない別のルールセットでジェネシスを持つ場合、それはフォークとは見なされません。
- **`FORK_NEXT`**: 次の予定されているフォークのブロック番号(`uint64`)、または次のフォークが知られていない場合は`0`。

たとえば、メインネットの`FORK_HASH`は以下のようになります:

- forkhash₀ = `0xfc64ec04` (ジェネシス) = `CRC32(<genesis-hash>)`
- forkhash₁ = `0x97c2c34c` (ホームステッド) = `CRC32(<genesis-hash> || uint64(1150000))`
- forkhash₂ = `0x91d1f948` (DAO フォーク) = `CRC32(<genesis-hash> || uint64(1150000) || uint64(1920000))`

*フォーク識別子*は`RLP([FORK_HASH, FORK_NEXT])`と定義されます。この`forkid`は、リモートチェーンの互換性を評価するために相互に検証されます(**単純に比較されるのではなく**)。フォーク状態に関係なく、両当事者が同じ結論に達する必要があり、一方からの無限の再接続試行を避けます。

#### 検証ルール

- 1) ローカルとリモートの`FORK_HASH`が一致する場合、ローカルのヘッドと`FORK_NEXT`を比較します。
  - 2つのノードは現在同じフォーク状態にあります。将来のフォークについて知っている情報が異なる可能性がありますが、フォークがトリガーされるまでは関係ありません(延期される可能性があり、ノードがそれに合わせてアップデートされる可能性があります)。
    - 1a) リモートでアナウンスされたが、リモートではまだ通過していないブロックが、ローカルですでに通過している場合、チェーンが互換性がないため切断します。
    - 1b) リモートでアナウンスされたフォークがない; またはまだローカルで通過していない場合、接続します。

- 2) リモートの`FORK_HASH`がローカルの過去のフォークのサブセットであり、リモートの`FORK_NEXT`がローカルの次のフォークブロック番号と一致する場合、接続します。
  - リモートノードは現在同期中です。最終的には私たちと分岐する可能性がありますが、現時点では十分な情報がありません。
- 3) リモートの`FORK_HASH`がローカルの過去のフォークのスーパーセットであり、ローカルで知られている将来のフォークで補完できる場合、接続します。
  - ローカルノードは現在同期中です。最終的にはリモートと分岐する可能性がありますが、現時点では十分な情報がありません。
- 4) その他の場合は拒否します。

#### 古いソフトウェアの例

以下の例は、ノードがマッチするソフトウェアバージョンを実行していない場合に発生する可能性のあるフォークの組み合わせを網羅しようとしています。ただし、それ以外は同じチェーン（メインネットノード、テストネットノードなど）に従っています。

| 過去のフォーク | 将来のフォーク | ヘッド | リモートの`FORK_HASH` | リモートの`FORK_NEXT` | 接続 | 理由 |
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
| A | | | A | | はい (1b) | 同じフォーク、同期状態。 |
| A | | < B | A | B | はい (1b) | リモートがフューチャーフォークをアナウンスしていますが、それは不確実です。 |
| A | | >= B | A | B | いいえ (1a) | リモートがローカルで通過したフューチャーフォークをアナウンスしています。 |
| A | B | | A |  | はい (1b) | ローカルが将来のフォークを知っていますが、それは不確実です。 |
| A | B | | A | B | はい (1b) | 両者が将来のフォークを知っていますが、それは不確実です。 |
| A | B1 | < B2 | A | B2 | はい (1b) | 両者が異なる将来のフォークを知っていますが、それらは不確実です。 |
| A | B1 | >= B2 | A | B2 | いいえ (1a) | 両者が異なる将来のフォークを知っていますが、リモートのものがローカルで通過しています。 |
| [A,B] | | | A | B | はい (2) | リモートは同期が遅れています。 |
| [A,B,C] | | | A | B | はい¹ (2) | リモートは同期が遅れています。リモートはソフトウェアアップデートが必要ですが、まだわかりません。 |
| A | B | | A ⊕ B | | はい (3) | ローカルは同期が遅れています。 |
| A | B,C | | A ⊕ B | | はい (3) | ローカルは同期が遅れています。ローカルも将来のフォークを知っていますが、それはまだ不確実です。 |
| A | | | A ⊕ B | | いいえ (4) | ローカルはソフトウェアアップデートが必要です。 |
| A | B | | A ⊕ B ⊕ C | | いいえ² (4) | ローカルはソフトウェアアップデートが必要です。 |
| [A,B] | | | A | | いいえ (4) | リモートはソフトウェアアップデートが必要です。 |

*注意、表に非対称性があり、¹と²でマークされています。リモートノードの将来のフォークリスト（次のものだけ）にアクセスできないため、ソフトウェアが古いことを検出できません。これは許容できます。なぜなら1) リモートノードは結局私たちから切断するでしょう、2) これは同期中の一時的な問題であり、遺産ノードとの永続的なものではないからです。*

## 根拠

##### なぜ`FORK_HASH`を4バイトにフラット化するのですか? なぜジェネシスとフォークのリスト全体を共有しないのですか?

`eth`devp2pプロトコルでは任意の量のデータを送信できますが、ディスカバリープロトコルのENRエントリ全体の許容スペースは300バイトです。

`FORK_HASH`を4バイトのチェックサムに縮小することで、ENRに将来の拡張のための十分な余地を確保できます。また、4バイトは（実用的な）
衝突の観点から、任意の数のイーサリアムネットワークに十分な大きさです。

##### なぜKeccak256ではなくIEEE CRC32をチェックサムとして使うのですか?

任意のデータを4バイトにフラット化し、入力のどの部分も無視しないメカニズムが必要です。他のチェックサムやハッシュアルゴリズムでも機能しますが、ノードがいつでも嘘をつくことができるため、暗号化ハッシュ関数には価値がありません。

Keccak256ハッシュの最初の4バイトを取るのは（奇妙に見える）、または4バイトグループをXORするのは（雑然としている）代わりに、CRC32の方が良い選択肢です。これは本来の設計目的そのものです。IEEE CRC32は、イーサネット、gzip、zip、pngなどでも使用されているため、すべてのプログラミング言語でサポートされていないはずはありません。

##### `FORK_NEXT`をあまり使っていないので、何か方法で取り除くことはできませんか?

リモートノードが同期遅れているのか、ソフトウェアが古いのかを区別できるようにする必要があります。過去のフォークだけを共有しても、ノードが正当に遅れているのか、古いままなのかを判断できません。

##### 将来のフォークをすべて「ハッシュ化」するのではなく、代わりに1つの次のフォークだけをアドバタイズするのはなぜですか?

私たちにとって既に通過した過去のフォークとは対照的に、将来のフォークについては何も知りません。同期が遅れているのかもしれませんし、フォークがまだ通過していないのかもしれません。まだ通過していない場合、延期される可能性があるため、それを強制するとネットワークが分断されます。また、まだ将来のすべてのフォークを認識していない（ソフトウェアをしばらく更新していない）可能性もあります。

## 下位互換性

このEIPはアイデンティティスキームのみを定義しており、機能的な変更は定義していません。

## テストケース

以下は、メインネット、Ropsten、Rinkeby、Görlisが（執筆時点の）ペテルスブルグフォークキャップで広告できるすべての可能なフォークIDのフルテストスイートです。

```go
type testcase struct {
	head uint64
	want ID
}
tests := []struct {
	config  *params.ChainConfig
	genesis common.Hash
	cases   []testcase
}{
	// メインネットのテストケース
	{
		params.MainnetChainConfig,
		params.MainnetGenesisHash,
		[]testcase{
			{0, ID{Hash: 0xfc64ec04, Next: 1150000}},       // 同期していない
			{1149999, ID{Hash: 0xfc64ec04, Next: 1150000}}, // 最後のフロンティアブロック
			{1150000, ID{Hash: 0x97c2c34c, Next: 1920000}}, // 最初のホームステッドブロック
			{1919999, ID{Hash: 0x97c2c34c, Next: 1920000}}, // 最後のホームステッドブロック
			{1920000, ID{Hash: 0x91d1f948, Next: 2463000}}, // 最初のDAOブロック
			{2462999, ID{Hash: 0x91d1f948, Next: 2463000}}, // 最後のDAOブロック
			{2463000, ID{Hash: 0x7a64da13, Next: 2675000}}, // 最初のタンジェリンブロック
			{2674999, ID{Hash: 0x7a64da13, Next: 2675000}}, // 最後のタンジェリンブロック
			{2675000, ID{Hash: 0x3edd5b10, Next: 4370000}}, // 最初のスプーリアスブロック
			{4369999, ID{Hash: 0x3edd5b10, Next: 4370000}}, // 最後のスプーリアスブロック
			{4370000, ID{Hash: 0xa00bc324, Next: 7280000}}, // 最初のビザンチウムブロック
			{7279999, ID{Hash: 0xa00bc324, Next: 7280000}}, // 最後のビザンチウムブロック
			{7280000, ID{Hash: 0x668db0af, Next: 0}},       // 最初と最後のコンスタンティノープル、最初のペテルスブルグブロック
			{7987396, ID{Hash: 0x668db0af, Next: 0}},       // 現在のペテルスブルグブロック
		},
	},
	// Ropstenのテストケース
	{
		params.TestnetChainConfig,
		params.TestnetGenesisHash,
		[]testcase{
			{0, ID{Hash: 0x30c7ddbc, Next: 10}},            // 同期していない、最後のフロンティア、ホームステッド、最初のタンジェリンブロック
			{9, ID{Hash: 0x30c7ddbc, Next: 10}},            // 最後のタンジェリンブロック
			{10, ID{Hash: 0x63760190, Next: 1700000}},      // 最初のスプーリアスブロック
			{1699999, ID{Hash: 0x63760190, Next: 1700000}}, // 最後のスプーリアスブロック
			{1700000, ID{Hash: 0x3ea159c7, Next: 4230000}}, // 最初のビザンチウムブロック
			{4229999, ID{Hash: 0x3ea159c7, Next: 4230000}}, // 最後のビザンチウムブロック
			{4230000, ID{Hash: 0x97b544f3, Next: 4939394}}, // 最初のコンスタンティノープルブロック
			{4939393, ID{Hash: 0x97b544f3, Next: 4939394}}, // 最後のコンスタンティノープルブロック
			{4939394, ID{Hash: 0xd6e2149b, Next: 6485846}}, // 最初のペテルスブルグブロック
			{6485845, ID{Hash: 0xd6e2149b, Next: 6485846}}, // 最後のペテルスブルグブロック
			{6485846, ID{Hash: 0x4bc66396, Next: 0}},       // 最初のイスタンブールブロック
			{7500000, ID{Hash: 0x4bc66396, Next: 0}},       // 将来のイスタンブールブロック
		},
	},
	// Rinkebyのテストケース
	{
		params.RinkebyChainConfig,
		params.RinkebyGenesisHash,
		[]testcase{
			{0, ID{Hash: 0x3b8e0691, Next: 1}},             // 同期していない、最後のフロンティアブロック
			{1, ID{Hash: 0x60949295, Next: 2}},             // 最初と最後のホームステッドブロック
			{2, ID{Hash: 0x8bde40dd, Next: 3}},             // 最初と最後のタンジェリンブロック
			{3, ID{Hash: 0xcb3a64bb, Next: 1035301}},       // 最初のスプーリアスブロック
			{1035300, ID{Hash: 0xcb3a64bb, Next: 1035301}}, // 最後のスプーリアスブロック
			{1035301, ID{Hash: 0x8d748b57, Next: 3660663}}, // 最初のビザンチウムブロック
			{3660662, ID{Hash: 0x8d748b57, Next: 3660663}}, // 最後のビザンチウムブロック
			{3660663, ID{Hash: 0xe49cab14, Next: 4321234}}, // 最初のコンスタンティノープルブロック
			{4321233, ID{Hash: 0xe49cab14, Next: 4321234}}, // 最後のコンスタンティノープルブロック
			{4321234, ID{Hash: 0xafec6b27, Next: 5435345}}, // 最初のペテルスブルグブロック
			{5435344, ID{Hash: 0xafec6b27, Next: 5435345}}, // 最後のペテルスブルグブロック
			{5435345, ID{Hash: 0xcbdb8838, Next: 0}},       // 最初のイスタンブールブロック
			{6000000, ID{Hash: 0xcbdb8838, Next: 0}},       // 将来のイスタンブールブロック
		},
	},
	// Görlisのテストケース
	{
		params.GoerliChainConfig,
		params.GoerliGenesisHash,
		[]testcase{
			{0, ID{Hash: 0xa3f5ab08, Next: 1561651}},       // 同期していない、最後のフロンティア、ホームステッド、タンジェリン、スプーリアス、ビザンチウム、コンスタンティノープル、最初のペテルスブルグブロック
			{1561650, ID{Hash: 0xa3f5ab08, Next: 1561651}}, // 最後のペテルスブルグブロック
			{1561651, ID{Hash: 0xc25efa5c, Next: 0}},       // 最初のイスタンブールブロック
			{2000000, ID{Hash: 0xc25efa5c, Next: 0}},       // 将来のイスタンブールブロック
		},
	},
}
```

 以下は、メインネットノードが置かれる可能性のある異なる状態と、検証し受け入れるか拒否するように求められる可能性のある異なるリモートフォーク識別子のテストスイートです:

```go
tests := []struct {
	head uint64
	id   ID
	err  error
}{
	// ローカルはメインネットのペテルスブルグ、リモートも同じをアナウンス。次のフォークはアナウンスされていません。
	{7987396, ID{Hash: 0x668db0af, Next: 0}, nil},

	// ローカルはメインネットのペテルスブルグ、リモートも同じをアナウンス。リモートはまた0xffffffffブロックでの次のフォークもアナウンスしますが、それは不確実です。
	{7987396, ID{Hash: 0x668db0af, Next: math.MaxUint64}, nil},

	// ローカルはメインネットでビザンチウムのみ（したがってペテルスブルグを認識している）、リモートもビザンチウムをアナウンスしますが、まだペテルスブルグを認識していません（たとえばフォーク前に更新されていないノード）。この場合、ペテルスブルグがまだ通過したかどうかはわかりません。
	{7279999, ID{Hash: 0xa00bc324, Next: 0}, nil},

	// ローカルはメインネットでビザンチウムのみ（したがってペテルスブルグを認識している）、リモートもビザンチウムをアナウンスし、ペテルスブルグも認識しています（たとえばフォーク前に更新されたノード）。ペテルスブルグがまだ通過したかどうか（通過するか）はわかりません。
	{7279999, ID{Hash: 0xa00bc324, Next: 7280000}, nil},

	// ローカルはメインネットでビザンチウムのみ（したがってペテルスブルグを認識している）、リモートもビザンチウムをアナウンスし、ランダムなフォーク（たとえば誤設定されたペテルスブルグ）も認識しています。どちらのフォークもどちらのノードでも通過していないため、不一致の可能性がありますが、とりあえず接続します。
	{7279999, ID{Hash: 0xa00bc324, Next: math.MaxUint64}, nil},

	// ローカルはメインネットのペテルスブルグ、リモートはビザンチウムとペテルスブルグの知識をアナウンス。リモートは単に同期が遅れているだけ、受け入れます。
	{7987396, ID{Hash: 0xa00bc324, Next: 7280000}, nil},

	// ローカルはメインネットのペテルスブルグ、リモートはスプーリアスとビザンチウムの知識をアナウンス。リモートは確実に同期が遅れています。ペテルスブルグのアップデートが必要かどうかはわかりません。
	{7987396, ID{Hash: 0x3edd5b10, Next: 4370000}, nil},

	// ローカルはメインネットのビザンチウム、リモートはペテルスブルグをアナウンス。ローカルは同期が遅れている、受け入れます。
	{7279999, ID{Hash: 0x668db0af, Next: 0}, nil},

	// ローカルはメインネットのスプーリアス、リモートはビザンチウムをアナウンスしますが、さらなるフォークは認識していません。ローカルは同期が遅れています。ローカルも将来のフォークを知っていますが、それはまだ不確実です。
	{4369999, ID{Hash: 0xa00bc324, Next: 0}, nil},

	// ローカルはメインネットのペテルスブルグ。リモートはビザンチウムをアナウンスしますが、さらなるフ
ォークを認識していません。リモートはソフトウェアアップデートが必要です。
	{7987396, ID{Hash: 0xa00bc324, Next: 0}, ErrRemoteStale},

	// ローカルはメインネットのペテルスブルグ、さらなるフォークを認識していません。リモートはペテルスブルグ + 0xffffffffをアナウンス。ローカルはソフトウェアアップデートが必要、拒否します。
	{7987396, ID{Hash: 0x5cddc0e1, Next: 0}, ErrLocalIncompatibleOrStale},

	// ローカルはメインネットのビザンチウム、ペテルスブルグを認識しています。リモートはペテルスブルグ + 0xffffffffをアナウンス。ローカルはソフトウェアアップデートが必要、拒否します。
	{7279999, ID{Hash: 0x5cddc0e1, Next: 0}, ErrLocalIncompatibleOrStale},

	// ローカルはメインネットのペテルスブルグ、リモートはRinkebyのペテルスブルグ。
	{7987396, ID{Hash: 0xafec6b27, Next: 0}, ErrLocalIncompatibleOrStale},

	// ローカルはメインネットのペテルスブルグ、遥か未来。リモートは88888888ブロックで自身のために「Gopherium」（存在しないフォーク）をアナウンス。ローカルは互換性がありません。
	//
	// このケースは、ほとんどのハッシュパワーを持つアップグレードされていないノードを検出します（典型的なRopsten混乱）。
	{88888888, ID{Hash: 0x668db0af, Next: 88888888}, ErrLocalIncompatibleOrStale},

	// ローカルはメインネットのビザンチウム。リモートもビザンチウムにいますが、ペテルスブルグ前の7279999ブロックで「Gopherium」（存在しないフォーク）をアナウンス。ローカルは互換性がありません。
	{7279999, ID{Hash: 0xa00bc324, Next: 7279999}, ErrLocalIncompatibleOrStale},
}
```

RLP エンコーディングを適切に検証するためのテストケースもいくつか用意しました（`FORK_HASH`は4バイトのバイナリですが、`FORK_NEXT`は8バイトの量です）:

```go
tests := []struct {
  id   ID
  want []byte
}{
  {
    ID{Hash: 0, Next: 0},
    common.Hex2Bytes("c6840000000080"),
  },
  {
    ID{Hash: 0xdeadbeef, Next: 0xBADDCAFE},
    common.Hex2Bytes("ca84deadbeef84baddcafe"),
  },
  {
    ID{Hash: math.MaxUint32, Next: math.MaxUint64},
    common.Hex2Bytes("ce84ffffffff88ffffffffffffffff"),
  },
}
```

## 実装

Geth: https://github.com/ethereum/go-ethereum/tree/master/core/forkid

## 著作権

著作権およびその関連権利は[CC0](../LICENSE.md)で放棄されています。