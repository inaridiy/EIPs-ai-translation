---
original: 93163cf7d1538da83aec4e696dcdd69059aa42c438d2ac848741101cd655a9dc
---

---
eip: 2315
title: EVM用のシンプルなサブルーチン
description: 効率的、安全、静的なサブルーチンのための2つのオペコード。
author: Greg Colvin (@gcolvin)、Martin Holst Swende (@holiman)、Brooklyn Zelenka (@expede)、John Max Skaller <skaller@internode.on.net>
discussions-to: https://ethereum-magicians.org/t/eip-2315-simple-subroutines-for-the-evm/3941
status: 撤回
type: Standards Track
category: Core
created: 2019-10-17
requires: 3540, 3670, 4200
withdrawal-reason: このプロポーザルはEOFプロポーザルによって置き換えられました。
---

## 概要

このプロポーザルは、完全で効率的、安全、静的な制御フロー機能を提供します。

サブルーチンの呼び出しと返却をサポートする2つの新しいオペコードを導入します:

* `RJUMPSUB relative_offset` -- サブルーチンへの相対ジャンプ
* `RETURNSUB` -- 最後の `RJUMPSUB` の後に `PC` に戻る

[EIP-4200](./eip-4200.md)で提案された2つの新しいオペコードに依存しています:

* `RJUMP relative_offset` — `PC + relative_offset` への相対ジャンプ
* `RJUMPI relative_offset` — 条件付き相対ジャンプ

`JUMP` と `JUMPI` を非推奨にし、ストリーミング、ワンパス、その他の準線形コンパイラをサポートする有効なコードを可能にします。

[EIP-3540](./eip-3540.md) と [EIP-3670](./eip-3670.md) と連携して、初期化時に有効なコードが無効な命令や無効な場所にジャンプしない、スタックアンダーフローを起こさない、サブルーチンの入出力の整合性を維持する、再帰がない場合にスタックの高さが有界であることを保証します。

これは、これらの要件を満たす最も単純な提案の1つです。

## 動機

### 完全な制御フロー機能

ジャンプ、条件付きジャンプ、サブルーチンは、1945年にAlan Turingによって提案された、コードのロジックと記憶装置の設計を組織化するための手段でした:
> 計算の結果に応じて、命令列を様々な地点で分岐させ、異なる方向に継続できるようにしたいと思います...  また、操作を補助的な操作に分割することもできるようにしたいと思います... 補助的な操作を開始するには、主要な操作を中断した場所を記録し、補助的な操作の最初の命令を適用するだけです。補助的な操作が終了したら、記録を参照して主要な操作を継続します。
>
> — Alan Turing — B.E. Carpenter, R.W. Doran, "The other Turing machine." The Computer Journal, Volume 20, Issue 3, January 1977.

より現代的な言葉で言えば、命令列、ジャンプ、条件付きジャンプがブロックに命令列を分割し、サブルーチンの呼び出しと、戻り先のアドレスを保持するスタックがあります。詳細は異なりますが、同様の機能は過去75年間にわたって重要な多くのマシンで証明されてきました。物理マシンには、Burroughs 5000、CDC 7600、IBM 360、DEC PDP-11とVAX、Motorola 68000、Sun SPARC、Intel x86などがあり、Scheme、Forth、Pascal、Java、Wasm、その他の仮想マシンもあります。

これらのマシンとは異なり、Ethereum仮想マシン(EVM)にはサブルーチン操作が提供されていません。代わりに、スタックからの動的な `JUMP` 命令を使って合成する必要があります。さらに、EVMは動的ジャンプしかサポートしていないため、必要な静的な解析ができません。

### 効率的な制御フロー

手動で書く、高級言語からコンパイルする、デプロイ時に検証する、VMで解釈する、機械コードにコンパイルするのが効率的です。

静的ジャンプ、条件付きジャンプ、サブルーチンは、歴史的な経験と、以下のようにEVMでも示されるように、十分かつ時間とスペースの面で効率的です。

### 安全な制御フロー

EVMには通常よりも高い安全性の要件があります。多くのスマートコントラクトが膨大な量のイーサを制御しているだけでなく、ブロックチェーンに配置されたら欠陥を修正することができません。初期化時に重要な安全性制約をコードに対して静的に検証することを提案します。

### 静的な制御フロー

EVMの動的ジャンプには2つの大きな問題があります。まず、静的ジャンプとサブルーチンを動的ジャンプで合成すると、以下に示すように、不必要に複雑なコードでスペースとガスを無駄にします。

さらに悪いことに、任意の目的地にダイナミックにジャンプできるジャンプは、制御フローを辿るときに二次的な "パスの爆発" を引き起こす可能性があります。Ethereumにとって、これはサービス拒否の脆弱性であり、初期化時にEVMコードの安全な使用を検証したり、EVMバイトコードを機械コードにコンパイルしたりすることを妨げます。

プログラムの安全性を検証し、EVMバイトコードを時間とスペースが線形のマシンコードにコンパイルするためには、静的な制御フローが _必要_ です。

## 仕様

### オペコード

#### `RJUMPSUB (0x5f) relative_offset`

サブルーチンにコントロールを移します。

1. `PC` の即値データから `relative_offset` をデコードします。
2. 現在の `PC + 3` を `return stack` にプッシュします。
3. `PC` を `PC + relative_offset` に設定します。

`relative_offset` は現在の `PC` からの相対オフセットです。オフセットは2バイトの2の補数符号付き整数として符号化され、MSBファーストで格納されます。

ガスコストは _low_ です。

#### `RETURNSUB (0x5e)`

サブルーチンの呼び出し元にコントロールを返します。

1. `return stack` からPCをポップします。

ガスコストは _verylow_ です。

_注意:_

* _`return stack` からポップされた値は検証する必要がありません。`RJUMPSUB` と `RETURNSUB` によってのみ変更可能です。_
* _上記の説明では、これらの命令のセマンティクスを `return stack` の観点で説明しています。ただし、`return stack` の実際の状態はEVMコードから観察可能ではなく、プロトコルのコンセンサスにも重要ではありません。(たとえば、ノードの実装者は `RJUMPSUB` を `PC + 1` ではなく `PC` を `return stack` に非表示でプッシュするように実装できます。これは `RETURNSUB` が `PC + 3` の場所に制御を返すことを観察可能にする限り許可されます。)_

### 有効性

_実行_ は、イエローペーパーで定義されているように、EVMの状態の連続的な変化として定義されます。有効なコードの条件は、状態の変化によって保持されます。実行時に、命令の実行が条件に違反する場合、実行は例外的な停止状態になります。イエローペーパーでは6つのそのような状態が定義されています。

1. ガス不足
2. スタックアイテムが1024を超える
3. 静的呼び出し中の状態の変更
4. スタックアイテムが不足
5. 無効なジャンプ先
6. 無効な命令

プログラムの実行でも例外的な停止状態に陥らないことを、コードが有効であると考えたいと思います。実際には、最初の3つの条件をランタイムでテストする必要があります。ガスの量は不明、再帰の深さも不明、非再帰プログラムでさえスタックの深さの解析は非自明です。残りの条件は、コードのサイズに比例する時間とスペースで静的に検証する必要があります。

#### 有効なコードの静的制約

* すべての命令が有効でなければなりません:
   * `JUMP` と `JUMPI` 命令は有効ではありません。
* すべてのジャンプが有効でなければなりません:
   * `RJUMP`、`RJUMPI`、または `RJUMPSUB` 命令は、即値データや自身のコードセクション外のアドレスにアドレス指定してはいけません。
* スタックが有効でなければなりません:
   * `data stack` のアイテム数は常に正でなければなりません。
   * `return stack` のアイテム数は常に正でなければなりません。
* `data stack` の整合性が保たれなければなりません:
   * `data stack` の高さは
     * 現在の `stack pointer` と現在のサブルーチンの入口の `stack pointer` の絶対差です。
   * 同一の `PC` に到達可能なすべてのパスで同じでなければならず、
   * 1024を超えてはいけません。

## 根拠

これは純粋な意味論的な仕様で、コードセクションの構文に制約を設けていません。サブルーチンは連続したバイトコードの列ではなく、バイトコードの制御フローグラフのサブグラフです。EVMは単純な状態マシンです。有効なコードが機械の歯車を詰まらせないことを保証するだけです。

構文的な制約を避けることで、テールコール最適化、複数エントリーのサブルーチン、"冷たい"コードのアウトオブラインへの移動など、冗長性の削減と "ホット"コードのキャッシュ保持のための最適化を可能にします。EVMコードをワンパスでマシンコードにコンパイルしたいので、EVMコードが可能な限り最適化されていることが重要です。

### 検証

構文ではなく検証によって制約を強制します。

有効なコードの制約は、検証可能で、コードのサイズに比例する時間とスペースでコードを検証およびコンパイルできるようにカバーしています。

`RJUMP`、`RJUMPI`、`RJUMPSUB` 命令は、即値引数として相対オフセットを取ります。これは実行時に変更できません。すべてのジャンプ先を初期化時に検証できるようにするために、ジャンプ先を定数にすることは重要です。動的ジャンプは、コード内の任意の場所にジャンプできるため、制御フローグラフを辿るときに悪用可能な二次的な "パスの爆発" が可能です。`JUMP` と `JUMPI` を非推奨にすることでこれを防ぐことができます。

`data stack` の整合性を要求することで

* スタックアンダーフローを防ぐ
* サブルーチンへのすべての呼び出しが同じ数の入力と出力を持つことを保証し
* 再帰がない場合にスタックの高さが有界であることを保証します。

`data stack` の整合性を要求することで、制御フローグラフを辿るいくつかのアルゴリズム - コードの検証とコンパイルを含む - がジョインで循環を断つことができ、再び二次的な "パスの爆発" を防ぐことができます。ある `PC` に到達したときに、それ以前に訪れたことがある場合、それはループの始まりか関数の入口のどちらかです。その `PC` でのスタックの高さが一定なので、ループがスタックを増やさず、サブルーチンの引数の数が常に同じであることがわかります - そのパスをもう一度辿る必要はありません。

_注: JVMとWasmも同様の制約を同様の理由で課しています。_

### 代替設計

サブルーチン機能には主に3つの設計があり、そのうち2つを検討します。他のものはEVMには適切ではありません。例えば、Wheeler Jumpは呼び出されたサブルーチンに戻りアドレスを書き込む自己書き換えコードです。

*1. 専用の戻りスタックに戻りアドレスを保持する。* Turingの設計は、Forth、Java、Wasm、その他のスタックマシンでよく使われています。データスタックは計算に使われ、戻りアドレスのための専用のスタックがあります。呼び出しと返却にはそれぞれ1つの命令で十分です。

*2. データスタックに戻りアドレスを保持する。* この設計は、CDC、
IBM、DEC、Intel、ARMなどのレジスタマシンでよく使われています。レジスタは主に計算に使われ、スタックは戻りアドレス、引数、ローカル変数のためのフレームを維持します。EVMにはレジスタがないので、両方の目的でスタックを使うと、以下に示すような非効率が生じます。Pascalのp-codeはこの設計を使っていますが、専用のレジスタを持つ複雑な呼び出し規約の一部です。

#### 専用の戻りスタックを好む

* 計算と制御フローの明確な分離を維持します:
  * データスタックは脆弱な戻りアドレスから自由で
  * 戻りスタックを上書きするのは不可能です。
* 効率が向上します:
  * ネイティブの算術を使うので256ビットのEVM命令よりも高速で
  * 戻りアドレスのためにデータスタックのスロットを使わず
  * 256ビットのデータの移動が少なくて済みます。

### 効率性

ここでは、`JUMP` を使うのと比べて、通常のサブルーチン呼び出しと最適化されたサブルーチン呼び出しの両方で、命令とガスコストの複雑さをどのように削減できるかを示します。

#### **シンプルなサブルーチン呼び出し**

比較的最小限のサブルーチンとその呼び出しコードの例を示します。

`RJUMPSUB` を使ったサブルーチン呼び出し:
```
SQUARE:
    dup1            ; 3 gas
    mul             ; 5 gas
    returnsub       ; 3 gas

CALL_SQUARE:
    push 0x02       ; 3 gas
    rjumpsub SQUARE ; 5 gas
```
_合計ガス: 19_

`JUMP` を使ったサブルーチン呼び出し:
```
SQUARE:
    jumpdest        ; 1 gas
    swap1           ; 3 gas
    dup1            ; 3 gas
    mul             ; 5 gas
    swap1           ; 3 gas
    jump            ; 8 gas

CALL_SQUARE:
    jumpdest        ; 1 gas
    push 0x02       ; 3 gas
    push RTN_CALL:  ; 3 gas
    push SQUARE     ; 3 gas
    jump            ; 8 gas
RTN_CALL:
    jumpdest        ; 1 gas
```
_合計: 41 gas_.

`RJUMPSUB` を使うと `JUMP` を使うのに比べて _41 - 19 = 22 gas_ 、_54%_ 節約できます。

#### **テールコール最適化**

もちろん、このような場合はテールコール最適化ができ、`SQUARE` からの返却が実際には `TEST_SQUARE` からの返却になります。

`RJUMPSUB` と `RETURNSUB` を使ったテールコール最適化:
```SQUARE:
    dup1            ; 3 gas
    mul             ; 5 gas
    returnsub       ; 3 gas

CALL_SQUARE:
    push 0x02       ; 3 gas
    rjump SQUARE    ; 3 gas
```
_合計: 17 gas_


`JUMP` を使ったテールコール最適化:
```
SQUARE:
    jumpdest        ; 1 gas
    swap1           ; 3 gas
    dup1            ; 3 gas
    mul             ; 5 gas
    swap2           ; 3 gas
    jump            ; 8 gas

CALL_SQUARE:
    jumpdest        ; 1 gas
    push 0x02       ; 3 gas
    push SQUARE     ; 3 gas
    jump            ; 8 gas
```
_合計: 38 gas_

`RJUMPSUB` を使うと `JUMP` を使うのに比べて _38 - 17 = 21 gas_ 、_55%_ 節約できます。

#### 効率性の注意点

これらの命令は、`JUMP` を使うよりもシンプルでガスの節約になるサブルーチンメカニズムを提供することがわかります - 例では約半分のガスを節約しています。

明らかに、この効率性の恩恵は、コードがより小さなサブルーチンに分割されているプログラムで大きくなります。どの程度小さいか? `RJUMPSUB` と `RETURNSUB` を使ってコードをサブルーチンでラップするのは _8 gas_ しかかかりませんが、上記のように `JUMP`、`PUSH`、`SWAP` を使うと _30 gas_ もかかります。

### コスト

`JUMP` の _mid_ コストに対する `RJUMPSUB` の _low_ コストは、ネイティブの算術を使って即値の2バイトの目的地をデコードし、戻りアドレスを `return stack` にプッシュするだけで済むことで正当化されます。一方、`JUMP` はデータスタックを使った256ビットの擬似命令を使う必要があります。

`RETURNSUB` の _verylow_ コストは、`return stack` からPCをポップするだけで済むことで正当化されます。ベンチマークが必要ですが、コストのバランスが取れていると思われます。

## 後方互換性

これらの変更により、既存のEVMコードのセマンティクスに影響があります。ジャンプ先として解釈されていたバイトが、今後は即値データとして解釈される可能性があります。このプロポーザルはイーサリアムオブジェクトフォーマットに依存しているので、これは実用的な問題ではありません。

## テストケース

### シンプルなルーチン

これはサブルーチンに飛び込み、抜け出して停止するはずです。

バイトコード: `0x5f0003005e` (`RJUMPSUB 3, RETURNSUB, STOP`)

|  Pc   |      Op     | Cost |   Stack   |   RStack  |
|-------|-------------|------|-----------|-----------|
|    0  |   RJUMPSUB  |    5 |        [] |        [] |
|    2  |       STOP  |    0 |        [] |        [] |
|    3  |  RETURNSUB  |    3 |        [] |        [] |

Output: 0x
Consumed gas: `10`

### 2階層のサブルーチン

これは問題なく実行されるはずで、2階層のサブルーチンに入っていきます。

バイトコード: `0x5f00045F00025200` (`RJUMPSUB 4, RJUMPSUB 2, RETURNSUB, RETURNSUB, STOP`)

|  Pc   |      Op     | Cost |   Stack   |   RStack  |
|-------|-------------|------|-----------|-----------|
|    0  |   RJUMPSUB  |    5 |        [] |        [] |
|    3  |   RJUMPSUB  |    5 |        [] |        [] |
|    4  |  RETURNSUB  |    5 |        [] |        [] |
|    5  |  RETURNSUB  |    5 |        [] |        [] |
|    6  |       STOP  |    0 |        [] |        [] |

Consumed gas: `20`

### 失敗1: 無効なジャンプ

これは失敗するはずです。指定された場所がコード範囲外だからです。

バイトコード: `0X5fff`(`RJUMPSUB -1`)

|  Pc   |      Op     | Cost |   Stack   |   RStack  |
|-------|-------------|------|-----------|-----------|
|    0  |   RJUMPSUB  |   10 |        [] |        [] |

```
Error: at pc=0, op=RJUMPSUB: invalid jump destination
```

### 失敗2: 浅い `return stack`

最初のオペコードで失敗するはずです。`return_stack` が浅いため。

バイトコード: `0x5e` (`RETURNSUB`)

|  Pc   |      Op     | Cost |   Stack   |   RStack  |
|-------|-------------|------|-----------|-----------|
|    0  |  RETURNSUB  |    5 |        [] |        [] |

```
Error: at pc=0, op=RETURNSUB: invalid retsub
```

### コードの最後にあるサブルーチン

この例では、RJUMPSUB がコードの最後のバイトにあります。サブルーチンが返ると、バイトコードの _後_ の "仮想的な停止" に当たるはずで、エラーで終了しないはずです。

バイトコード: `0x5c00045e5fffff` (`RJUMP 4, RETURNSUB, RJUMPSUB -1`)

|  Pc   |      Op     | Cost |   Stack   |   RStack  |
|-------|-------------|------|-----------|-----------|
|    0  |      RJUMP  |    5 |        [] |        [] |
|    3  |  RETURNSUB  |    5 |        [] |        [] |
|    4  |   RJUMPSUB  |    5 |        [] |        [] |
|    7  |       STOP  |    0 |        [] |        [] |

Consumed gas: `15`

## 参考実装

以下は、コードの有効性を判定するアルゴリズムのPseudoPythonの実装です。同等のアルゴリズムを初期化時に実行する必要があります。

このアルゴリズムは、プログラムの制御フローを記号的に実行し、上記のルールに違反していないかをチェックします。

プログラムの制御フローグラフの頂点 + 辺の数に比例する時間で実行されます。頂点はベーシックブロック、辺は制御フローを表します。したがって、アルゴリズムはコードのサイズに比例する時間で実行されます。条件付きジャンプの継続のためのスタックを維持しますが、その最大サイズはコードのサイズに比例します。

### 検証関数

** 注: この関数は不完全で間違っていることが知られています。 **

簡単のため、EIP-3540、EIP-3670、EIP-4200を含むジャンプ先の解析と事前の検証がすでに行われていると仮定します。つまり、EOF ヘッダーとセクションは適切に構成されており、無効な命令やジャンプはありません。実際には、すべての検証パスを1つのループに折り込むことができます。

いくつかのヘルパー関数も仮定しています。
* `is_valid(opcode)` はオペコードが有効であれば true を返します。
* `is_terminator(opcode)` はオペコードが終端子であれば true を返します。
* `is_valid_jumpdest(pc)` は `pc` が有効なジャンプ先であれば true を返します。
* `immediate_data(pc)` は `pc` の命令の即値データを返します。
* `immediate_size(opcode)` はオペコードの即値データのサイズを返します。
* `removed_items(opcode)` はオペコードによって `data_stack` から削除されるアイテム数を返します。
* `added_items(opcode)` はオペコードによって `data_stack` に追加されるアイテム数を返します。

```
# コードが有効であれば true を返す
def validate_code(code: bytes, pc: int, sp: int, bp: int) -> boolean:
    continuations = []
    do
        while pc < len(code):
            opcode = code[pc]
            if !is_valid(opcode):
                return false
            if is_terminator(opcode):
                return true

            # スタックの高さをチェックし、以前に訪れたことがあれば返す
            stack_height = sp - bp
            if stack_height > 1024
                return false
            if pos in stack_heights:
                if stack_height != stack_heights[pos]:
                    return false
                return true
            else:
                stack_heights[pos] = stack_height

            if opcode == RJUMP:

                # ジャンプ先のpcにリセットする
                jumpdest = immediate_data(pc)
                pc += jumpdest
                if !is_valid_jumpdest(pc)
                    return false

            elif opcode == RJUMPI:

                jumpdest = pc + immediate_data(pc)
                if !is_valid_jumpdest(pc)
                    return false

                # 条件の真側は後で継続する
                continations.push((jumpdest, sp, bp))

                # 条件の偽側は今継続する

            elif opcode == RJUMPSUB:

                # サブルーチンの入口に入る
                bp = sp

                # 戻りアドレスをプッシュし、pcを目的地にリセットする
                jumpdest = pc + immediate_data(pc)
                if !is_valid_jumpdest(pc)
                    return false
                push(return_stack, pc + 3)
                pc = jumpdest
                continue

            elif opcode == RETURNSUB:

                # サブルーチンの出口に戻る
                bp = sp

                # 戻りアドレスをポップし、呼び出し元をチェックする
                pc = pop(return_stack)
                if code[pc - 3] != RJUMPSUB:
                   return false

            # スタックに命令を適用する
            sp -= removed_items(opcode)
            if sp < 0
                return false
            sp += added_items(opcode)

            # オペコードと即値データをスキップする
            pc += 1 + immediate_size(opcode)

        while (pc, sp, bp) = continuations.pop()

    return true
```

## セキュリティ上の考慮事項

これらの変更により、新しい制御フロー命令が導入されます。新しいセキュリティ上の考慮事項は導入されません。このEIPは、ブロックチェーンにデ
プロイされたEVMコードの安全性を検証することで、セキュリティを向上させることを目的としています。検証アルゴリズムは時間とスペースが準線形でなければ、サービス拒否の脆弱性になります。ここで示したアルゴリズムは、バイトコードを1回線形時間で走査し、`RJUMPI` 命令の数を超えないスタックのコンティニュエーションを使用します。

## 著作権
著作権およびそれに関連する権利は[CC0](../LICENSE.md)で放棄されています。