---
original: c0e7a2e793f3fa44f048b772a3fb4779199d29b6d240c97e3723ace1e46e1c40
---

---
eip: 1153
title: 一時的なストレージオペコード
description: 取引後に破棄される、ストレージとほぼ同じ動作をする状態を操作するためのオペコードを追加する
author: Alexey Akhunov (@AlexeyAkhunov), Moody Salem (@moodysalem)
discussions-to: https://ethereum-magicians.org/t/eip-transient-storage-opcodes/553
status: 最終
type: 標準トラック
category: コア
created: 2018-06-15
requires: 2200, 3529
---

## 概要

このプロポーザルでは、一時的なストレージオペコードを導入します。これらのオペコードは、ストレージと同じように動作しますが、取引後に一時的なストレージは破棄され、`TSTORE`は[EIP-2200](./eip-2200.md)で定義されているガスの支払い要件の対象外となります。つまり、一時的なストレージの値はストレージからデシリアライズされたり、ストレージにシリアライズされることはありません。したがって、ディスクアクセスが不要なため、一時的なストレージはより安価です。一時的なストレージは、2つの新しいオペコード `TLOAD` と `TSTORE` を使ってスマートコントラクトからアクセスできます。ここで「T」は「一時的な」を意味します。

```
TLOAD  (0x5c)
TSTORE (0x5d)
```

## 動機

Ethereumでトランザクションを実行すると、`CALL`(または同様の)命令によって作成された複数のネストされた実行フレームが生成されます。コントラクトは同じトランザクション内で再入力される可能性があり、その場合、1つのコントラクトに属する複数のフレームが存在します。現在、これらのフレームは2つの方法で通信できます。1つは`CALL`命令を介して入力/出力を渡すことで、もう1つはストレージの更新を介することです。信頼できない別のコントラクトに属する中間フレームがある場合、入力/出力を介した通信は安全ではありません。再入力ロックがその典型的な例で、中間フレームがロックの状態を渡すことに依存することはできません。ストレージ(`SSTORE`/`SLOAD`)を介した通信は高コストです。一時的なストレージは、フレーム間通信のための専用で効率的なソリューションです。

また、フレーム間通信によって蓄積されたストレージリファンドは、[EIP-3529](./eip-3529.md)(ロンドンハードフォークで導入)により、トランザクションで使用されたガスの20%に制限されています。これにより、それ以外は低コストのトランザクションでの一時的に設定されたストレージスロットのリファンドが大幅に減少します。たとえば、1つの再入力ロックの完全なリファンドを受け取るには、他の操作に約80kガスを使う必要があります。

言語サポートは比較的簡単に追加できます。たとえば、Solidityでは、既存の修飾子`memory`と`storage`、およびJavaの`transient`キーワードと同様の意味を持つ修飾子`transient`を導入できます。`TSTORE`と`TLOAD`のアドレッシングスキームは`SSTORE`と`SLOAD`と同じなので、ストレージ変数用に存在するコード生成ルーチンを一時的なストレージにも簡単に一般化できます。

このEIPによって可能になるか改善される潜在的なユースケースには以下のようなものがあります:

1. 再入力ロック
2. オンチェーンで計算可能なCREATE2アドレス: コンストラクタ引数がイニシャルコードハッシュの一部として渡されるのではなく、ファクトリコントラクトから読み取られる
3. 単一のトランザクション[ERC-20](./eip-20.md)承認、例: `#temporaryApprove(address spender, uint256 amount)`
4. 転送時手数料コントラクト: トークンコントラクトに手数料を支払って、トランザクションの期間中の転送をロック解除する
5. "Till"パターン: ユーザーがコールバックの一部としてすべてのアクションを実行できるようにし、最後に"Till"がバランスしていることを確認する
6. プロキシコールメタデータ: 不変のプロキシコンストラクタ引数の値などの、追加のメタデータを実装コントラクトに渡す

これらのオペコードは`SSTORE`と`SLOAD`オペコードよりも効率的に実行できます。なぜなら、元の値を読み込む必要がないからです(つまり、常に0です)。ガスの会計ルールもより単純で、リファンドは不要です。

## 仕様

2つの新しいオペコード `TLOAD` (`0x5c`)と `TSTORE` (`0x5d`)がEVMに追加されます。(以前のこのEIPのドラフトでは、他のEIPとの競合を避けるために、`TLOAD`と`TSTORE`にそれぞれ`0xb3`と`0xb4`を指定していましたが、その競合は解消されています。)

これらは`SLOAD` (`0x54`)と`SSTORE` (`0x55`)と同じスタック引数を使用します。

`TLOAD`は、スタックの一番上から32バイトのワードを1つポップし、その値をアドレスとして扱い、その場所の一時的なストレージから32バイトのワードを取得し、それをスタックの一番上にプッシュします。

`TSTORE`は、スタックの一番上から32バイトのワードを2つポップします。一番上のワードがアドレス、次のワードが値です。`TSTORE`は、指定されたアドレスに値を一時的なストレージに保存します。

アドレッシングは`SLOAD`と`SSTORE`と同じです。つまり、各32バイトのアドレスは一意の32バイトのワードを指します。

`TSTORE`のガスコストは、汚れたスロット(つまり、元の値が新しい値でも現在の値でもない)への温かい`SSTORE`と同じ(現在100ガス)で、`TLOAD`のガスコストは、値が以前に読み取られた(つまり、ホット)`SLOAD`と同じ(現在100ガス)です。トランザクションの巻き戻しとの相互作用のため、メモリアクセスと同等のコストにはできません。

一時的なストレージのすべての値は、トランザクション終了時に破棄されます。

一時的なストレージは、永続ストレージと同様に、それを所有するコントラクトにプライベートです。所有コントラクトのフレームのみが自身の一時的なストレージにアクセスできます。そして、アクセスする際は、永続ストレージと同様に、すべてのフレームが同じ一時的なストアにアクセスしますが、メモリとは異なります。

一時的なストレージが`DELEGATECALL`または`CALLCODE`のコンテキストで使用される場合、一時的なストレージの所有コントラクトは`DELEGATECALL`または`CALLCODE`命令を発行したコントラクト(呼び出し元)になります。一時的なストレージが`CALL`または`STATICCALL`のコンテキストで使用される場合、一時的なストレージの所有コントラクトは`CALL`または`STATICCALL`命令のターゲットコントラクト(被呼び出し側)になります。

フレームが巻き戻された場合、フレームの入力から返却までに行われたすべての一時的なストレージへの書き込みが巻き戻されます。これは永続ストレージの動作と同じです。

`TSTORE`オペコードが`STATICCALL`のコンテキストで呼び出された場合、変更は行われずに例外が発生します。`TLOAD`は`STATICCALL`のコンテキストで許可されています。

一時的なストレージのオペコードの動作は、ストレージのオペコードとは異なり、`TSTORE`は[EIP-2200](./eip-2200.md)で定義されているガス残量(`_gasleft()`)の要件の対象外です。

## 根拠

フレーム間通信の問題を解決する別のオプションは、一時的なストレージの使用例向けに`SSTORE`と`SLOAD`オペコードの価格を下げることです。これは[EIP-2200](./eip-2200.md)で既に行われています。しかし、[EIP-3529](./eip-3529.md)ではリファンドの上限が取引ガスコストの20%に削減されたため、一時的なストレージの使用が大幅に制限されています。

別のアプローチは、一時的なストレージのリファンドカウンターを他のストレージ用途のリファンドカウンターとは別に保ち、一時的なストレージのリファンド上限を削除することです。ただし、この方法は実装と理解が複雑です。たとえば、20%のリファンド上限は、ガス使用量から未キャップのガスリファンドを差し引いた後に適用する必要があります。そうしないと、一時的なストレージの書き込みを実行することで、20%のリファンド上限の対象となるガス量を増やすことができます。したがって、リファンドカウンターとは別のメカニズムを持つことが好ましいです。将来のハードフォークでは、一時的なストレージのユースケースをサポートするための複雑なリファンド動作を削除し、より効率的なコントラクトへの移行を促進できます。

ワードアドレス型のストレージライクなインターフェイスに対する既知の異論は、一時的なストレージがライフサイクルではメモリに近いことです。バイトアドレス型のメモリライクなインターフェイスも選択肢の1つです。トランザクションスコープのメモリ領域との組み合わせで有用なマッピングを使えるため、ワードアドレス型のストレージライクなインターフェイスが好ましいとされています。たとえば、[ERC-20](./eip-20.md)の一時的な承認のユースケースでは、`(owner, spender)`へのマッピングを使う必要があります。リニアメモリでマッピングを実装するのは難しく、リニアメモリにはダイナミックなガスコストも必要です。また、巻き戻しを扱うのも複雑です。任意のオフセットでストアできるマップを使ってメモリライクなインターフェイスを実現することも可能ですが、コンパイラに新しいコードパスを追加する必要があり、メモリとストレージの中間的なインターフェイスになってしまいます。

一部の人は、一時的なストレージの代替として、トランザクション固有の識別子を使うことが必要ないと考えていますが、これは誤解です。トランザクション識別子を通常のストレージと組み合わせても、このEIPを動機付けるのと同じ問題があります。2つの機能は直交しています。

このEIPの相対的な欠点:

- 既存のコントラクトの一時的なストレージの使用に対処していない
- クライアントに新しいコードが必要
- イエローペーパーに新しい概念を追加する必要がある(更新が必要)

このEIPの相対的な利点:

- 一時的なストレージオペコードはプロトコルアップグレードで個別に検討され、意図せずに壊れることがない(例: [EIP-3529](./eip-3529.md))
- クライアントは元の値を読み込む必要がない
- 非一時的な書き込みのための前払いガストがない
- 既存の操作のセマンティクスを変更しない
- 使用後にストレージスロットをクリアする必要がない
- ガス会計ルールがより単純
- 将来のストレージ設計(例: Verkleツリー)では一時的なストレージのリファンドを考慮する必要がない

## 下位互換性

このEIPを実装するにはハードフォークが必要です。

既存のオペコードの動作を変更しないため、すべての既存のスマートコントラクトと下位互換性があります。

## テストケース

このEIPのテストスイートは[こちら](https://github.com/ethereum/execution-spec-tests/tree/1983444bbe1a471886ef7c0e82253ffe2a4053e1/tests/cancun/eip1153_tstore)にあります。

## 参考実装

一時的なストレージは、単一のトランザクション内で永続ストレージと同様の巻き戻し動作をする必要があるため、トランザクション内で一時的なストレージの以前の状態に巻き戻せる必要があります。同時に、巻き戻しは例外的なケースであり、読み取り、書き込み、返却は安価
であることが推奨されます。これは以下の時間計算量を持ちます:

- コールフレームに入るときに、コールマーカーがリストに追加される - `O(1)`
- 新しい値は現在の状態に書き込まれ、前の値がジャーナルに書き込まれる - `O(1)`
- コールが正常に終了すると、そのコールが開始されたときのジャーナルインデックスのマーカーが破棄される - `O(1)`
- 巻き戻しの際は、最後のチェックポイントまでの全エントリを逆順に巻き戻す - `O(N)` ただし `N` = 最後のチェックポイント以降のジャーナルエントリ数

```typescript
interface JournalEntry {
    addr: string
    key: string
    prevValue: string
}

type Journal = JournalEntry[]

type Checkpoints = Journal['length'][]

interface Current {
    [addr: string]: {
        [key: string]: string
    }
}

const EMPTY_VALUE = '0x0000000000000000000000000000000000000000000000000000000000000000'

class TransientStorage {
    /**
     * 一時的なストレージの現在の状態
     */
    private current: Current = {}
    /**
     * すべての変更がジャーナルに書き込まれる。巻き戻しの際は、最後のチェックポイントまでの変更を逆順に適用する
     */
    private journal: Journal = []
    /**
     * 各チェックポイントでのジャーナルの長さ
     */
    private checkpoints: Checkpoints = [0]

    /**
     * 指定したコントラクトアドレスとキーの現在の値を返す
     * @param addr コントラクトのアドレス
     * @param key 一時的なストレージのキー
     */
    public get(addr: string, key: string): string {
        return this.current[addr]?.[key] ?? EMPTY_VALUE
    }

    /**
     * マップに現在の値を設定する
     * @param addr キーが設定されるコントラクトのアドレス
     * @param key 設定するスロット
     * @param value スロットに設定する新しい値
     */
    public put(addr: string, key: string, value: string) {
        this.journal.push({
            addr,
            key,
            prevValue: this.get(addr, key),
        })

        this.current[addr] = this.current[addr] ?? {}
        this.current[addr][key] = value;
    }

    /**
     * 最後のチェックポイント以降の変更をすべてコミットする
     */
    public commit(): void {
        if (this.checkpoints.length === 0) throw new Error('Nothing to commit')
        this.checkpoints.pop() // 最後のチェックポイントは破棄される
    }

    /**
     * 新しいコンテキストに入るときに呼び出される。最後のチェックポイント以降の変更は巻き戻される
     */
    public checkpoint(): void {
        this.checkpoints.push(this.journal.length)
    }

    /**
     * 最後のチェックポイントの状態に一時的なストレージを巻き戻す
     */
    public revert() {
        const lastCheckpoint = this.checkpoints.pop()
        if (typeof lastCheckpoint === 'undefined') throw new Error('Nothing to revert')

        for (let i = this.journal.length - 1; i >= lastCheckpoint; i--) {
            const {addr, key, prevValue} = this.journal[i]
            // ジャーナルに書き込まれたので存在するはず
            this.current[addr][key] = prevValue
        }
        this.journal.splice(lastCheckpoint, this.journal.length - lastCheckpoint)
    }
}
```

最悪の場合の時間計算量は、1ブロックに収まる最大数のキーを書き込んでから巻き戻す場合に発生します。この場合、クライアントはジャーナルのすべてのエントリを適用するために2倍の書き込みを行う必要があります。ただし、同じ場合は既存のクライアントの状態ジャーナル実装にも適用され、以下のコードではDOSできません。

```solidity
pragma solidity =0.8.13;

contract TryDOS {
    uint256 slot;

    constructor() {
        slot = 1;
    }

    function tryDOS() external {
        uint256 i = 1;
        while (gasleft() > 5000) {
            unchecked {
                slot = i++;
            }
        }
        revert();
    }
}
```

## セキュリティ上の考慮事項

`TSTORE`は、ノードにリニアコストで メモリを割り当てる新しい方法を提供します。つまり、`TSTORE`1つで、他の必要な操作を除いて、32バイトを100ガスで保存できます。30 million ガスを使えば、`TSTORE`を使って割り当てられる最大メモリ量は:

```
30M gas * 1 TSTORE / 100 gas * 32 bytes / 1 TSTORE * 1MB / 2^20 bytes ~= 9.15MB
```

同じ量のガスを使って、`MSTORE`で割り当てられる最大メモリ量は~3.75MBです:

```
30M gas = 3x + x^2 / 512 => x = ~123,169 32-byte words
~123,169 words * 32 bytes/word * 1MB / 2^20 bytes = 3.75MB
```

ただし、各コンテキストで1M gasしか使わず、メモリ拡張コストをリセットするコールを行えば、100万ガスあたり~700KBのメモリを割り当てられ、合計で~20MBのメモリを割り当てられます:

```
1M gas = 3x + x^2 / 512 => x = ~21,872 32-byte words
30M gas * ~21,872 words / 1M gas * 32 bytes/word * 1MB / 2^20 bytes = ~20MB
```

スマートコントラクト開発者は、一時的なストレージ変数の寿命を理解する必要があります。一時的なストレージはトランザクション終了時に自動的にクリアされるため、スマートコントラクト開発者はガス節約のためにコール中のスロットのクリアを避けたくなるかもしれません。しかし、これにより同じトランザクション内の後続の操作が妨げられる(再入力ロックの場合など)か、他のバグが発生する可能性があるため、スマートコントラクト開発者は、それらのスロットが同じトランザクション内の後続のコールで使用される予定の場合を除いて、一時的なストレージスロットに0以外の値を残さないよう注意する必要があります。それ以外の点では、これらのオペコードは`SSTORE`と`SLOAD`と全く同じ動作をするため、特に再入力リスクに関して、通常のセキュリティ上の考慮事項がすべて適用されます。

スマートコントラクト開発者は、一時的なストレージをメモリマッピングの代替として使うことにも誘惑されるかもしれません。一時的なストレージはコールが返却または巻き戻されても破棄されないことに注意する必要があります(メモリとは異なる)。これらのユースケースには主にメモリは適していないため、一時的なストレージを使うべきではありません。一時的なストレージはメモリに比べて必然的に高コストであるため、このような使用パターンは既に阻害されています。メモリマッピングの大半のユースケースは、エントリのキーソート済みリストでより良く実装できます。スマートコントラクトでメモリマッピングが必要となるケースはほとんどありません(著者は本番環境での使用例を知りません)。

## 著作権

著作権およびそれに関連する権利は[CC0](../LICENSE.md)によって放棄されています。