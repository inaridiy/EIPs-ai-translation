---
original: 74424742815e4553cbf5dff48561c1ff9f3c386f39a2b0b0a13a3c1f931439b5
---

---
eip: 2926
title: チャンクベースのコードマークル化
author: Sina Mahmoodi (@s1na), Alex Beregszaszi (@axic)
discussions-to: https://ethereum-magicians.org/t/eip-2926-chunk-based-code-merkleization/4555
status: 停滞
type: Standards Track
category: Core
created: 2020-08-25
requires: 161, 170, 2584
---

## 概要

コードマークル化、トライの2進数化、およびステートアクセスオペコードのガスコスト増加は、Eth1xロードマップにおけるステートレスまたは部分的ステートレスの状況でブロックの証拠サイズを減らすための主要な手段と考えられています。ここでは、固定サイズのチャンクアプローチによるコードマークル化を詳細に説明し、既存のコントラクトをこのモデルに移行する方法を概説します。

## 動機

バイトコードは現在、ブロックの証拠サイズに対する[第2の要因](https://github.com/mandrigin/ethereum-mainnet-bin-tries-data)となっています。トライを16進数から2進数に移行することで、証拠のハッシュ部分が3倍小さくなり、コードが最大の要因となります。コントラクトコードをチャンクに分割し、それらのチャンクをマークル木に格納することで、ステートレスクライアントは特定のトランザクションの実行に必要なチャンクのみを取得すればよくなります。

## 仕様

この仕様は、[EIP-2584](./eip-2584.md)が導入されていることを前提としており、マークル化のルールとガスコストを提案しています。以下の2つのセクションで構成されています:

1. 特定のコントラクトコードをチャンクに分割してマークル化する方法
2. ハードフォーク時に既存のすべてのコントラクトコードをマークル化する方法

### 定数と定義

#### 定数

- `CHUNK_SIZE`: 32 (バイト)
- `KEY_LENGTH`: 2 (バイト)
- `MAX_CHUNK_COUNT`: `0xfffc`
- `VERSION_KEY`: `0xfffd`
- `CODELEN_KEY`: `0xfffe`
- `CODEHASH_KEY`: `0xffff`
- `VERSION`: 0
- `EMPTY_CODE_ROOT`: `0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470` (==`keccak256('')`)
- `HF_BLOCK_NUMBER`: 未定義

#### 定義

- `BE(x, N)`: `x`を`N`バイトの符号なし整数にキャストし、ビッグエンディアンで返す

### コードマークル化

アカウントレコード`A`にコード`C`がある場合、フィールド`A.codeHash`は`codeRoot`に置き換えられます。`C`が空の場合、`codeRoot`は`EMPTY_CODE_ROOT`になります。それ以外の場合は、`codeTrie`(2進数トライ)のルートが格納されます。`codeTrie`には以下のリーフが含まれます:

- キー: `VERSION_KEY`, 値: `BE(VERSION, 1)`
- キー: `CODELEN_KEY`, 値: `BE(length(C), 4)`
- キー: `CODEHASH_KEY`, 値: `keccak256(C)`

上記に加えて、`codeTrie`は以下のようなコードチャンクのリスト`chunks = [(FIO_0, code_0), ..., (FIO_n, code_n)]`をコミットします:

- `n < MAX_CHUNK_COUNT`
- `code_0 || ... || code_n == C`
- `length(code_i) == CHUNK_SIZE` (`0 <= i < n`)
- `length(code_n) <= CHUNK_SIZE`
- `FIO_i`は、チャンク内の最初の命令のオフセットです。前のチャンクの最後の命令が複数バイトの命令(例えば`PUSHN`)で、チャンク境界を越える場合にのみ0より大きくなります。チャンクのすべてのバイトがデータの場合は`CHUNK_SIZE`に設定されます。

`chunks`の`i`番目の要素は、`codeTrie`に以下のように格納されます:

- キー: `BE(i, KEY_LENGTH)`
- 値: `BE(FIO_i, 1) || code_i`(||はバイト連結)

#### コントラクト作成時のガスコスト

現在、コントラクト作成時(CREATE、CREATE2、外部トランザクションなど)にはコード1バイトあたり200ガスが課金されています。この1バイトあたりのコストは、チャンク化とマークル化のコストを考慮して、`200`から`TBD`に引き上げられます。

### 既存のコードの更新(移行プロセス)

移行プロセスでは、状態内のすべてのコントラクトを読み取り、上記の手順を適用します。この処理にかかる時間のベンチマークはまだ行われていませんが、直感的には2ブロック間の時間(数時間程度)よりも長くなると考えられます。そのため、クライアントにはEIPがアクティブになる前に事前に変更を処理することをお勧めします。

コードは(ほとんど)静的であるため、クライアントは`[accountAddress -> codeRoot]`のマッピングを維持し、既にマークル化したコントラクトの結果を保持できます。この事前計算フェーズでは、新しいコントラクトが作成されるたびに`codeRoot`を計算し、マッピングに追加します。コントラクトが自己破壊されると、対応するエントリが削除されます。

EIPがアクティブになる`HF_BLOCK_NUMBER`ブロックでは、トランザクションを実行する前に、状態内の非空のコードを持つすべてのコントラクトのアカウントレコードを更新し、`codeHash`フィールドを事前計算された`codeRoot`に置き換える必要があります。EOAアカウントは`codeHash`値を`codeRoot`のままにします。*空のコードを持つアカウントは`codeHash`値を`codeRoot`のままにします。*

## 根拠

### 16進数 vs 2進数トライ

現在、Ethereumメインネットの状態は16進数のマークルパトリシアトリーでエンコードされています。Eth1xロードマップの一環として、[2進数トライ](https://ethresear.ch/t/binary-trie-format/7621)への移行が[調査](https://medium.com/@mandrigin/stateless-ethereum-binary-tries-experiment-b2c035497768)されており、証拠サイズの削減を目的としています。コードチャンクもトライに格納されるため、この EIPは2進数化による証拠サイズ削減の恩恵を受けます。そのため、[EIP-2584](./eip-2584.md)をこの変更の要件として明示的に述べています。ただし、コードマークル化がそれ以前のハードフォークに含まれる場合は、2進数への移行後にすべてのコードを再マークル化する必要があります。

### チャンクサイズ

現在推奨されている32バイトのチャンクサイズは、いくつかの観察に基づいて選択されています。より小さなチャンクは効率的(つまり[チャンク利用率](https://ethresear.ch/t/some-quick-numbers-on-code-merkelization/7260/3)が高い)ですが、トライの深さが増えるためハッシュのオーバーヘッドが大きくなります。より大きなチャンクは効率が低いですが、ハッシュのオーバーヘッドが小さくなります。最終的な推奨事項を得るために、さまざまなチャンクサイズを比較する大規模な実験を行う予定です。

### 最初の命令オフセット

`firstInstructionOffset`フィールドにより、クライアントがすべてのチャンクを持っていない場合(例えばステートレスクライアントがブロックの証拠を受け取る場合)でも、ジャンプ先の解析が安全に行えます。

注: バイトコードの最後のチャンクでデータバイトが複数バイトの命令に似ている場合、FIOを計算する際のエッジケースが存在する可能性がありますが、これは安全に無視できます。

### コードアクセスオペコードのガスコスト

マークル化されたコードをクライアントのデータベースにどのように格納するかによって、CALL、CALLCODE、DELEGATECALL、STATICCALL、EXTCODESIZE、EXTCODEHASH、EXTCODECOPY などのコードアクセスオペコードのパフォーマンスが影響を受けます。中間ノードを含むコードトライ全体をデータベースに格納すると、呼び出し先のコードを取得するために複数の検索が必要になります。これは現在の1回の検索(トライの走査を除く)よりも多くなります。ただし、CODECOPY とCODESIZEは、現在のコントラクトのコードがすでにメモリにロードされているため、影響を受けません。

このセクションのガスコスト分析は、特定の格納方法を前提としています。この方法では、クライアントはコード作成時に1回だけマークル化してcodeRootを計算しますが、その後チャンクは破棄します。代わりに、完全なバイトコードとメタデータフィールドをデータベースに格納します。呼び出しごとのチャンクメーターリングは、ステートレスモデルでのウィットネスメーターリングによりより簡単に解決できると考えています。

### 異なるチャンク化ロジック

チャンクをパッケージする別のオプションとして、各チャンクにchunkLengthを前置し、完全なオペコードのみを含むようにすることを検討しました(つまり、CHUNK_SIZEに収まらない複数バイトのオペコードは次のチャンクに繰り越されます)。

このアプローチには、指定したものと比べて以下のような欠点があります:
1) 少なくとも33バイトの`CHUNK_SIZE`が必要 - PUSH32命令を収容するため
2) より無駄が多い。例えば、`DUP1 PUSH32 <32バイトペイロード>`は2つのチャンクにエンコードされ、最初のチャンクにはDUP1のみ、2つ目にはPUSH32命令とペイロードが含まれる
3) チャンク数の計算が複雑で、メタデータに明示的に格納する必要がある

さらに、他のオプション(基本ブロックベース、Solidity サブルーチン(制御フローの判断が必要)、EIP-2315 サブルーチンなど)も検討しましたが、この EIPではチャンクベースのオプションに焦点を当てています。

### RLP と SSZ

2進数への移行提案との整合性を保つため、リーフ値のシリアル化にRLPを使用しないことにしました。さらに、データのシリアル化とマークル化にSSZを検討しましたが、簡単さを優先して2進数トライ形式を採用することにしました。

### メタデータフィールド

メタデータフィールドの`version`、`codeLen`、`codeHash`は主に、ステートレスパラダイムにおけるEXTCODESIZEとEXTCODEHASHの実装を安価にするために追加されています。versionフィールドにより、将来的にバイトコードの種類(例えば[EVM1.5/EIP-615](./eip-615.md)、[EIP-2315](./eip-2315.md)など)やコードマークル化スキーム(あるいはマークル化設定、例えば大きな`CHUNK_SIZE`)を区別できます。

`codeHash`と`codeSize`をメタデータに含めるかわりに、アカウントの一部として扱うこともできます。EOAではこれらのフィールドが不要なため、それらを省略するロジックを追加するか、アカウントにそれらを含めるための計算が必要になります。メタデータの方が簡潔だと考えています。

versionフィールドの代替案として、[EIP-1702](./eip-1702.md)に従うか、`accountKind`フィールド(選択肢: `eoa`、`merkleized_evm_chunk32`、`merkleized_eip2315_chunk64`など)をアカウントの最初のメンバーとして追加することも考えられます。これにより、EOAの`codeHash`を省略できる可能性があります。

### コードトライのキー(およびKEY_LENGTH)

上記の仕様で説明したように、コードトライのキーは`chunks`配列のインデックスです。キー長を2バイトにすることで、トライは65536 - 3(メタデータフィールドを除く)個のチャンクをアドレス指定できます。これは約2Mbのコードサイズに相当し、将来のコードサイズ制限の大幅な引き上げ(約85倍)にも対応できます。
### EOAのcodeRootの代替値

この提案では、アカウントの4番目のフィールド(`codeHash`)の意味が変更されます。この変更前は、そのフィールドはバイトコードのKeccak-256ハッシュを表していました。論理的にはEOAの場合は空入力のハッシュになります。

`codeHash`は`codeRoot`に置き換えられるため、新しいルールではEOAの値が異なります: `codeTrie(metadata=[codeHash=keccak256(''), codeSize=0])`のルートです。代替案としては、単に空のトライのハッシュを使用するか、上記の結果を使用せずに`codeRoot = 0`を使用することも考えられます。

しかし、[EIP-1052](./eip-1052.md)との互換性を維持したいため、EOAの場合は空入力のハッシュ(`c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470`)を使用することにしました。

## 下位互換性

コントラクトの観点からは、ガスコストの変更を除いて、設計は透過的になるよう目指しています。

コントラクトが提示するインターフェイス以外では、コントラクトコードの格納方法に大幅な変更が加えられ、Ethereumの状態に大きな変更が必要となるため、ハードフォークを介してのみ導入できます。

## テストケース

TBD

以下のケースの`codeRoot`を示します:

1. `code=''`
2. `code='PUSH1(0) DUP1 REVERT'`
3. `code='PUSH32(-1)'`(データがチャンク境界を越える)

## 実装

チャンク化とマークル化ロジックのTypeScript実装は[こちら](https://github.com/ewasm/biturbo/blob/merklize-mainnet-blocks/src/relayer/bytecode.ts#L172)、Python実装は[こちら](https://github.com/hugo-dc/code-chunks/)にあります。ただし、これらの例では2進数トライは使用していないことに注意してください。

## セキュリティ上の考慮事項

TBA

## 著作権
著作権およびそれに関連する権利は[CC0](../LICENSE.md)で放棄されています。