---
original: 95ee4db276ce311ed541ad0325fc166f842f07cb949321c12ed6b9d0d3ffb888
---

---
eip: 7685
title: 汎用実行レイヤーリクエスト
description: CLとの共有のためのELトリガーリクエストの汎用バス
author: lightclient (@lightclient)
discussions-to: https://ethereum-magicians.org/t/eip-7685-general-purpose-execution-layer-requests/19668
status: レビュー
type: Standards Track
category: コア
created: 2024-04-14
---

## 概要

このプロポーザルは、契約トリガーリクエストを保存するための汎用フレームワークを定義します。実行ヘッダーとボディに1つのフィールドずつ追加し、リクエスト情報を格納します。これにより、リクエストがコンセンサスレイヤーに露出し、処理することができます。

## 動機

スマートコントラクト制御バリデーターの普及により、追加のELトリガー動作に対する需要が高まっています。これらのシステムが管理操作を管理するスマートコントラクトに委任することで、仲介者が介入して特定の操作を確実に行う必要がなくなります。これにより、エンドユーザーにとってより安全なシステムが実現できます。

## 仕様

### 実行レイヤー

#### リクエスト

`request`は、`request_type`を先頭に付けた不透明なバイト配列`request_data`で構成されます:

```
request = request_type ++ request_data
```

`requests`は、ブロック内のすべての`request`オブジェクトをタイプ順に昇順に並べたリストとします。例:

```
[0x00_request_0, 0x01_request_0, 0x01_request_1, 0x02_request_0, ...]
```

同一タイプ内のリクエストの順序は、各リクエストタイプによって定義されます。

#### ブロック構造

ブロックボディにリクエストのリストが追加されます。拡張されたブロックボディ構造のRLP エンコーディングは以下のように計算されます:

```python
block_body_rlp = rlp([
    field_0,
    ...,
    # `requests`の前の最新のブロックボディフィールド
    field_n,
    [request_0, ..., request_k],
])
```

#### ブロックヘッダー

ヘッダーに新しい32バイトの値`requests_root`を追加します。

`requests_root`は、`requests`リストのインデックスをキーとするMerkle-Patricia treeのルートです。これは、トランザクショントリーのルートの計算方法と同等です。

`requests_root`フィールドの値は以下のように計算されます:

```python
def compute_trie_root_from_indexed_data(data):
    trie = Trie.from([(i, obj) for i, obj in enumerate(data)])
    return trie.root

block.header.requests_root = compute_trie_root_from_indexed_data(block.body.requests)
```

### コンセンサスレイヤー

各提案は、新しいELリクエストを含めるようにビーコンチェーンの型を拡張する方法を選択できます。

## 根拠

### 不透明なバイト配列ではなくRLPの配列

`request_data`配列の2バイト目以降を不透明なバイトとし、RLP(または他のエンコーディング)リストではないようにすることで、将来的にSSZ、LEB128、または固定幅フォーマットなどのトランザクションペイロードのエンコーディング形式をサポートできます。

### リクエストのソースと有効性

このEIPでは、リクエストの発信元や、いつ/どのようにリクエストを検証するかについて厳密な要件を設けていません。これは、将来のプロトコル設計者に最大限の柔軟性を提供するためです。

リクエストのソースと有効性に関する著者の推奨事項は以下の通りです:

* リクエストのソースは、トランザクションの実行から来るべきです。具体的には、指定のシステムコントラクトに呼び出しを行い、そのコントラクトに要求を保存するトランザクションです。後にシステムコールによってストレージから取り出され、リクエストに変換されます。あるいは、システムコールが速度制限に本質的に関心がない場合は、単にイベントを発行し、それをブロック後にシステムで解析してリクエストに変換することもできます。
* リクエストの有効性は、しばしば実行レイヤーでは完全に検証できません。これが、単に「リクエスト」と呼ばれる理由です。それ自体では、行動を触発する権限を持っていません。ELで可能な検証を行い、さらなる検証のためにCLに渡すことを期待しています。

### 順序

タイプ間の順序は昇順です。これは、`requests_root`にコミットされたすべてのリクエストがブロックに見つかったことを検証するプロセスを簡素化するためです。

別の選択肢としては、リクエストがブロック内で生成された順序で並べることも考えられます。多くのリクエストがブロックの最後にシステムコールによって蓄積されると予想されるため、これを強制するのは難しいでしょう。したがって、タイプ順に並べるのが最も簡単な順序付けで、整合性を確保できます。

#### 同一タイプ内

同一タイプ内の順序は定義されていません。これは、このEIPの観点からはリクエストのデータが不透明であるためです。したがって、各リクエストタイプによって個別に決定されます。

## 下位互換性

下位互換性の問題はありません。

## テストケース

TODO

## セキュリティ上の考慮事項

議論が必要です。

## 著作権

著作権およびそれに関連する権利は[CC0](../LICENSE.md)によって放棄されています。